/**
 * Compiled Game Bundle
 * Project: TurnBasedWarfare
 * Generated: 2025-11-17T18:47:28.776Z
 */

window.engine = {
        app: {}
};

// Global bundle namespace
window.COMPILED_GAME = {
    projectName: "TurnBasedWarfare",
    version: "2025-11-17T18:47:28.776Z",
    classRegistry: {},
    libraryClasses: {},
    collections: {
  "components": {
    "Animator": {
      "filePath": "/global/components/js/Animator.js",
      "fileName": "Animator"
    },
    "ArrayTracker": {
      "filePath": "/global/components/js/ArrayTracker.js",
      "fileName": "ArrayTracker"
    },
    "Collider": {
      "filePath": "/global/components/js/Collider.js",
      "fileName": "Collider"
    },
    "AudioManager": {
      "filePath": "/global/components/js/AudioManager.js",
      "fileName": "AudioManager"
    },
    "Effect": {
      "filePath": "/global/components/js/Effect.js",
      "fileName": "Effect"
    },
    "PlayerController": {
      "filePath": "/global/components/js/PlayerController.js",
      "fileName": "PlayerController"
    },
    "MapManager": {
      "filePath": "/global/components/js/MapManager.js",
      "fileName": "MapManager"
    },
    "Projectile": {
      "filePath": "/global/components/js/Projectile.js",
      "fileName": "Projectile"
    },
    "Physics": {
      "filePath": "/global/components/js/Physics.js",
      "fileName": "Physics"
    },
    "Stats": {
      "filePath": "/global/components/js/Stats.js",
      "fileName": "Stats"
    },
    "ThreeJsWorld": {
      "filePath": "/global/components/js/ThreeJsWorld.js",
      "fileName": "ThreeJsWorld"
    },
    "InfiniWorld": {
      "fileName": "InfiniWorld",
      "parameters": "[\"world\", \"palette\"]",
      "updateInEditor": true,
      "filePath": "/global/components/js/InfiniWorld.js"
    },
    "Transform": {
      "fileName": "Transform",
      "filePath": "/global/components/js/Transform.js"
    },
    "MultiplayerManager": {
      "fileName": "MultiplayerManager",
      "filePath": "/global/components/js/MultiplayerManager.js"
    }
  },
  "editorModules": {
    "aiPromptModule": {
      "title": "AI Prompt Modal",
      "library": "AIPromptPanel",
      "interface": "aiPromptPanel"
    },
    "audioModule": {
      "title": "Audio Editor",
      "container": "audio-editor-container",
      "propertyName": "audio",
      "interface": "audioEditor",
      "inputElement": "textarea",
      "inputDataType": "json",
      "loadHook": "editAudio",
      "saveHook": "saveAudio",
      "libraries": [
        "Component",
        "AudioEditor"
      ]
    },
    "compilerModule": {
      "title": "Game Compiler",
      "library": "CompilerModule",
      "propertyName": "compiler",
      "libraries": [
        "jszip.min.js",
        "Compiler",
        "CompilerModule"
      ],
      "interface": "compilerInterface"
    },
    "exportScriptModule": {
      "title": "Export Scripts Module",
      "library": "ZipExporter"
    },
    "graphicsModule": {
      "title": "Graphics Editor",
      "container": "graphics-editor-container",
      "libraries": [
        "threejs",
        "three_OrbitControls",
        "GLTFLoader",
        "ShapeFactory",
        "ModelManager",
        "GE_AnimationManager",
        "GE_EventManager",
        "GE_GizmoManager",
        "GE_GroupManager",
        "GE_ShapeManager",
        "GE_RotationUtils",
        "GE_SceneRenderer",
        "GE_UIManager",
        "GE_EquipmentEditor",
        "GraphicsEditor"
      ],
      "propertyName": "render",
      "interface": "graphicsEditor",
      "inputElement": "textarea",
      "inputDataType": "json",
      "loadHook": "renderGraphicsObject",
      "saveHook": "saveGraphicsObject"
    },
    "sceneModule": {
      "title": "Scene Editor",
      "container": "scene-editor-container",
      "libraries": [
        "threejs",
        "three_OrbitControls",
        "three_SkeletonUtils",
        "three_EffectComposer",
        "three_OutputPass",
        "three_RenderPixelatedPass",
        "GLTFLoader",
        "ShapeFactory",
        "GameState",
        "TileMap",
        "SimplexNoise",
        "TerrainGenerator",
        "ModelManager",
        "SE_GizmoManager",
        "SceneEditor"
      ],
      "propertyName": "sceneData",
      "interface": "sceneEditor",
      "inputElement": "textarea",
      "inputDataType": "array",
      "loadHook": "renderSceneObject",
      "saveHook": "saveSceneObject"
    },
    "terrainModule": {
      "title": "Terrain Editor",
      "container": "level-editor-container",
      "libraries": [
        "threejs",
        "ShapeFactory",
        "CoordinateTranslator",
        "ImageManager",
        "CanvasUtility",
        "TerrainImageProcessor",
        "TileMap",
        "GE_GroupManager",
        "TerrainMapEditor"
      ],
      "propertyName": "tileMap",
      "interface": "terrainEditor",
      "inputElement": "textarea",
      "inputDataType": "json",
      "loadHook": "editTileMap",
      "saveHook": "saveTileMap"
    },
    "textureEditor": {
      "title": "Texture Editor",
      "container": "texture-editor-container",
      "library": "TextureEditor",
      "propertyName": "image",
      "interface": "TextureEditor",
      "inputElement": "textarea",
      "inputDataType": "string",
      "loadHook": "editTexture",
      "saveHook": "saveTexture"
    },
    "scriptModule": {
      "title": "Script Editor",
      "container": "script-editor-container",
      "interface": "scriptEditor",
      "inputElement": "textarea",
      "inputDataType": "string",
      "libraries": [
        "ScriptEditor"
      ],
      "propertyNames": "[\"script\", \"html\", \"css\"]",
      "loadHook": "editScript",
      "saveHook": "saveScript"
    }
  },
  "interfaces": {
    "aiPromptPanel": {
      "title": "AI Prompt Panel",
      "modals": [
        "aiPromptPanel"
      ],
      "fileName": "aiPromptPanel"
    },
    "compilerInterface": {
      "title": "Compiler Interface",
      "fileName": "compilerInterface",
      "filePath": "/global/interfaces/css/compilerInterface.css",
      "modals": [
        "compilerModal"
      ],
      "css": ".compiler-modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.7);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 10000;\n}\n\n.compiler-modal .modal-content {\n    background: #2d2d30;\n    border-radius: 8px;\n    width: 600px;\n    max-width: 90%;\n    max-height: 90vh;\n    overflow-y: auto;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n}\n\n.compiler-modal .modal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 20px;\n    border-bottom: 1px solid #3e3e42;\n}\n\n.compiler-modal .modal-header h2 {\n    margin: 0;\n    color: #fff;\n}\n\n.compiler-modal .close-btn {\n    background: none;\n    border: none;\n    color: #999;\n    font-size: 24px;\n    cursor: pointer;\n    padding: 0;\n    width: 30px;\n    height: 30px;\n    line-height: 30px;\n    text-align: center;\n}\n\n.compiler-modal .close-btn:hover {\n    color: #fff;\n}\n\n.compiler-modal .modal-body {\n    padding: 20px;\n}\n\n.compiler-modal .form-group {\n    margin-bottom: 15px;\n}\n\n.compiler-modal .form-group label {\n    display: block;\n    margin-bottom: 5px;\n    color: #d4d4d4;\n    font-size: 14px;\n}\n\n.compiler-modal .form-group input[type=\"text\"] {\n    width: 100%;\n    padding: 10px;\n    background: #3c3c3c;\n    border: 1px solid #555;\n    border-radius: 4px;\n    color: #d4d4d4;\n    font-size: 14px;\n}\n\n.compiler-modal .form-group input[type=\"checkbox\"] {\n    margin-right: 8px;\n}\n\n.compiler-modal .compilation-output {\n    background: #1e1e1e;\n    border: 1px solid #3e3e42;\n    border-radius: 4px;\n    padding: 10px;\n    margin-top: 15px;\n}\n\n.compiler-modal .compilation-output h3 {\n    margin: 0 0 10px 0;\n    color: #fff;\n    font-size: 14px;\n}\n\n.compiler-modal .compilation-output pre {\n    margin: 0;\n    color: #d4d4d4;\n    font-family: 'Courier New', monospace;\n    font-size: 12px;\n    white-space: pre-wrap;\n    max-height: 200px;\n    overflow-y: auto;\n}\n\n.compiler-modal .downloads-section {\n    background: #1e1e1e;\n    border: 1px solid #3e3e42;\n    border-radius: 4px;\n    padding: 15px;\n    margin-bottom: 15px;\n}\n\n.compiler-modal .downloads-section h3 {\n    margin: 0 0 10px 0;\n    color: #fff;\n    font-size: 14px;\n}\n\n.compiler-modal .download-link {\n    display: inline-block;\n    padding: 8px 12px;\n    background: #007acc;\n    color: white;\n    text-decoration: none;\n    border-radius: 4px;\n    margin-right: 10px;\n    margin-bottom: 10px;\n    font-size: 14px;\n}\n\n.compiler-modal .download-link:hover {\n    background: #005a9e;\n}\n\n.compiler-modal .modal-footer {\n    padding: 20px;\n    border-top: 1px solid #3e3e42;\n    display: flex;\n    justify-content: flex-end;\n    gap: 10px;\n}\n\n.compiler-modal .btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    font-weight: 600;\n}\n\n.compiler-modal .btn-primary {\n    background: #007acc;\n    color: white;\n}\n\n.compiler-modal .btn-primary:hover {\n    background: #005a9e;\n}\n\n.compiler-modal .btn-secondary {\n    background: #3e3e42;\n    color: #d4d4d4;\n}\n\n.compiler-modal .btn-secondary:hover {\n    background: #505053;\n}\n\n.toolbar-btn {\n    padding: 8px 16px;\n    background: #007acc;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    margin-left: 10px;\n}\n\n.toolbar-btn:hover {\n    background: #005a9e;\n}\n"
    },
    "sceneEditor": {
      "title": "Scene Editor",
      "modals": [],
      "fileName": "sceneEditor",
      "css": "/* =============================================================================\r\n   SCENE EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Scene view */\r\n.scene-editor__scene-view {\r\n    flex: 1;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n\r\n#scene-canvas-container {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#scene-editor-canvas {\r\n    cursor: crosshair;\r\n    outline: none;\r\n}\r\n\r\n/* No selection message */\r\n.scene-editor__no-selection {\r\n    text-align: center;\r\n    padding: var(--editor-spacing-xl);\r\n    color: var(--editor-text-muted);\r\n    font-style: italic;\r\n}\r\n\r\n/* Hierarchy item */\r\n.scene-editor__hierarchy-item {\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    cursor: pointer;\r\n    border-left: 2px solid transparent;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.scene-editor__hierarchy-item:hover {\r\n    background-color: rgba(255, 255, 255, 0.05);\r\n}\r\n\r\n.scene-editor__hierarchy-item--selected {\r\n    background-color: var(--editor-primary);\r\n    border-left-color: var(--editor-primary-hover);\r\n    color: white;\r\n}\r\n\r\n/* Component styling */\r\n.scene-editor__component {\r\n    background-color: var(--editor-bg-light);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n    padding: var(--editor-spacing-md);\r\n}\r\n\r\n.scene-editor__component-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: var(--editor-spacing-sm);\r\n    font-weight: 600;\r\n    color: var(--editor-text-secondary);\r\n}\r\n",
      "filePath": "/global/interfaces/html/sceneEditor.html",
      "html": "<div id=\"scene-editor-container\" class=\"editor-module\">\r\n   <div id=\"scene-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n      <h2 class=\"editor-module__panel-title\">Hierarchy</h2>\r\n      <div id=\"scene-hierarchy\" class=\"editor-module__list editor-module__scroll-y\">\r\n        <!-- Entities will be populated here -->\r\n      </div>\r\n      <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n        <select id=\"scene-addPrefabSelect\" class=\"editor-module__select\"></select>\r\n        <button class=\"editor-module__btn editor-module__btn--secondary\" id=\"scene-addPrefabBtn\">+ Add Prefab</button>\r\n        <button class=\"editor-module__btn editor-module__btn--danger\" id=\"scene-removePrefabBtn\">Remove Selected Prefab</button>\r\n      </div>\r\n   </div>\r\n\r\n   <div class=\"editor-module__canvas-area\">\r\n      <div class=\"editor-module__toolbar\">\r\n        <button id=\"scene-translate-tool\" class=\"editor-module__btn editor-module__btn--active\" title=\"Translate (G)\">\r\n            <span>Move</span>\r\n        </button>\r\n        <button id=\"scene-rotate-tool\" class=\"editor-module__btn\" title=\"Rotate (R)\">\r\n            <span>Rotate</span>\r\n        </button>\r\n        <button id=\"scene-scale-tool\" class=\"editor-module__btn\" title=\"Scale (S)\">\r\n            <span>Scale</span>\r\n        </button>\r\n      </div>\r\n      <div id=\"scene-view\" class=\"scene-editor__scene-view\">\r\n         <div id=\"scene-canvas-container\" class=\"editor-module__grid-background\">\r\n            <canvas id=\"scene-editor-canvas\" class=\"editor-module__canvas\"></canvas>\r\n         </div>\r\n      </div>\r\n   </div>\r\n\r\n   <div id=\"scene-inspector\" class=\"editor-module__sidebar editor-module__sidebar--right\">\r\n      <h2 class=\"editor-module__panel-title\">Inspector</h2>\r\n      <div class=\"editor-module__scroll-y\">\r\n        <div class=\"scene-editor__no-selection\" id=\"scene-noSelection\">\r\n          No entity selected\r\n        </div>\r\n        <div id=\"scene-entityInspector\" style=\"display: none;\">\r\n          <div id=\"scene-components\">\r\n            <!-- Components will be added here dynamically -->\r\n          </div>\r\n          <button class=\"editor-module__btn editor-module__btn--secondary\" id=\"addComponentBtn\">+ Add Component</button>\r\n        </div>\r\n      </div>\r\n   </div>\r\n</div>\r\n"
    },
    "graphicsEditor": {
      "title": "Graphics Editor",
      "modals": [
        "rotateShapes",
        "moveAllShapes",
        "generateIsometric"
      ],
      "fileName": "graphicsEditor",
      "css": "/* =============================================================================\r\n   GRAPHICS EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#graphics-editor-canvas {\r\n    cursor: grab;\r\n    outline: none;\r\n}\r\n\r\n#graphics-editor-canvas:active {\r\n    cursor: grabbing;\r\n}\r\n\r\n/* Equipment list specific styles */\r\n.graphics-editor__equipment-list {\r\n    max-height: 200px;\r\n}\r\n\r\n.graphics-editor__no-equipment {\r\n    text-align: center;\r\n    padding: var(--editor-spacing-xl);\r\n    color: var(--editor-text-muted);\r\n    font-style: italic;\r\n    font-size: 13px;\r\n}\r\n\r\n/* Equipment item styling */\r\n.graphics-editor__equipment-item {\r\n    padding: var(--editor-spacing-md);\r\n    border-bottom: 1px solid var(--editor-border-color);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n}\r\n\r\n.graphics-editor__equipment-item:hover {\r\n    background-color: var(--editor-primary);\r\n}\r\n\r\n.graphics-editor__equipment-item--selected {\r\n    background-color: var(--editor-primary);\r\n    color: white;\r\n}\r\n\r\n.graphics-editor__equipment-item:last-child {\r\n    border-bottom: none;\r\n}\r\n\r\n.graphics-editor__equipment-info {\r\n    display: flex;\r\n    flex-direction: column;\r\n    flex: 1;\r\n}\r\n\r\n.graphics-editor__item-name {\r\n    font-weight: 600;\r\n    font-size: 14px;\r\n}\r\n\r\n.graphics-editor__slot-name {\r\n    color: var(--editor-text-muted);\r\n    font-size: 12px;\r\n}\r\n\r\n.graphics-editor__bone-info {\r\n    font-size: 11px;\r\n    color: var(--editor-text-muted);\r\n    margin-top: var(--editor-spacing-xs);\r\n}\r\n\r\n/* Shape list specific styles */\r\n.graphics-editor__shape-item,\r\n.graphics-editor__group-item {\r\n    user-select: none;\r\n    cursor: grab;\r\n}\r\n\r\n.graphics-editor__shape-item:active,\r\n.graphics-editor__group-item:active {\r\n    cursor: grabbing;\r\n}\r\n\r\n.graphics-editor__group-item {\r\n    border-left: 4px solid var(--editor-primary);\r\n    font-weight: 500;\r\n}\r\n\r\n.graphics-editor__shape-item {\r\n    border-left: 2px solid var(--editor-bg-lighter);\r\n}\r\n\r\n.graphics-editor__group-shapes {\r\n    margin-left: var(--editor-spacing-lg);\r\n    padding: var(--editor-spacing-sm);\r\n    border-left: 2px dashed var(--editor-border-color);\r\n}\r\n\r\n/* Drag states */\r\n.graphics-editor__shape-item.dragging,\r\n.graphics-editor__group-item.dragging {\r\n    opacity: 0.5;\r\n}\r\n\r\n.graphics-editor__group-item.drag-over {\r\n    border-color: var(--editor-success);\r\n    box-shadow: 0 0 8px rgba(34, 197, 94, 0.3);\r\n}\r\n\r\n/* Mode-specific visibility */\r\n#graphics-editor-container.equipment-mode #graphics-toolbar,\r\n#graphics-editor-container.equipment-mode #graphics-lists,\r\n#graphics-editor-container.equipment-mode #inspector {\r\n    display: none !important;\r\n}\r\n\r\n#graphics-editor-container.equipment-mode #equipment-toolbar,\r\n#graphics-editor-container.equipment-mode #equipment-controls,\r\n#graphics-editor-container.equipment-mode #equipment-inspector,\r\n#graphics-editor-container.equipment-mode #equipment-info,\r\n#graphics-editor-container.equipment-mode #selected-equipment-info {\r\n    display: block !important;\r\n}\r\n\r\n#graphics-editor-container.equipment-mode #shape-count,\r\n#graphics-editor-container.equipment-mode #selected-shape {\r\n    display: none !important;\r\n}\r\n\r\n/* Transform buttons */\r\n.graphics-editor__transform-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.graphics-editor__transform-buttons button {\r\n    flex: 1;\r\n}\r\n",
      "filePath": "/global/interfaces/html/graphicsEditor.html",
      "html": "<div id=\"graphics-editor-container\" class=\"editor-module\">\r\n   <div id=\"graphics-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n\r\n      <!-- Standard Graphics Editor Toolbar -->\r\n      <div id=\"toolbar\" class=\"editor-module__toolbar\">\r\n         <div id=\"graphics-toolbar\" class=\"editor-module__toolbar-group editor-module__flex-col editor-module__gap-sm\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-animation\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Animation\">+A</button>\r\n               <button id=\"delete-animation\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Animation\">-A</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-frame\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Frame\">+F</button>\r\n               <button id=\"delete-frame\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Frame\">-F</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"create-group\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Create Group\">+G</button>\r\n               <button id=\"delete-group\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Group\">-G</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-shape\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Shape\">+S</button>\r\n               <button id=\"delete-shape\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Shape\">-S</button>\r\n            </div>\r\n         </div>\r\n         <div id=\"graphics-toolbar-right\" class=\"editor-module__toolbar-group\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"preview-animation\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Preview Animation\">â–¶</button>\r\n               <button id=\"generate-isometric\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Generate Isometric Sprites\">Iso</button>\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment Toolbar -->\r\n         <div id=\"equipment-toolbar\" class=\"editor-module__toolbar-group\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"equipment-add-btn\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Equipment\">+E</button>\r\n               <button id=\"equipment-remove-btn\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Remove Equipment\">-E</button>\r\n               <button id=\"equipment-reset-btn\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Reset Position\">â†»</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"equipment-mode-toggle\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Toggle Equipment Mode\">âš”</button>\r\n               <button id=\"equipment-save-btn\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Save Equipment\">ðŸ’¾</button>\r\n            </div>\r\n         </div>\r\n      </div>\r\n\r\n      <!-- Standard Graphics Editor Lists -->\r\n      <div id=\"graphics-lists\" class=\"editor-module__scroll-y\">\r\n         <div id=\"frame-list\" class=\"editor-module__list\"></div>\r\n         <div id=\"group-list\" class=\"editor-module__list\"></div>\r\n         <div id=\"shape-list\" class=\"editor-module__list\"></div>\r\n      </div>\r\n\r\n      <!-- Equipment Controls -->\r\n      <div id=\"equipment-controls\">\r\n\r\n         <!-- Add Equipment Section -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Add Equipment</h4>\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Item:</label>\r\n               <select id=\"equipment-item-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Select Item...</option>\r\n               </select>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Slot:</label>\r\n               <select id=\"equipment-slot-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Select Slot...</option>\r\n                  <option value=\"mainHand\">Main Hand</option>\r\n                  <option value=\"offHand\">Off Hand</option>\r\n                  <option value=\"head\">Head</option>\r\n                  <option value=\"chest\">Chest</option>\r\n                  <option value=\"back\">Back</option>\r\n                  <option value=\"legs\">Legs</option>\r\n                  <option value=\"feet\">Feet</option>\r\n               </select>\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment List -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment List</h4>\r\n            <div id=\"equipment-list\" class=\"graphics-editor__equipment-list editor-module__scroll-y\">\r\n               <div class=\"graphics-editor__no-equipment\">No equipment loaded</div>\r\n            </div>\r\n         </div>\r\n\r\n      </div>\r\n   </div>\r\n\r\n   <!-- Canvas Container -->\r\n   <div id=\"canvas-container\" class=\"editor-module__canvas-area editor-module__grid-background\">\r\n      <canvas id=\"graphics-editor-canvas\" class=\"editor-module__canvas\"></canvas>\r\n      <div class=\"editor-module__info\">\r\n         <div>Shapes: <span id=\"shape-count\">0</span></div>\r\n         <div>Selected: <span id=\"selected-shape\">None</span></div>\r\n         <div id=\"equipment-info\">Equipment: <span id=\"equipment-count\">0</span></div>\r\n         <div id=\"selected-equipment-info\">Selected: <span id=\"selected-equipment\">None</span></div>\r\n         <div><small>Controls: Left-click to select, Drag to rotate, Right-drag to pan, Scroll to zoom</small></div>\r\n      </div>\r\n   </div>\r\n\r\n   <!-- Right Sidebar -->\r\n   <div id=\"graphics-rightbar\" class=\"editor-module__sidebar editor-module__sidebar--right\">\r\n\r\n      <!-- Standard Inspector -->\r\n      <div id=\"inspector\" class=\"editor-module__scroll-y\"></div>\r\n\r\n      <!-- Equipment Inspector -->\r\n      <div id=\"equipment-inspector\">\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment Attachment</h4>\r\n\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Bone:</label>\r\n               <select id=\"equipment-bone-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Auto-detect</option>\r\n               </select>\r\n            </div>\r\n\r\n            <h5 class=\"editor-module__section-title\">Position Offset</h5>\r\n            <div class=\"editor-module__form-row editor-module__form-row--compact\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">X:</label>\r\n               <input type=\"number\" id=\"equipment-offset-x\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Y:</label>\r\n               <input type=\"number\" id=\"equipment-offset-y\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Z:</label>\r\n               <input type=\"number\" id=\"equipment-offset-z\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n            </div>\r\n\r\n            <h5 class=\"editor-module__section-title\">Rotation (degrees)</h5>\r\n            <div class=\"editor-module__form-row editor-module__form-row--compact\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">X:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-x\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Y:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-y\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Z:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-z\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n            </div>\r\n\r\n            <div class=\"editor-module__message editor-module__message--warning\">\r\n               Select equipment to adjust positioning. Changes apply in real-time.\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment Properties -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment Properties</h4>\r\n            <div id=\"equipment-property-list\">\r\n               <div class=\"graphics-editor__no-equipment\">Select equipment to view properties</div>\r\n            </div>\r\n         </div>\r\n      </div>\r\n\r\n      <!-- JSON Editor -->\r\n      <div id=\"json-editor\" style=\"display: none;\">\r\n        <textarea id=\"json-content\" class=\"editor-module__textarea editor-module__input\" placeholder=\"Edit JSON here...\"></textarea>\r\n      </div>\r\n   </div>\r\n</div>\r\n"
    },
    "terrainEditor": {
      "title": "Terrain Editor",
      "modals": [
        "addTerrainType",
        "generateIsoSprites"
      ],
      "fileName": "terrainEditor",
      "css": "/* =============================================================================\r\n   TERRAIN EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#grid {\r\n    display: block;\r\n    image-rendering: pixelated;\r\n}\r\n\r\n/* Save button styling */\r\n.terrain-editor__save-btn {\r\n    width: 100%;\r\n    font-weight: 600;\r\n}\r\n\r\n/* Terrain list */\r\n.terrain-editor__terrain-list {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__terrain-item {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: var(--editor-spacing-md);\r\n    padding: var(--editor-spacing-md);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    background-color: rgba(255, 255, 255, 0.03);\r\n    border: 1px solid var(--editor-border-color);\r\n    cursor: move;\r\n    user-select: none;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__terrain-item:hover {\r\n    background-color: rgba(255, 255, 255, 0.05);\r\n    transform: translateY(-2px);\r\n}\r\n\r\n.terrain-editor__color-option {\r\n    width: 36px;\r\n    height: 36px;\r\n    min-width: 36px;\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    border: 2px solid transparent;\r\n    flex-shrink: 0;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__color-option--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n.terrain-editor__terrain-label {\r\n    flex-grow: 1;\r\n    font-weight: 500;\r\n}\r\n\r\n.terrain-editor__terrain-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n}\r\n\r\n/* Object controls */\r\n.terrain-editor__object-controls {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__object-controls button {\r\n    flex: 1;\r\n}\r\n\r\n/* Environment objects container */\r\n.terrain-editor__environment-objects {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__environment-type {\r\n    background-color: var(--editor-bg-light);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    overflow: hidden;\r\n    box-shadow: var(--editor-shadow-sm);\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__environment-type:hover {\r\n    box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n.terrain-editor__environment-type-header {\r\n    padding: var(--editor-spacing-md);\r\n    font-weight: 500;\r\n    cursor: pointer;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    background-color: var(--editor-bg-medium);\r\n    color: var(--editor-text-secondary);\r\n    text-transform: capitalize;\r\n}\r\n\r\n.terrain-editor__environment-type-header::after {\r\n    content: 'â–¼';\r\n    font-size: 10px;\r\n    transition: transform 0.2s ease;\r\n}\r\n\r\n.terrain-editor__environment-type-header.open::after {\r\n    transform: rotate(180deg);\r\n}\r\n\r\n.terrain-editor__environment-items {\r\n    padding: var(--editor-spacing-md);\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    gap: var(--editor-spacing-xs);\r\n}\r\n\r\n.terrain-editor__environment-item {\r\n    width: 128px;\r\n    height: 128px;\r\n    border: 2px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    padding: 2px;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background-color: var(--editor-bg-light);\r\n    transition: var(--editor-transition);\r\n    position: relative;\r\n}\r\n\r\n.terrain-editor__environment-item:hover {\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: translateY(-2px);\r\n}\r\n\r\n.terrain-editor__environment-item--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n.terrain-editor__environment-item canvas {\r\n    max-width: 100%;\r\n    max-height: 100%;\r\n    object-fit: contain;\r\n}\r\n\r\n/* Tooltip for environment items */\r\n.terrain-editor__environment-item::before {\r\n    content: attr(data-name);\r\n    position: absolute;\r\n    bottom: calc(100% + 5px);\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    background-color: var(--editor-bg-dark);\r\n    color: var(--editor-text-primary);\r\n    text-align: center;\r\n    border-radius: var(--editor-border-radius-sm);\r\n    padding: var(--editor-spacing-xs) var(--editor-spacing-sm);\r\n    font-size: 12px;\r\n    white-space: nowrap;\r\n    visibility: hidden;\r\n    opacity: 0;\r\n    transition: var(--editor-transition);\r\n    z-index: 10;\r\n    pointer-events: none;\r\n    box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n.terrain-editor__environment-item:hover::before {\r\n    visibility: visible;\r\n    opacity: 1;\r\n}\r\n\r\n/* Object preview canvas (dragging) */\r\n#object-preview-canvas {\r\n    transition: transform 0.05s ease-out;\r\n    will-change: transform;\r\n    image-rendering: pixelated;\r\n    position: absolute;\r\n    pointer-events: none;\r\n    z-index: 9999;\r\n    opacity: 0.7;\r\n}\r\n\r\n/* Delete mode indicator */\r\n.terrain-editor--delete-mode .editor-module__canvas-area {\r\n    cursor: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"red\" stroke-width=\"2\"><path d=\"M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2\"/><path d=\"M10 11v6M14 11v6\"/></svg>'), auto;\r\n}\r\n\r\n/* Height level selector */\r\n.terrain-editor__height-levels {\r\n    display: grid;\r\n    grid-template-columns: repeat(3, 1fr);\r\n    gap: var(--editor-spacing-sm);\r\n    margin-top: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__height-btn {\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    background-color: var(--editor-bg-medium);\r\n    border: 1px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    color: var(--editor-text-secondary);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n    font-size: 12px;\r\n    font-weight: 500;\r\n}\r\n\r\n.terrain-editor__height-btn:hover {\r\n    background-color: var(--editor-bg-light);\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.terrain-editor__height-btn.active {\r\n    background-color: var(--editor-primary);\r\n    border-color: var(--editor-primary);\r\n    color: white;\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n/* Tool buttons */\r\n.terrain-editor__tool-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-top: var(--editor-spacing-xs);\r\n}\r\n\r\n.terrain-editor__tool-buttons button {\r\n    flex: 1;\r\n}\r\n\r\n/* Slider styling */\r\n.editor-module__slider {\r\n    flex: 1;\r\n    height: 4px;\r\n    border-radius: 2px;\r\n    background: var(--editor-bg-medium);\r\n    outline: none;\r\n    -webkit-appearance: none;\r\n    margin: 0 var(--editor-spacing-sm);\r\n}\r\n\r\n.editor-module__slider::-webkit-slider-thumb {\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    width: 16px;\r\n    height: 16px;\r\n    border-radius: 50%;\r\n    background: var(--editor-primary);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.editor-module__slider::-moz-range-thumb {\r\n    width: 16px;\r\n    height: 16px;\r\n    border-radius: 50%;\r\n    background: var(--editor-primary);\r\n    cursor: pointer;\r\n    border: none;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.editor-module__slider::-webkit-slider-thumb:hover {\r\n    background: var(--editor-primary-hover);\r\n    transform: scale(1.2);\r\n}\r\n\r\n.editor-module__slider::-moz-range-thumb:hover {\r\n    background: var(--editor-primary-hover);\r\n    transform: scale(1.2);\r\n}\r\n\r\n.editor-module__value-display {\r\n    min-width: 20px;\r\n    text-align: center;\r\n    font-weight: 500;\r\n    color: var(--editor-text-primary);\r\n}\r\n\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .terrain-editor__environment-items {\r\n        justify-content: center;\r\n    }\r\n\r\n    .terrain-editor__environment-item {\r\n        width: 80px;\r\n        height: 80px;\r\n    }\r\n\r\n    .terrain-editor__height-levels {\r\n        grid-template-columns: repeat(2, 1fr);\r\n    }\r\n}\r\n",
      "filePath": "/global/interfaces/html/terrainEditor.html",
      "html": "<div id=\"level-editor-container\" class=\"editor-module\">\r\n   <div class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n     <div class=\"editor-module__toolbar\">\r\n       <button id=\"terrainsBtn\" class=\"editor-module__btn editor-module__btn--active\">Tiles</button>\r\n       <button id=\"heightsBtn\" class=\"editor-module__btn\">Heights</button>\r\n       <button id=\"environmentBtn\" class=\"editor-module__btn\">Env</button>\r\n       <button id=\"rampsBtn\" class=\"editor-module__btn\">Ramps</button>\r\n       <button id=\"placementsBtn\" class=\"editor-module__btn\">Entities</button>\r\n     </div>\r\n\r\n     <div class=\"editor-module__scroll-y\">\r\n       <div id=\"terrainsPanel\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Map Settings</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label for=\"terrainMapSize\" class=\"editor-module__label\">Map Size:</label>\r\n             <input type=\"number\" id=\"terrainMapSize\" class=\"editor-module__input\" value=\"48\" step=\"1\" min=\"1\">\r\n           </div>\r\n           <div class=\"editor-module__form-row\">\r\n              <label for=\"extensionTerrainType\" class=\"editor-module__label\">Surrounding Type:</label>\r\n              <select id=\"extensionTerrainType\" class=\"editor-module__select extensionTerrainType\"></select>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n              <button id=\"saveMapBtn\" class=\"editor-module__btn editor-module__btn--success terrain-editor__save-btn\">ðŸ’¾ Save Map</button>\r\n            </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Tools</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label class=\"editor-module__label\">Tool:</label>\r\n             <div class=\"terrain-editor__tool-buttons\">\r\n               <button id=\"terrainBrushBtn\" class=\"editor-module__btn editor-module__btn--small editor-module__btn--active\">Brush</button>\r\n               <button id=\"terrainFillBtn\" class=\"editor-module__btn editor-module__btn--small\">Fill</button>\r\n             </div>\r\n           </div>\r\n           <div class=\"editor-module__form-row\" id=\"terrainBrushSizeRow\">\r\n             <label for=\"terrainBrushSize\" class=\"editor-module__label\">Brush Size:</label>\r\n             <input type=\"range\" id=\"terrainBrushSize\" class=\"editor-module__slider\" value=\"1\" step=\"1\" min=\"1\" max=\"5\">\r\n             <span id=\"terrainBrushSizeValue\" class=\"editor-module__value-display\">1</span>\r\n           </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Terrain Types</h3>\r\n           <div class=\"terrain-editor__terrain-list\">\r\n             <!-- Terrain items will be dynamically populated here -->\r\n           </div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"environmentPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Environment Objects</h3>\r\n           <div class=\"terrain-editor__object-controls\">\r\n             <button class=\"editor-module__btn editor-module__btn--small\" id=\"clear-selection-btn\">Clear Selection</button>\r\n             <button class=\"editor-module__btn editor-module__btn--small editor-module__btn--danger\" id=\"delete-mode-btn\">Delete Mode</button>\r\n           </div>\r\n           <div class=\"terrain-editor__environment-objects\"></div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"rampsPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Ramp Placement</h3>\r\n           <div class=\"editor-module__info-box\">\r\n             <p>Click on tiles to place/remove ramps. Ramps allow units to walk between different terrain heights.</p>\r\n             <p><strong>Current ramps:</strong> <span id=\"rampCount\">0</span></p>\r\n           </div>\r\n           <div class=\"terrain-editor__object-controls\">\r\n             <button class=\"editor-module__btn editor-module__btn--small editor-module__btn--danger\" id=\"clear-all-ramps-btn\">Clear All Ramps</button>\r\n           </div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"heightsPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Height Map Editor</h3>\r\n           <div class=\"editor-module__info-box\">\r\n             <p>Paint height levels on the map. Heights are independent of terrain types.</p>\r\n             <p>Click on tiles to paint the selected height level.</p>\r\n           </div>\r\n           <div class=\"editor-module__form-row\">\r\n             <label for=\"heightLevel\" class=\"editor-module__label\">Height Level:</label>\r\n             <input type=\"number\" id=\"heightLevel\" class=\"editor-module__input\" value=\"0\" step=\"1\" min=\"0\" max=\"10\">\r\n           </div>\r\n           <div class=\"editor-module__section\">\r\n             <h4 class=\"editor-module__section-title\">Quick Select</h4>\r\n             <div class=\"terrain-editor__height-levels\" id=\"heightLevelButtons\">\r\n               <!-- Height level buttons will be dynamically populated here -->\r\n             </div>\r\n           </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Tools</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label class=\"editor-module__label\">Tool:</label>\r\n             <div class=\"terrain-editor__tool-buttons\">\r\n               <button id=\"heightBrushBtn\" class=\"editor-module__btn editor-module__btn--small editor-module__btn--active\">Brush</button>\r\n               <button id=\"heightFillBtn\" class=\"editor-module__btn editor-module__btn--small\">Fill</button>\r\n             </div>\r\n           </div>\r\n           <div class=\"editor-module__form-row\" id=\"heightBrushSizeRow\">\r\n             <label for=\"heightBrushSize\" class=\"editor-module__label\">Brush Size:</label>\r\n             <input type=\"range\" id=\"heightBrushSize\" class=\"editor-module__slider\" value=\"1\" step=\"1\" min=\"1\" max=\"5\">\r\n             <span id=\"heightBrushSizeValue\" class=\"editor-module__value-display\">1</span>\r\n           </div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"placementsPanel\" style=\"display: none;\">\r\n         <!-- Panel content will be dynamically generated by setupPlacementsPanel() -->\r\n       </div>\r\n     </div>\r\n   </div>\r\n\r\n   <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n     <canvas id=\"grid\" class=\"editor-module__canvas\"></canvas>\r\n\r\n     <div class=\"editor-module__status-bar\">\r\n       Cursor: x: 0, y: 0 | Zoom: 100% | Selected: Grass\r\n     </div>\r\n   </div>\r\n </div>\r\n"
    },
    "scriptEditor": {
      "title": "Script Editor",
      "fileName": "scriptEditor",
      "css": "/* =============================================================================\r\n   SCRIPT EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Code container */\r\n.script-editor__code-container {\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.script-editor__code {\r\n    flex: 1;\r\n    height: 100%;\r\n    font-family: 'Courier New', 'Monaco', 'Menlo', monospace;\r\n    font-size: 14px;\r\n    line-height: 1.5;\r\n}\r\n\r\n/* Override global scrollbar suppression for CodeMirror */\r\n#script-editor-container .CodeMirror {\r\n    overflow-y: auto !important;\r\n    -ms-overflow-style: auto !important;\r\n    scrollbar-width: auto !important;\r\n    height: 100%;\r\n    font-size: 14px;\r\n}",
      "filePath": "/global/interfaces/html/scriptEditor.html",
      "html": "<div id=\"script-editor-container\" class=\"editor-module\">\r\n    <div id=\"script-editor-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Script Editor</h3>\r\n            <button id=\"save-script-btn\" class=\"editor-module__btn editor-module__btn--primary\">Save Script</button>\r\n        </div>\r\n    </div>\r\n    <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n        <div class=\"script-editor__code-container\">\r\n            <textarea id=\"script-editor\" class=\"editor-module__textarea editor-module__input script-editor__code\" placeholder=\"Enter your script here...\"></textarea>\r\n            <div class=\"handle\"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n"
    },
    "audioEditor": {
      "title": "Audio Editor",
      "fileName": "audioEditor",
      "css": "/* =============================================================================\r\n   AUDIO EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Value display for sliders */\r\n.audio-editor__value-display {\r\n    float: right;\r\n    font-weight: 600;\r\n    color: var(--editor-primary);\r\n    font-size: 12px;\r\n}\r\n\r\n/* Waveform display area */\r\n.audio-editor__waveform-display {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background-color: var(--editor-bg-dark);\r\n    position: relative;\r\n}\r\n\r\n.audio-editor__waveform-display::before {\r\n    content: 'ðŸŽµ Waveform Visualization';\r\n    color: var(--editor-text-muted);\r\n    font-size: 24px;\r\n}\r\n\r\n/* Status container */\r\n#status-container {\r\n    background-color: var(--editor-bg-light);\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    text-align: center;\r\n    font-size: 12px;\r\n    color: var(--editor-text-secondary);\r\n}\r\n",
      "filePath": "/global/interfaces/html/audioEditor.html",
      "html": "<div id=\"audio-editor-container\" class=\"editor-module\">\r\n    <div class=\"editor-module__sidebar editor-module__sidebar--left editor-module__scroll-y\">\r\n        <div id=\"status-container\" class=\"editor-module__status-bar\">\r\n            <span id=\"status-message\">Ready</span>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"playBtn\" class=\"editor-module__btn editor-module__btn--primary\">Play</button>\r\n                <button id=\"exportBtn\" class=\"editor-module__btn editor-module__btn--success\">Save</button>\r\n                <button id=\"randomSoundBtn\" class=\"editor-module__btn editor-module__btn--secondary\">ðŸŽ² Randomize Sound</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Basic Parameters</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Waveform:</label>\r\n                <select id=\"waveform\" class=\"editor-module__select\">\r\n                    <option value=\"sine\">Sine</option>\r\n                    <option value=\"square\">Square</option>\r\n                    <option value=\"sawtooth\">Sawtooth</option>\r\n                    <option value=\"triangle\">Triangle</option>\r\n                    <option value=\"noise\">Noise</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Frequency: <span class=\"audio-editor__value-display\">440 Hz</span></label>\r\n                <input type=\"range\" id=\"frequency\" class=\"editor-module__range\" min=\"20\" max=\"2000\" value=\"440\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Duration: <span class=\"audio-editor__value-display\">1.00 s</span></label>\r\n                <input type=\"range\" id=\"duration\" class=\"editor-module__range\" min=\"0.1\" max=\"5\" value=\"1\" step=\"0.1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Volume: <span class=\"audio-editor__value-display\">70%</span></label>\r\n                <input type=\"range\" id=\"volume\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0.7\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Noise Generator</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Type:</label>\r\n                <select id=\"noiseType\" class=\"editor-module__select\">\r\n                    <option value=\"white\">White</option>\r\n                    <option value=\"pink\">Pink</option>\r\n                    <option value=\"brown\">Brown</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Amount: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"noiseAmount\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Filter:</label>\r\n                <select id=\"noiseFilterType\" class=\"editor-module__select\">\r\n                    <option value=\"none\">None</option>\r\n                    <option value=\"lowpass\">Low Pass</option>\r\n                    <option value=\"highpass\">High Pass</option>\r\n                    <option value=\"bandpass\">Band Pass</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Filter Freq: <span class=\"audio-editor__value-display\">2000 Hz</span></label>\r\n                <input type=\"range\" id=\"noiseFilterFreq\" class=\"editor-module__range\" min=\"20\" max=\"20000\" value=\"2000\" step=\"1\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Envelope (ADSR)</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Attack: <span class=\"audio-editor__value-display\">0.010 s</span></label>\r\n                <input type=\"range\" id=\"attack\" class=\"editor-module__range\" min=\"0.001\" max=\"2\" value=\"0.01\" step=\"0.001\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Decay: <span class=\"audio-editor__value-display\">0.10 s</span></label>\r\n                <input type=\"range\" id=\"decay\" class=\"editor-module__range\" min=\"0\" max=\"2\" value=\"0.1\" step=\"0.001\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Sustain: <span class=\"audio-editor__value-display\">70%</span></label>\r\n                <input type=\"range\" id=\"sustain\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0.7\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Release: <span class=\"audio-editor__value-display\">0.30 s</span></label>\r\n                <input type=\"range\" id=\"release\" class=\"editor-module__range\" min=\"0.001\" max=\"5\" value=\"0.3\" step=\"0.001\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Pitch Envelope</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Start: <span class=\"audio-editor__value-display\">1.00x</span></label>\r\n                <input type=\"range\" id=\"pitchEnvStart\" class=\"editor-module__range\" min=\"0.1\" max=\"4\" value=\"1\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">End: <span class=\"audio-editor__value-display\">1.00x</span></label>\r\n                <input type=\"range\" id=\"pitchEnvEnd\" class=\"editor-module__range\" min=\"0.1\" max=\"4\" value=\"1\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Effects</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Type:</label>\r\n                <select id=\"filterType\" class=\"editor-module__select\">\r\n                    <option value=\"lowpass\">Low Pass</option>\r\n                    <option value=\"highpass\">High Pass</option>\r\n                    <option value=\"bandpass\">Band Pass</option>\r\n                    <option value=\"notch\">Notch</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Frequency: <span class=\"audio-editor__value-display\">1000 Hz</span></label>\r\n                <input type=\"range\" id=\"filterFreq\" class=\"editor-module__range\" min=\"20\" max=\"20000\" value=\"1000\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Q: <span class=\"audio-editor__value-display\">Q: 1.0</span></label>\r\n                <input type=\"range\" id=\"filterQ\" class=\"editor-module__range\" min=\"0.1\" max=\"20\" value=\"1\" step=\"0.1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Distortion: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"distortion\" class=\"editor-module__range\" min=\"0\" max=\"100\" value=\"0\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Delay Time: <span class=\"audio-editor__value-display\">0.30 s</span></label>\r\n                <input type=\"range\" id=\"delayTime\" class=\"editor-module__range\" min=\"0\" max=\"2\" value=\"0.3\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Delay Feedback: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"delayFeedback\" class=\"editor-module__range\" min=\"0\" max=\"0.9\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Reverb: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"reverbAmount\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Bitcrusher: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"bitcrusher\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Panning: <span class=\"audio-editor__value-display\">Center</span></label>\r\n                <input type=\"range\" id=\"panning\" class=\"editor-module__range\" min=\"-1\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"editor-module__canvas-area audio-editor__waveform-display\">\r\n        <!-- Waveform visualization will go here -->\r\n    </div>\r\n</div>\r\n"
    },
    "TextureEditor": {
      "title": "Texture Editor",
      "fileName": "TextureEditor",
      "css": "/* =============================================================================\r\n   TEXTURE EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#texture-canvas {\r\n    background-color: transparent;\r\n    image-rendering: pixelated;\r\n    border: 1px solid var(--editor-border-color);\r\n    box-shadow: var(--editor-shadow-md);\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    transform: translate(-50%, -50%);\r\n}\r\n\r\n/* No texture message */\r\n.texture-editor__no-texture-message {\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    transform: translate(-50%, -50%);\r\n    color: var(--editor-text-muted);\r\n    font-size: 14px;\r\n    pointer-events: none;\r\n}\r\n\r\n/* Color palette grid */\r\n.texture-editor__color-palette {\r\n    display: grid;\r\n    grid-template-columns: repeat(4, 1fr);\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.texture-editor__color-btn {\r\n    width: 100%;\r\n    aspect-ratio: 1;\r\n    border: 2px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.texture-editor__color-btn:hover {\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: scale(1.1);\r\n}\r\n\r\n.texture-editor__color-btn--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}",
      "filePath": "/global/interfaces/html/TextureEditor.html",
      "html": "<div id=\"texture-editor-container\" class=\"editor-module\">\r\n    <div class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Tools</h3>\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"brush-tool\" class=\"editor-module__btn editor-module__btn--active\">Brush</button>\r\n                <button id=\"eraser-tool\" class=\"editor-module__btn\">Eraser</button>\r\n                <button id=\"fill-tool\" class=\"editor-module__btn\">Fill</button>\r\n                <button id=\"eyedropper-tool\" class=\"editor-module__btn\">Eyedropper</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Brush Size</h3>\r\n            <div class=\"editor-module__form-row\">\r\n                <input type=\"range\" id=\"brush-size\" class=\"editor-module__range\" min=\"1\" max=\"10\" value=\"1\">\r\n                <span id=\"brush-size-display\">1px</span>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Colors</h3>\r\n            <div id=\"color-palette\" class=\"texture-editor__color-palette\"></div>\r\n            <div class=\"editor-module__form-row\">\r\n                <input type=\"color\" id=\"custom-color-picker\" class=\"editor-module__color-picker\" value=\"#000000\">\r\n                <label for=\"custom-color-picker\" class=\"editor-module__label\">Custom Color</label>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n                <label for=\"transparency-slider\" class=\"editor-module__label\">Opacity:</label>\r\n                <input type=\"range\" id=\"transparency-slider\" class=\"editor-module__range\" min=\"0\" max=\"255\">\r\n                <span id=\"transparency-display\">100%</span>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Actions</h3>\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"new-btn\" class=\"editor-module__btn\">New</button>\r\n                <button id=\"undo-btn\" class=\"editor-module__btn\" disabled>Undo</button>\r\n                <button id=\"redo-btn\" class=\"editor-module__btn\" disabled>Redo</button>\r\n                <button id=\"clear-btn\" class=\"editor-module__btn editor-module__btn--danger\">Clear</button>\r\n                <button class=\"export-btn editor-module__btn editor-module__btn--primary\">Save</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Import</h3>\r\n            <input type=\"file\" class=\"editor-module__input\" accept=\"image/*\">\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n        <canvas id=\"texture-canvas\" class=\"editor-module__canvas\"></canvas>\r\n        <div id=\"noTextureMessage\" class=\"texture-editor__no-texture-message\">No texture loaded</div>\r\n    </div>\r\n</div>\r\n"
    },
    "createOrJoinRoom": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/interfaces/html/createOrJoinRoom.html",
      "fileName": "createOrJoinRoom",
      "html": "<div class=\"setup-content\" style=\"background: #1a1a1a; padding: 2rem; border: 2px solid #444; border-radius: 10px; text-align: center; color: white;\">\r\n    <h2>âš”ï¸ Arena âš”ï¸</h2>\r\n    <p>Battle against another player in real-time strategic combat.</p>\r\n    \r\n    <div class=\"player-name-input\" style=\"margin: 1rem 0;\">\r\n        <label for=\"playerName\">Your Name:</label><br>\r\n        <input type=\"text\" id=\"playerName\" placeholder=\"Enter your name\" maxlength=\"20\" value=\"Player\" \r\n                style=\"padding: 0.5rem; margin: 0.5rem; border: 1px solid #666; background: #333; color: white;\">\r\n    </div>\r\n    \r\n    <div class=\"multiplayer-options\" style=\"margin: 1.5rem 0;\">\r\n            <button id=\"createRoomBtn\" class=\"btn btn-primary\" style=\"padding: 0.75rem 1.5rem; margin: 0.5rem; background: #0066cc; border: none; color: white; cursor: pointer; border-radius: 5px;\">Create Room</button><br>\r\n            <div class=\"room-join-section\" style=\"margin-top: 1rem;\">\r\n                <input type=\"text\" id=\"roomIdInput\" value=\"1000\" placeholder=\"Enter Room ID\" maxlength=\"6\" \r\n                        style=\"padding: 0.5rem; border: 1px solid #666; background: #333; color: white;\">\r\n                <button id=\"joinRoomBtn\" class=\"btn btn-secondary\" \r\n                        style=\"padding: 0.5rem 1rem; margin-left: 0.5rem; background: #666; border: none; color: white; cursor: pointer; border-radius: 5px;\">Join Room</button>\r\n            </div>\r\n                    <button id=\"quickMatchBtn\" class=\"btn btn-primary\" \r\n                style=\"padding: 1rem 2rem; margin: 0.5rem; background: #0066cc; border: none; color: white; cursor: pointer; border-radius: 5px; font-size: 1.2rem;\">\r\n            ðŸŽ¯ Find Game\r\n        </button>\r\n        <p style=\"color: #999; font-size: 0.9rem; margin-top: 1rem;\">\r\n            You'll be matched with an available opponent or<br>\r\n            wait for another player to join your game.\r\n        </p>\r\n    </div>\r\n    \r\n    <button id=\"cancelMultiplayerBtn\" class=\"btn btn-secondary\" \r\n            style=\"padding: 0.5rem 1rem; background: #666; border: none; color: white; cursor: pointer; border-radius: 5px;\">Cancel</button>\r\n</div>"
    },
    "main": {
      "title": "Main Interface",
      "modals": [],
      "fileName": "main",
      "css": "/* Import fantasy fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&display=swap');\r\n\r\n/* === RESET & BASE === */\r\n* {\r\n    margin: 0;\r\n    padding: 0;\r\n    box-sizing: border-box;\r\n}\r\n\r\n:root {\r\n    /* Fantasy Color Palette */\r\n    --primary-gold: #d4af37;\r\n    --secondary-gold: #b8860b;\r\n    --accent-amber: #daa520;\r\n    --deep-forest: #1b3d1b;\r\n    --medium-forest: #2d4a2b;\r\n    --light-forest: #3d5a3b;\r\n    --forest-brown: #4a3f2a;\r\n    --dark-brown: #3d2f1f;\r\n    --medium-brown: #5d4037;\r\n    --light-brown: #6d4c41;\r\n    --stone-gray: #8d7053;\r\n    --warm-gray: #a68b5b;\r\n    --cream: #f5e6b3;\r\n    --dark-green: #0f2f0f;\r\n    --blood-red: #8b0000;\r\n    --dark-bronze: #8B7355;\r\n    --mystic-blue: #4169E1;\r\n    --rich-purple: #8A2BE2;\r\n    --shadow-black: #000000;\r\n    --parchment: #F5E6B3;\r\n    --forest-green: #1b5e20;\r\n    \r\n    /* Gradients */\r\n    --gold-gradient: linear-gradient(135deg, var(--primary-gold), var(--secondary-gold));\r\n    --forest-gradient: linear-gradient(135deg, var(--deep-forest), var(--medium-forest));\r\n    --earth-gradient: linear-gradient(135deg, var(--dark-brown), var(--medium-brown));\r\n    --natural-gradient: linear-gradient(135deg, var(--forest-brown), var(--medium-brown));\r\n    --command-gradient: linear-gradient(135deg, var(--dark-brown), var(--forest-brown));\r\n    \r\n    /* Typography */\r\n    --font-decorative: 'Cinzel Decorative', serif;\r\n    --font-title: 'Cinzel', serif;\r\n    --font-body: 'MedievalSharp', cursive;\r\n}\r\n\r\nbody {\r\n    font-family: var(--font-body);\r\n    background-color: var(--dark-green);\r\n    color: var(--cream);\r\n    overflow: hidden;\r\n    height: 100vh;\r\n}\r\n\r\n/* Screen Management */\r\n.screen {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100vh;\r\n    display: none;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n}\r\n\r\n.screen.active {\r\n    display: flex;\r\n}\r\n\r\n/* Main Menu Screen */\r\n#mainMenu {\r\n    text-align: center;\r\n}\r\n\r\n#mainMenu, #gameModeSelect, #multiplayerLobby {\r\n    background-color: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.3));\r\n    background-image: url('resources/images/background.png');\r\n    background-size: cover;\r\n    background-position: center center;\r\n    background-repeat: no-repeat;\r\n    overflow-y: auto;\r\n    padding: 2rem;\r\n}\r\n\r\nbody.bg2 #mainMenu, body.bg2 #gameModeSelect, body.bg2 #multiplayerLobby {\r\n    background-image: url('resources/images/background2.png');\r\n}\r\n\r\nbody.bg3 #mainMenu, body.bg3 #gameModeSelect, body.bg3 #multiplayerLobby {\r\n    background-image: url('resources/images/background3.png');\r\n}\r\n\r\n\r\nbody.bg4 #mainMenu, body.bg4 #gameModeSelect, body.bg4 #multiplayerLobby {\r\n    background-image: url('resources/images/background4.png');\r\n}\r\n\r\nbody.bg5 #mainMenu, body.bg5 #gameModeSelect, body.bg5 #multiplayerLobby {\r\n    background-image: url('resources/images/background5.png');\r\n}\r\n\r\n.game-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: clamp(2.5rem, 8vw, 5rem);\r\n    font-weight: 700;\r\n    color: var(--primary-gold);\r\n    text-shadow: 2px 2px 3px var(--dark-green);\r\n    background-clip: text;\r\n    margin-bottom: 1rem;\r\n    animation: titleGlow 3s ease-in-out infinite alternate;\r\n    position: relative;\r\n}\r\n\r\n@keyframes titleGlow {\r\n    from {\r\n        filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.5));\r\n    }\r\n    to {\r\n        filter: drop-shadow(0 0 30px rgba(212, 175, 55, 0.8));\r\n    }\r\n}\r\n\r\n.subtitle {\r\n    font-family: var(--font-title);\r\n    font-size: 1.2rem;\r\n    color: var(--cream);\r\n    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);\r\n    margin-bottom: 3rem;\r\n    font-style: italic;\r\n}\r\n\r\n\r\n.main-menu-buttons {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 1rem;\r\n    min-width: 300px;\r\n}\r\n\r\n\r\n\r\n/* Game Mode Selection */\r\n.mode-selection {\r\n    text-align: center;\r\n    max-width: 1000px;\r\n    width: 100%;\r\n}\r\n\r\n.mode-selection h2 {\r\n    font-family: var(--font-decorative);\r\n    font-size: 2.5rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 2rem;    \r\n    text-shadow: 2px 2px 3px var(--dark-green);\r\n}\r\n\r\n.mode-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n    gap: 2rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.mode-card {\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.8), rgba(13, 10, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 12px;\r\n    padding: 2rem;\r\n    cursor: pointer;\r\n    transition: all 0.4s ease;\r\n    text-align: center;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n.mode-card::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: -50%;\r\n    left: -50%;\r\n    width: 200%;\r\n    height: 200%;\r\n    background: radial-gradient(circle, rgba(212, 175, 55, 0.1) 0%, transparent 70%);\r\n    opacity: 0;\r\n    transition: opacity 0.4s ease;\r\n    z-index: 0;\r\n}\r\n\r\n.mode-card:hover::before {\r\n    opacity: 1;\r\n}\r\n\r\n.mode-card:hover {\r\n    transform: translateY(-8px) scale(1.02);\r\n    border-color: var(--primary-gold);\r\n    box-shadow: \r\n        0 15px 40px rgba(212, 175, 55, 0.2),\r\n        0 0 30px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.mode-card.selected {\r\n    border-color: var(--accent-amber);\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.4),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.1);\r\n}\r\n\r\n.mode-card > * {\r\n    position: relative;\r\n    z-index: 1;\r\n}\r\n\r\n.mode-icon {\r\n    font-size: 3.5rem;\r\n    margin-bottom: 1rem;\r\n    display: block;\r\n}\r\n\r\n.mode-title {\r\n    font-family: var(--font-title);\r\n    font-size: 1.4rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 0.8rem;\r\n    font-weight: 600;\r\n}\r\n\r\n.mode-description {\r\n    font-size: 0.95rem;\r\n    color: var(--stone-gray);\r\n    margin-bottom: 1.2rem;\r\n    line-height: 1.4;\r\n}\r\n\r\n.mode-difficulty {\r\n    display: inline-block;\r\n    padding: 0.4rem 1rem;\r\n    border-radius: 20px;\r\n    font-size: 0.8rem;\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.easy { \r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(27, 94, 32, 0.3);\r\n}\r\n\r\n.medium { \r\n    background: linear-gradient(135deg, var(--accent-amber), #f57c00);\r\n    color: var(--shadow-black);\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.3);\r\n}\r\n\r\n.hard { \r\n    background: linear-gradient(135deg, var(--blood-red), #c62828);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(183, 28, 28, 0.3);\r\n}\r\n\r\n.expert { \r\n    background: linear-gradient(135deg, var(--rich-purple), #6a1b9a);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(74, 20, 140, 0.3);\r\n}\r\n\r\n/* Game Screen */\r\n#gameScreen {\r\n    background: var(--shadow-black);\r\n    justify-content: flex-start;\r\n    align-items: flex-start;\r\n}\r\n\r\n#gameContainer {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#canvasContainer {\r\n    position: absolute;\r\n    width: calc(100% - 380px);\r\n    height: 100%;\r\n    left: 0;\r\n    top: 0;\r\n}\r\n\r\n#gameCanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    background: \r\n        radial-gradient(circle at 30% 70%, rgba(27, 94, 32, 0.08) 0%, transparent 50%),\r\n        radial-gradient(circle at 70% 30%, rgba(139, 0, 0, 0.08) 0%, transparent 50%),\r\n        #2a3a2a;\r\n    border-left: 2px solid var(--medium-brown);\r\n    cursor: crosshair;\r\n}\r\n\r\n#miniMapContainer {\r\n    min-width: 200px;\r\n    width: 200px;\r\n    height: 200px;\r\n    rotate: -45deg;\r\n    margin: 2em;\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    padding: 0.1rem;\r\n}\r\n\r\n#actionPanel {\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    padding: 0.8rem;\r\n    min-height: 200px;\r\n    min-width: 200px;\r\n    max-width: 200px;\r\n    max-height: 200px;\r\n}\r\n\r\n#selectedUnits {\r\n  max-height: 200px;\r\n  width: 100%;\r\n  display: flex;\r\n  gap: .5em;\r\n  pointer-events: none !important;\r\n  flex-wrap: wrap;\r\n}\r\n\r\n#selectedUnits > div {\r\n    display: flex;\r\n    width: 32px;\r\n    height: 32px;\r\n    pointer-events: all;\r\n}\r\n\r\n#selectedUnits > div > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n\r\n#selectedUnits > div.selected {\r\n    border: 2px solid  rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n}\r\n\r\n#unitPortrait {\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    height: 128px;\r\n    width: 128px;\r\n    min-width: 128px;\r\n    max-width: 128px;\r\n}\r\n\r\n#unitPortrait > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n#gameControls {\r\n    position: absolute;\r\n    bottom: calc(200px + 2em);\r\n    right: 1em;\r\n    width: 200px;\r\n    margin: auto;\r\n}\r\n#undoBtn { display: none;}\r\n#uiContainer {\r\n    pointer-events: none;\r\n    display: flex;\r\n    position: absolute;\r\n    bottom: 1em;\r\n    left: 1em;\r\n    right: 1em;\r\n    align-items: flex-end;\r\n    gap: 1em;\r\n    justify-content: space-between;\r\n}\r\n#uiContainer > div {\r\n    pointer-events: all;\r\n}\r\n/* Buttons */\r\n.btn {\r\n    background: var(--gold-gradient);\r\n    color: var(--shadow-black);\r\n    border: 2px solid var(--secondary-gold);\r\n    padding: 12px 30px;\r\n    font-family: var(--font-title);\r\n    font-weight: 600;\r\n    font-size: 14px;\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n    cursor: pointer;\r\n    border-radius: .5em;\r\n    position: relative;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.btn::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: -2px;\r\n    left: -2px;\r\n    right: -2px;\r\n    bottom: -2px;\r\n    background: linear-gradient(45deg, var(--primary-gold), var(--accent-amber), var(--primary-gold));\r\n    z-index: -1;\r\n    opacity: 0;\r\n    transition: opacity 0.3s ease;\r\n    border-radius: .5em;\r\n}\r\n\r\n.btn:hover::before {\r\n    opacity: 1;\r\n}\r\n\r\n.btn:hover {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.4);\r\n}\r\n\r\n.btn:active {\r\n    transform: translateY(0);\r\n}\r\n\r\n.btn-secondary {\r\n    background: var(--mystical-gradient);\r\n    color: var(--parchment);\r\n    border-color: var(--mystic-blue);\r\n}\r\n\r\n.btn-secondary:hover {\r\n    box-shadow: 0 8px 20px rgba(21, 101, 192, 0.4);\r\n}\r\n\r\n.btn-danger {\r\n    background: linear-gradient(135deg, var(--blood-red), #d32f2f);\r\n    color: var(--parchment);\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.btn-danger:hover {\r\n    box-shadow: 0 8px 20px rgba(183, 28, 28, 0.4);\r\n}\r\n\r\n/* UI Components for Game */\r\n#resourcesContainer {\r\n    display: flex;\r\n    gap: 1em;\r\n    position: absolute;\r\n    top: 1em;\r\n    right: 1em;\r\n}\r\n.resource-label {\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.resource-value {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    font-size: 1.1rem;\r\n    text-shadow: 0 0 5px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.unit-shop {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.unit-card {\r\n    background: linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    cursor: pointer;\r\n    text-align: center;\r\n    transition: all 0.3s ease;\r\n    font-size: 0.85rem;\r\n    position: relative;\r\n    overflow: hidden;\r\n    animation: cardSlideIn 0.3s ease-out;\r\n}\r\n\r\n.unit-card::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: -100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.2), transparent);\r\n    transition: left 0.5s ease;\r\n}\r\n\r\n.unit-card:hover::before {\r\n    left: 100%;\r\n}\r\n\r\n.unit-card:hover {\r\n    border-color: var(--primary-gold);\r\n    transform: translateY(-3px) scale(1.02);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.3), 0 0 15px rgba(212, 175, 55, 0.2);\r\n}\r\n.unit-card:hover .shimmer {\r\n    left: 100%;\r\n}\r\n.unit-card:hover .unit-icon {\r\n    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);\r\n    border-color: var(--primary-gold);\r\n    transform: scale(1.05);\r\n}\r\n\r\n.unit-card.selected {\r\n    border-color: var(--accent-amber);\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.4), inset 0 0 10px rgba(255, 140, 0, 0.1);\r\n    background: linear-gradient(145deg, rgba(74, 20, 140, 0.3), rgba(114, 47, 55, 0.3));\r\n    transform: translateY(-3px) scale(1.02);\r\n}\r\n.unit-card.selected .unit-icon {\r\n    box-shadow: 0 0 12px rgba(255, 140, 0, 0.6);\r\n    border-color: var(--accent-amber);\r\n    transform: scale(1.1);\r\n}\r\n\r\n.unit-card.disabled {\r\n    opacity: 0.4;\r\n    cursor: not-allowed;\r\n    filter: grayscale(0.7);\r\n}\r\n\r\n.unit-card.disabled:hover {\r\n    transform: none;\r\n    border-color: var(--dark-bronze);\r\n    box-shadow: none;\r\n}\r\n.unit-card.disabled:hover .shimmer {\r\n    left: -100%;\r\n}\r\n.unit-card.disabled .unit-icon {\r\n    filter: grayscale(1) brightness(0.6);\r\n    opacity: 0.5;\r\n}\r\n.unit-card.disabled:hover .unit-icon {\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n    border-color: var(--dark-bronze);\r\n    transform: scale(1);\r\n}\r\n/* Add these CSS styles to your main.css or in a <style> tag */\r\n\r\n/* Unit Icon Styles */\r\n.unit-icon {\r\n    width: 24px;\r\n    height: 24px;\r\n    object-fit: cover;\r\n    vertical-align: middle;\r\n    margin-right: 6px;\r\n    border-radius: 3px;\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n    transition: all 0.2s ease;\r\n    border: 1px solid var(--dark-bronze);\r\n    background: rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n/* Hover effects for icons */\r\n.unit-card:hover .unit-icon {\r\n    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);\r\n    border-color: var(--primary-gold);\r\n    transform: scale(1.05);\r\n}\r\n\r\n/* Selected card icon effects */\r\n.unit-card.selected .unit-icon {\r\n    box-shadow: 0 0 12px rgba(255, 140, 0, 0.6);\r\n    border-color: var(--accent-amber);\r\n    transform: scale(1.1);\r\n}\r\n\r\n/* Disabled card icon effects */\r\n.unit-card.disabled .unit-icon {\r\n    filter: grayscale(1) brightness(0.6);\r\n    opacity: 0.5;\r\n}\r\n\r\n/* Alternative styling for larger icons if you prefer */\r\n.unit-icon-large {\r\n    width: 32px;\r\n    height: 32px;\r\n    object-fit: cover;\r\n    vertical-align: middle;\r\n    margin-right: 8px;\r\n    border-radius: 4px;\r\n    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    background: rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n/* Icon error handling - fallback styling */\r\n.unit-icon:not([src]),\r\n.unit-icon[src=\"\"] {\r\n    background: linear-gradient(45deg, var(--dark-bronze), var(--primary-gold));\r\n    display: inline-block;\r\n    position: relative;\r\n}\r\n\r\n.unit-icon:not([src])::before,\r\n.unit-icon[src=\"\"]::before {\r\n    content: \"âš”ï¸\";\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translate(-50%, -50%);\r\n    font-size: 16px;\r\n}\r\n\r\n/* Rarity-based icon effects */\r\n.unit-card.rarity-rare:hover {\r\n    border-color: #4169E1;\r\n    box-shadow: 0 8px 20px rgba(65, 105, 225, 0.4), 0 0 15px rgba(65, 105, 225, 0.2);\r\n}\r\n\r\n.unit-card.rarity-epic:hover {\r\n    border-color: #8A2BE2;\r\n    box-shadow: 0 8px 20px rgba(138, 43, 226, 0.4), 0 0 15px rgba(138, 43, 226, 0.2);\r\n}\r\n\r\n.unit-card.rarity-legendary:hover {\r\n    border-color: var(--primary-gold);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.6), 0 0 20px rgba(255, 215, 0, 0.4);\r\n}\r\n\r\n/* Rarity background effects */\r\n.unit-card.rarity-rare {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(65, 105, 225, 0.3) 0%, transparent 70%);\r\n    border-color: #4169E1;\r\n}\r\n\r\n.unit-card.rarity-epic {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(138, 43, 226, 0.3) 0%, transparent 70%);\r\n    border-color: #8A2BE2;\r\n}\r\n\r\n.unit-card.rarity-legendary {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(255, 215, 0, 0.3) 0%, transparent 70%);\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n/* Legendary border animation */\r\n.unit-card.rarity-legendary .legendary-border {\r\n    position: absolute;\r\n    top: -2px;\r\n    left: -2px;\r\n    right: -2px;\r\n    bottom: -2px;\r\n    border-radius: 10px;\r\n    background: linear-gradient(45deg, var(--primary-gold), var(--accent-amber), var(--primary-gold));\r\n    animation: legendaryBorder 3s ease-in-out infinite;\r\n    z-index: -1;\r\n    pointer-events: none;\r\n}\r\n\r\n/* Unit cost color states */\r\n.unit-cost.cost-affordable {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.unit-cost.cost-unaffordable {\r\n    color: var(--blood-red);\r\n}\r\n\r\n@keyframes cardSlideIn {\r\n    from {\r\n        opacity: 0;\r\n        transform: translateY(20px);\r\n    }\r\n    to {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n    }\r\n}\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .unit-icon {\r\n        width: 20px;\r\n        height: 20px;\r\n        margin-right: 4px;\r\n    }\r\n}\r\n\r\n/* Loading placeholder for icons */\r\n.unit-icon[loading] {\r\n    background: linear-gradient(90deg, \r\n        rgba(212, 175, 55, 0.1) 25%, \r\n        rgba(212, 175, 55, 0.2) 50%, \r\n        rgba(212, 175, 55, 0.1) 75%);\r\n    background-size: 200% 100%;\r\n    animation: shimmer 2s infinite;\r\n}\r\n\r\n@keyframes shimmer {\r\n    0% { background-position: -200% 0; }\r\n    100% { background-position: 200% 0; }\r\n}\r\n.unit-name {\r\n    font-family: var(--font-title);\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n    margin-bottom: 6px;\r\n    font-size: 0.9rem;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n}\r\n\r\n.unit-name img {\r\n    width: 24px; \r\n    height: 24px; \r\n    object-fit: cover; \r\n    vertical-align: middle; \r\n    margin-right: 6px; \r\n    border-radius: 3px;\r\n}\r\n\r\n.unit-cost {\r\n    color: var(--accent-amber); \r\n    font-size: 0.8rem; \r\n    margin-bottom: 6px; \r\n    font-weight: bold;\r\n}\r\n\r\n.unit-stats {\r\n    font-size: 0.75rem; \r\n    line-height: 1.2;\r\n}\r\n\r\n.spec-unit-preview {\r\n    margin-top: 8px;\r\n    padding: 6px;\r\n    background: rgba(255, 170, 0, 0.1);\r\n    border-radius: 4px;\r\n    font-size: 10px;\r\n    color: #ffaa00;\r\n    position: relative;\r\n    z-index: 2;\r\n    border: 1px solid rgba(255, 170, 0, 0.3);\r\n}\r\n\r\n.army-list {\r\n    max-height: 200px;\r\n    overflow-y: auto;\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 0.8rem;\r\n    margin-top: 1rem;\r\n}\r\n\r\n.army-unit {\r\n    padding: 0.8rem;\r\n    margin: 0.3rem 0;\r\n    background: \r\n        linear-gradient(135deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border-radius: 6px;\r\n    border: 1px solid var(--dark-bronze);\r\n    color: var(--parchment);\r\n    font-size: 0.85rem;\r\n    transition: all 0.2s ease;\r\n}\r\n\r\n.army-unit:hover {\r\n    border-color: var(--primary-gold);\r\n    box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);\r\n}\r\n\r\n.stat {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    margin-bottom: 0.5rem;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.stat-label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.ready-status {\r\n    font-weight: bold;\r\n}\r\n\r\n.connection-good {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.connection-waiting {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.connection-bad {\r\n    color: var(--blood-red);\r\n}\r\n\r\n/* Ready Button - Make it prominent */\r\n.ready-btn {\r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    border: 3px solid #388e3c;\r\n    padding: 1rem 2rem;\r\n    border-radius: 8px;\r\n    font-weight: bold;\r\n    cursor: pointer;\r\n    font-family: var(--font-decorative);\r\n    font-size: 1.1rem;\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n    transition: all 0.3s ease;\r\n    box-shadow: \r\n        0 0 20px rgba(27, 94, 32, 0.3),\r\n        0 4px 15px rgba(27, 94, 32, 0.2);\r\n    animation: readyPulse 2s ease-in-out infinite;\r\n}\r\n\r\n.ready-btn:hover {\r\n    background: linear-gradient(135deg, #2e7d32, #388e3c);\r\n    transform: translateY(-3px) scale(1.05);\r\n    box-shadow: \r\n        0 0 30px rgba(27, 94, 32, 0.5),\r\n        0 8px 25px rgba(27, 94, 32, 0.4);\r\n}\r\n\r\n.ready-btn:disabled {\r\n    background: var(--stone-gray);\r\n    color: #666;\r\n    border-color: #666;\r\n    cursor: not-allowed;\r\n    transform: none;\r\n    animation: none;\r\n    box-shadow: none;\r\n}\r\n\r\n.ready-btn.ready-state {\r\n    background: linear-gradient(135deg, var(--accent-amber), #f57c00);\r\n    border-color: var(--accent-amber);\r\n    animation: readyGlow 1.5s ease-in-out infinite alternate;\r\n}\r\n\r\n/* Multiplayer Lobby Enhancements */\r\n.multiplayer-lobby-container {\r\n    max-width: 900px;\r\n    width: 100%;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border-radius: 15px;\r\n    padding: 2rem;\r\n    border: 3px solid var(--primary-gold);\r\n    box-shadow: \r\n        0 0 40px rgba(212, 175, 55, 0.2),\r\n        inset 0 0 40px rgba(212, 175, 55, 0.05);\r\n}\r\n\r\n.lobby-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 2.5rem;\r\n    background: var(--gold-gradient);\r\n    -webkit-background-clip: text;\r\n    -webkit-text-fill-color: transparent;\r\n    background-clip: text;\r\n    margin-bottom: 1rem;\r\n    text-align: center;\r\n}\r\n\r\n.room-info {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.room-id-display {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 1rem;\r\n}\r\n\r\n.room-label {\r\n    color: var(--stone-gray);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.room-id {\r\n    font-family: var(--font-title);\r\n    color: var(--accent-amber);\r\n    font-size: 1.2rem;\r\n    font-weight: bold;\r\n    letter-spacing: 2px;\r\n}\r\n\r\n.connection-status {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n}\r\n\r\n.status-indicator {\r\n    font-size: 1rem;\r\n    font-weight: bold;\r\n}\r\n\r\n/* Players Section */\r\n.players-section {\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.players-section h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 1.8rem;\r\n    margin-bottom: 1.5rem;\r\n    text-align: center;\r\n}\r\n\r\n.players-grid {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 1.5rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.player-card {\r\n    background: \r\n        linear-gradient(145deg, rgba(114, 47, 55, 0.2), rgba(74, 20, 140, 0.2)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 1.5rem;\r\n    text-align: center;\r\n    position: relative;\r\n}\r\n\r\n.player-card.ready {\r\n    border-color: var(--forest-green);\r\n    box-shadow: 0 0 20px rgba(27, 94, 32, 0.3);\r\n}\r\n\r\n.player-card.waiting {\r\n    border-color: var(--accent-amber);\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.3);\r\n}\r\n\r\n.player-card.empty {\r\n    border-color: var(--stone-gray);\r\n    opacity: 0.6;\r\n    border-style: dashed;\r\n}\r\n\r\n.player-name {\r\n    font-family: var(--font-title);\r\n    font-size: 1.2rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 0.8rem;\r\n    font-weight: 600;\r\n}\r\n\r\n.player-status {\r\n    font-size: 1rem;\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.player-status.ready {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.player-status.waiting {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.player-status.empty {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.player-stats {\r\n    font-size: 0.9rem;\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.lobby-status {\r\n    margin-bottom: 2rem;\r\n    text-align: center;\r\n}\r\n\r\n.status-message {\r\n    font-size: 1.3rem;\r\n    color: var(--accent-amber);\r\n    margin-bottom: 1rem;\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.game-progress {\r\n    margin-top: 1rem;\r\n}\r\n\r\n.progress-bar {\r\n    width: 100%;\r\n    height: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    border-radius: 4px;\r\n    overflow: hidden;\r\n    margin-bottom: 0.5rem;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.progress-fill {\r\n    height: 100%;\r\n    background: linear-gradient(90deg, var(--accent-amber), var(--primary-gold));\r\n    width: 0%;\r\n    transition: width 0.3s ease;\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n}\r\n\r\n.progress-text {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.game-info h3 {\r\n    color: var(--primary-gold);\r\n    margin-bottom: 1rem;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.game-settings {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.setting {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.setting-label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.setting-value {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n}\r\n\r\n.lobby-footer {\r\n    border-top: 1px solid var(--dark-bronze);\r\n    padding-top: 2rem;\r\n}\r\n\r\n/* Enhanced Lobby Controls */\r\n.lobby-controls {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    gap: 2rem;\r\n    margin-bottom: 2rem;\r\n    padding: 1.5rem;\r\n    background: rgba(0, 0, 0, 0.2);\r\n    border-radius: 10px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.lobby-controls-left {\r\n    display: flex;\r\n    gap: 1rem;\r\n}\r\n\r\n.lobby-controls-right {\r\n    display: flex;\r\n    gap: 1rem;\r\n}\r\n\r\n\r\n/* Retreat button - less prominent */\r\n#leaveLobbyBtn {\r\n    background: linear-gradient(135deg, var(--stone-gray), #616161);\r\n    color: var(--parchment);\r\n    border: 2px solid #757575;\r\n    padding: 0.8rem 1.5rem;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n#leaveLobbyBtn:hover {\r\n    background: linear-gradient(135deg, #616161, #757575);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.lobby-tips {\r\n    color: var(--stone-gray);\r\n    font-size: 0.9rem;\r\n    line-height: 1.4;\r\n}\r\n\r\n.lobby-tips p {\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n/* Multiplayer Game Screen Styles */\r\n#multiplayerGameScreen {\r\n    background: var(--shadow-black);\r\n    justify-content: flex-start;\r\n    align-items: flex-start;\r\n}\r\n\r\n#multiplayerGameContainer {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#multiplayerCanvasContainer {\r\n    position: absolute;\r\n    width: calc(100% - 380px);\r\n    height: 100%;\r\n    left: 0;\r\n    top: 0;\r\n}\r\n\r\n#multiplayerGameCanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    background: \r\n        radial-gradient(circle at 30% 70%, rgba(27, 94, 32, 0.1) 0%, transparent 50%),\r\n        radial-gradient(circle at 70% 30%, rgba(183, 28, 28, 0.1) 0%, transparent 50%),\r\n        #111111;\r\n    cursor: crosshair;\r\n}\r\n\r\n.opponent-overlay {\r\n    position: absolute;\r\n    top: 10px;\r\n    right: 10px;\r\n    z-index: 100;\r\n}\r\n\r\n.opponent-info-card {\r\n    background: rgba(0, 0, 0, 0.9);\r\n    border: 2px solid var(--blood-red);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n    min-width: 250px;\r\n    color: var(--parchment);\r\n}\r\n\r\n.opponent-info-card h4 {\r\n    color: var(--blood-red);\r\n    margin-bottom: 0.8rem;\r\n    text-align: center;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.opponent-details {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.5rem;\r\n}\r\n\r\n.opponent-details > div {\r\n    display: flex;\r\n    justify-content: space-between;\r\n}\r\n\r\n.opponent-details .label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.status-deploying { color: var(--accent-amber); }\r\n.status-ready { color: var(--forest-green); }\r\n.status-battling { color: var(--blood-red); }\r\n\r\n#multiplayerUIContainer {\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    width: 380px;\r\n    height: 100%;\r\n    background: \r\n        linear-gradient(180deg, rgba(26, 13, 26, 0.95) 0%, rgba(13, 10, 26, 0.95) 50%, rgba(26, 10, 13, 0.95) 100%);\r\n    border-left: 3px solid var(--primary-gold);\r\n    padding: 1.5rem;\r\n    overflow-y: auto;\r\n}\r\n\r\n.multiplayer-player-panel {\r\n    background: \r\n        linear-gradient(145deg, rgba(114, 47, 55, 0.2), rgba(74, 20, 140, 0.2)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 1.5rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.multiplayer-resources {\r\n    background: \r\n        linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(26, 13, 26, 0.4));\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    margin-bottom: 1.5rem;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.multiplayer-unit-shop {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 0.8rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.multiplayer-game-controls {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.multiplayer-phase-info {\r\n    position: absolute;\r\n    bottom: 2rem;\r\n    left: 2rem;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border: 3px solid var(--accent-amber);\r\n    border-radius: 12px;\r\n    padding: 1.5rem;\r\n    min-width: 250px;\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.2),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.05);\r\n}\r\n\r\n.phase-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.versus-info {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n    font-size: 0.9rem;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.player-indicator {\r\n    color: var(--forest-green);\r\n    font-weight: bold;\r\n}\r\n\r\n.vs {\r\n    color: var(--accent-amber);\r\n    font-weight: bold;\r\n}\r\n\r\n.opponent-indicator {\r\n    color: var(--blood-red);\r\n    font-weight: bold;\r\n}\r\n\r\n.multiplayer-phase-info .phase-title {\r\n    font-size: 1.5rem;\r\n    color: var(--accent-amber);\r\n    text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n    margin-bottom: 0.5rem;\r\n    text-align: center;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.phase-info {\r\n    position: absolute;\r\n    bottom: 2rem;\r\n    left: 2rem;\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border: 3px solid var(--accent-amber);\r\n    border-radius: 12px;\r\n    padding: 1.5rem;\r\n    text-align: center;\r\n    min-width: 250px;\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.2),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.05);\r\n}\r\n\r\n.phase-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 1.8rem;\r\n    color: var(--accent-amber);\r\n    text-shadow: 0 0 15px rgba(255, 140, 0, 0.5);\r\n    margin-bottom: 0.8rem;\r\n}\r\n\r\n.phase-timer {\r\n    font-family: var(--font-title);\r\n    font-size: 1.4rem;\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.round-info {\r\n    color: var(--mystic-blue);\r\n    font-family: var(--font-title);\r\n    font-size: 1.1rem;\r\n    margin-bottom: 0.8rem;\r\n}\r\n\r\n/* Victory/Defeat Screens */\r\n#victoryScreen, #defeatScreen {\r\n    text-align: center;\r\n}\r\n\r\n#victoryScreen {\r\n    background: \r\n        radial-gradient(circle at center, rgba(27, 94, 32, 0.2) 0%, transparent 70%),\r\n        var(--shadow-gradient);\r\n}\r\n\r\n#defeatScreen {\r\n    background: \r\n        radial-gradient(circle at center, rgba(183, 28, 28, 0.2) 0%, transparent 70%),\r\n        var(--shadow-gradient);\r\n}\r\n\r\n.result-content {\r\n    max-width: 600px;\r\n    width: 90%;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border-radius: 15px;\r\n    padding: 3rem;\r\n    border: 3px solid var(--primary-gold);\r\n    box-shadow: \r\n        0 0 40px rgba(212, 175, 55, 0.2),\r\n        inset 0 0 40px rgba(212, 175, 55, 0.05);\r\n}\r\n\r\n.result-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 3.5rem;\r\n    margin-bottom: 2rem;\r\n    text-shadow: 0 0 20px currentColor;\r\n}\r\n\r\n.victory-title {\r\n    color: var(--forest-green);\r\n    animation: victoryPulse 2s ease-in-out infinite;\r\n}\r\n\r\n.defeat-title {\r\n    color: var(--blood-red);\r\n    animation: defeatShake 0.5s ease-in-out infinite;\r\n}\r\n\r\n@keyframes victoryPulse {\r\n    0%, 100% { transform: scale(1); }\r\n    50% { transform: scale(1.05); }\r\n}\r\n\r\n@keyframes defeatShake {\r\n    0%, 100% { transform: translateX(0); }\r\n    25% { transform: translateX(-3px); }\r\n    75% { transform: translateX(3px); }\r\n}\r\n\r\n.stats-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(2, 1fr);\r\n    gap: 1rem;\r\n    margin: 2rem 0;\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1.5rem;\r\n    border-radius: 10px;\r\n}\r\n\r\n.victory-stats .stat, .defeat-stats .stat {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    padding: 0.5rem 0;\r\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\r\n}\r\n\r\n.stat-card {\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n}\r\n\r\n.stat-label {\r\n    font-size: 0.9rem;\r\n    color: var(--stone-gray);\r\n    margin-bottom: 0.5rem;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.stat-value {\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n    color: var(--primary-gold);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.victory-controls, .defeat-controls {\r\n    display: flex;\r\n    gap: 1rem;\r\n    justify-content: center;\r\n    margin-top: 2rem;\r\n}\r\n\r\n.victory-controls .btn, .defeat-controls .btn {\r\n    min-width: 150px;\r\n}\r\n\r\n/* Loading Screen */\r\n#loadingScreen {\r\n    background: var(--shadow-gradient);\r\n}\r\n\r\n.loading-content {\r\n    text-align: center;\r\n}\r\n\r\n.loading-spinner {\r\n    width: 60px;\r\n    height: 60px;\r\n    border: 4px solid var(--dark-bronze);\r\n    border-top: 4px solid var(--primary-gold);\r\n    border-radius: 50%;\r\n    animation: spin 1s linear infinite;\r\n    margin: 0 auto 2rem;\r\n    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n.loading-text {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 1.5rem;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.loading-tip {\r\n    color: var(--stone-gray);\r\n    font-style: italic;\r\n    max-width: 400px;\r\n    margin: 0 auto;\r\n    line-height: 1.4;\r\n}\r\n\r\n/* Pause Menu */\r\n.pause-overlay {\r\n    display: none;\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.85);\r\n    z-index: 2000;\r\n    justify-content: center;\r\n    align-items: center;\r\n    backdrop-filter: blur(5px);\r\n}\r\n\r\n.pause-overlay.active {\r\n    display: flex;\r\n}\r\n\r\n.pause-content {\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    border: 3px solid var(--primary-gold);\r\n    border-radius: 15px;\r\n    padding: 3rem;\r\n    text-align: center;\r\n    box-shadow: 0 0 50px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.pause-content h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 2.5rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n/* Battle log styles */\r\n.battle-log {\r\n    background: rgba(0, 0, 0, 0.6);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n    height: 150px;\r\n    overflow-y: auto;\r\n    font-size: 0.8rem;\r\n    margin-top: 1.5rem;\r\n}\r\n\r\n.log-entry {\r\n    margin: 0.3rem 0;\r\n    padding: 0.3rem 0.5rem;\r\n    border-radius: 3px;\r\n    line-height: 1.3;\r\n}\r\n\r\n.log-damage {\r\n    color: #ff6666;\r\n    background: rgba(255, 102, 102, 0.1);\r\n}\r\n\r\n.log-death {\r\n    color: var(--blood-red);\r\n    font-weight: bold;\r\n    background: rgba(183, 28, 28, 0.1);\r\n}\r\n\r\n.log-victory {\r\n    color: var(--forest-green);\r\n    font-weight: bold;\r\n    background: rgba(27, 94, 32, 0.1);\r\n}\r\n\r\n.log-placement {\r\n    color: var(--primary-gold);\r\n    background: rgba(212, 175, 55, 0.1);\r\n}\r\n\r\n/* Experience Panel Styles */\r\n.experience-panel {\r\n    background: linear-gradient(135deg, rgba(255, 140, 0, 0.15), rgba(212, 175, 55, 0.15));\r\n    border-radius: 10px;\r\n    border: 2px solid var(--accent-amber);\r\n    animation: experienceGlow 2s ease-in-out infinite alternate;\r\n    position: relative;\r\n    overflow: hidden;\r\n    padding: 0.5em;\r\n    margin-bottom: 1em;\r\n}\r\n\r\n.experience-panel .experience-squad-info {\r\n    display: flex; \r\n    justify-content: space-between; \r\n    align-items: center; margin-bottom: 6px; position: relative; z-index: 2;\r\n}\r\n\r\n.experience-panel .experience-squad-name {\r\n    color: var(--parchment); font-size: 13px; font-weight: bold; font-family: var(--font-title);\r\n}\r\n\r\n.experience-panel .experience-levelUpCost {\r\n    display: flex; \r\n    justify-content: space-between; \r\n    font-size: 11px; \r\n    margin-bottom: 6px; \r\n    position: relative; \r\n    z-index: 2;\r\n}\r\n\r\n.experience-panel .level-up-button {\r\n    position: relative;\r\n    z-index: 2;   \r\n}\r\n\r\n.experience-panel .level-up-button.level-up-button-spec {\r\n    background: 'linear-gradient(135deg, #cc6600, #ff8800)';\r\n    border-color: '#ffaa00';\r\n    box-shadow: '0 0 15px rgba(255, 170, 0, 0.4)';\r\n}\r\n\r\n.experience-nextLevelSpec {\r\n    color: '#ffaa00'; \r\n    font-size: 12px; \r\n    font-weight: bold;\r\n}\r\n\r\n.experience-nextLevel {    \r\n    color: '#44ff44';\r\n    font-size: 12px; \r\n    font-weight: bold;\r\n}\r\n\r\n.unit-card .shimmer {\r\n    position: absolute;\r\n    top: 0;\r\n    left: -100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.3), transparent);\r\n    transition: left 0.5s ease;\r\n    pointer-events: none;\r\n    z-index: 1;\r\n}\r\n\r\n.insufficientGoldEffect  {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    background: rgba(183, 28, 28, 0.3);\r\n    border-radius: 8px;\r\n    animation: insufficientGoldFlash 0.6s ease-out;\r\n    pointer-events: none;\r\n    z-index: 5;\r\n}\r\n\r\n@keyframes experienceGlow {\r\n    from { box-shadow: 0 0 10px rgba(255, 140, 0, 0.3); }\r\n    to { box-shadow: 0 0 25px rgba(255, 140, 0, 0.6); }\r\n}\r\n.selection-ripple {\r\n    position: absolute;\r\n    width: 20px;\r\n    height: 20px;\r\n    background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);\r\n    border-radius: 50%;\r\n    transform: scale(0);\r\n    animation: selectionRipple 0.6s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n\r\n.level-up-burst {\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    width: 20px;\r\n    height: 20px;\r\n    background: radial-gradient(circle, \r\n        rgba(255, 215, 0, 0.9) 0%, \r\n        rgba(255, 140, 0, 0.6) 50%, \r\n        transparent 100%);\r\n    border-radius: 50%;\r\n    transform: translate(-50%, -50%) scale(0);\r\n    animation: levelUpBurst 1.2s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n\r\n.level-up-sparkle {\r\n    position: absolute;\r\n    width: 4px;\r\n    height: 4px;\r\n    background: var(--primary-gold);\r\n    transform: scale(0);\r\n    animation: sparkle 0.8s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n.experience-bar {\r\n    width: 100%;\r\n    height: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    border-radius: 4px;\r\n    overflow: hidden;\r\n    margin: 0.5rem 0;\r\n    border: 1px solid var(--dark-bronze);\r\n\r\n    position: relative; \r\n    z-index: 2;\r\n}\r\n\r\n.experience-fill {\r\n    height: 100%;\r\n    width: 100%;\r\n    background: linear-gradient(90deg, var(--accent-amber), var(--primary-gold));\r\n    transition: width 0.3s ease;\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n}\r\n\r\n.level-up-button {\r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    border: 2px solid #388e3c;\r\n    padding: 0.5rem 1rem;\r\n    margin: 0.3rem;\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n    font-family: var(--font-title);\r\n    font-size: 0.8rem;\r\n    font-weight: 600;\r\n    transition: all 0.3s ease;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n}\r\n\r\n.level-up-button:hover {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 5px 15px rgba(27, 94, 32, 0.4);\r\n}\r\n\r\n.level-up-button:disabled {\r\n    background: var(--stone-gray);\r\n    border-color: #616161;\r\n    cursor: not-allowed;\r\n    opacity: 0.6;\r\n}\r\n\r\n/* Undo Container */\r\n.undo-container {\r\n    margin-bottom: 1.5rem;\r\n    padding: 1rem;\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.undo-button {\r\n    width: 100%;\r\n    padding: 0.8rem;\r\n    background: linear-gradient(135deg, var(--stone-gray), #616161);\r\n    color: var(--parchment);\r\n    border: 1px solid #757575;\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n    font-family: var(--font-title);\r\n    font-size: 0.9rem;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.undo-button:hover {\r\n    background: linear-gradient(135deg, #616161, #757575);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.undo-button:disabled {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    transform: none;\r\n}\r\n\r\n/* Multiplayer Setup Dialog */\r\n.multiplayer-setup-dialog {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.9);\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    z-index: 3000;\r\n    backdrop-filter: blur(5px);\r\n}\r\n\r\n.setup-content {\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    border: 3px solid var(--primary-gold);\r\n    border-radius: 15px;\r\n    padding: 2.5rem;\r\n    max-width: 500px;\r\n    width: 90%;\r\n    text-align: center;\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 50px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.setup-content h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 2rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.player-name-input {\r\n    margin: 2rem 0;\r\n}\r\n\r\n.player-name-input label {\r\n    display: block;\r\n    margin-bottom: 0.8rem;\r\n    color: var(--stone-gray);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.player-name-input input {\r\n    width: 100%;\r\n    padding: 1rem;\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    color: var(--parchment);\r\n    font-size: 1rem;\r\n    font-family: var(--font-title);\r\n    transition: border-color 0.3s ease;\r\n}\r\n\r\n.player-name-input input:focus {\r\n    border-color: var(--primary-gold);\r\n    outline: none;\r\n    box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.room-join-section {\r\n    margin-top: 1.5rem;\r\n    display: flex;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.room-join-section input {\r\n    flex: 1;\r\n    padding: 1rem;\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    color: var(--parchment);\r\n    text-transform: uppercase;\r\n    font-family: var(--font-title);\r\n    font-weight: bold;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.opponent-info {\r\n    background: rgba(0,0,0,0.8);\r\n    border: 2px solid var(--blood-red);\r\n    border-radius: 5px;\r\n    padding: 1rem;\r\n    color: var(--parchment);\r\n    min-width: 200px;\r\n}\r\n\r\n.opponent-info h4 {\r\n    color: var(--blood-red);\r\n    margin-bottom: 0.5rem;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.opponent-stats div {\r\n    margin: 0.25rem 0;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.multiplayer-notification {\r\n    background: rgba(0,0,0,0.9);\r\n    border: 2px solid;\r\n    border-radius: 5px;\r\n    padding: 1rem 2rem;\r\n    margin: 0.5rem;\r\n    font-weight: bold;\r\n    animation: notificationSlideIn 0.3s ease-out;\r\n}\r\n\r\n.modal {\r\n    position: fixed; \r\n    top: 0; \r\n    left: 0; \r\n    width: 100%; \r\n    height: 100%;\r\n    background: rgba(0,0,0,0.9); \r\n    display: flex; \r\n    justify-content: center;\r\n    align-items: center; \r\n    z-index: 10000;\r\n}\r\n\r\n.team-health-bar {\r\n    background: linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(26, 13, 26, 0.4));\r\n    border: 1px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 0.8rem;\r\n    min-width: 200px;\r\n    text-align: center;\r\n    font-family: 'Courier New', monospace;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.player-health {\r\n    border-color: #00ff00;\r\n}\r\n\r\n.opponent-health {\r\n    border-color: #ff4444;\r\n}\r\n\r\n.team-label {\r\n    font-size: 0.9rem;\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n    text-shadow: 0 0 5px currentColor;\r\n}\r\n\r\n.health-bar-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.3rem;\r\n}\r\n\r\n.health-bar {\r\n    width: 100%;\r\n    height: 20px;\r\n    background: #222;\r\n    border: 1px solid #444;\r\n    border-radius: 10px;\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n\r\n.health-fill {\r\n    height: 100%;\r\n    transition: width 0.5s ease;\r\n    border-radius: 10px;\r\n    position: relative;\r\n}\r\n\r\n.player-fill {\r\n    background: linear-gradient(90deg, #004400 0%, #00aa00 50%, #00ff00 100%);\r\n    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);\r\n}\r\n\r\n.opponent-fill {\r\n    background: linear-gradient(90deg, #440000 0%, #aa0000 50%, #ff4444 100%);\r\n    box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);\r\n}\r\n\r\n.health-text {\r\n    font-size: 0.8rem;\r\n    color: #fff;\r\n    font-weight: bold;\r\n    text-shadow: 1px 1px 2px #000;\r\n}\r\n\r\n.damage-popup {\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n    text-shadow: 2px 2px 4px #000;\r\n    animation: damageFloat 2s ease-out forwards;\r\n    pointer-events: none;\r\n    z-index: 1001;\r\n    color: #ff6666;\r\n}\r\n\r\n@keyframes damageFloat {\r\n    0% {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n        font-size: 1.5rem;\r\n    }\r\n    50% {\r\n        opacity: 1;\r\n        transform: translateY(-30px);\r\n        font-size: 2rem;\r\n    }\r\n    100% {\r\n        opacity: 0;\r\n        transform: translateY(-60px);\r\n        font-size: 1rem;\r\n    }\r\n}\r\n@keyframes notificationSlideIn {\r\n    from {\r\n        transform: translateX(100%);\r\n        opacity: 0;\r\n    }\r\n    to {\r\n        transform: translateX(0);\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\n/* Scrollbar Styling */\r\n::-webkit-scrollbar {\r\n    width: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    border-radius: 4px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n    background: var(--dark-bronze);\r\n    border-radius: 4px;\r\n    transition: background 0.3s ease;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n    background: var(--primary-gold);\r\n}\r\n\r\n/* Responsive Design */\r\n@media (max-width: 768px) {\r\n    .game-title {\r\n        font-size: 2.5rem;\r\n    }\r\n    \r\n    .mode-grid {\r\n        grid-template-columns: 1fr;\r\n    }\r\n    \r\n    #canvasContainer {\r\n        width: 100%;\r\n    }\r\n    \r\n    #uiContainer {\r\n        position: relative;\r\n        width: 100%;\r\n        border-left: none;\r\n        border-top: 3px solid var(--primary-gold);\r\n    }\r\n    \r\n    .phase-info {\r\n        position: relative;\r\n        bottom: auto;\r\n        left: auto;\r\n        margin: 1rem;\r\n    }\r\n\r\n    .unit-shop {\r\n        grid-template-columns: 1fr;\r\n    }\r\n\r\n    #multiplayerCanvasContainer {\r\n        width: 100%;\r\n    }\r\n    \r\n    #multiplayerUIContainer {\r\n        position: relative;\r\n        width: 100%;\r\n        height: auto;\r\n        border-left: none;\r\n        border-top: 3px solid var(--primary-gold);\r\n    }\r\n}\r\n\r\n\r\n\r\n/* Ripple Animation */\r\n@keyframes ripple {\r\n    to {\r\n        transform: scale(4);\r\n        opacity: 0;\r\n    }\r\n}\r\n\r\n@keyframes particleFloat {\r\n    0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }\r\n    10% { opacity: 1; }\r\n    90% { opacity: 1; }\r\n    100% { transform: translate(-100px, -100vh) rotate(360deg); opacity: 0; }\r\n}\r\n\r\n@keyframes shimmer {\r\n    0% { left: -100%; }\r\n    50% { left: 100%; }\r\n    100% { left: 100%; }\r\n}\r\n\r\n@keyframes selectionPulse {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    100% { transform: translate(-50%, -50%) scale(10); opacity: 0; }\r\n}\r\n\r\n@keyframes selectionBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    100% { transform: translate(-50%, -50%) scale(8); opacity: 0; }\r\n}\r\n\r\n@keyframes levelUpBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    50% { transform: translate(-50%, -50%) scale(6); opacity: 0.8; }\r\n    100% { transform: translate(-50%, -50%) scale(12); opacity: 0; }\r\n}\r\n\r\n@keyframes cardSelect {\r\n    0% { transform: scale(1); }\r\n    50% { transform: scale(1.05); }\r\n    100% { transform: scale(1.02); }\r\n}\r\n\r\n@keyframes cardDeselect {\r\n    0% { transform: scale(1.02); }\r\n    100% { transform: scale(1); }\r\n}\r\n\r\n@keyframes copyPulse {\r\n    0%, 100% { transform: scale(1); color: var(--accent-amber); }\r\n    50% { transform: scale(1.1); color: var(--primary-gold); }\r\n}\r\n\r\n@keyframes notificationSlideOut {\r\n    from { transform: translateX(0); opacity: 1; }\r\n    to { transform: translateX(100%); opacity: 0; }\r\n}\r\n\r\n\r\n\r\n @keyframes selectionRipple {\r\n    0% { transform: scale(0); opacity: 1; }\r\n    100% { transform: scale(6); opacity: 0; }\r\n}\r\n\r\n@keyframes insufficientGoldFlash {\r\n    0%, 100% { opacity: 0; }\r\n    50% { opacity: 1; }\r\n}\r\n\r\n@keyframes sparkle {\r\n    0% { transform: scale(0) rotate(0deg); opacity: 1; }\r\n    50% { transform: scale(1) rotate(180deg); opacity: 1; }\r\n    100% { transform: scale(0) rotate(360deg); opacity: 0; }\r\n}\r\n\r\n@keyframes legendaryBorder {\r\n    0%, 100% { opacity: 0.6; transform: scale(1); }\r\n    50% { opacity: 1; transform: scale(1.02); }\r\n}\r\n\r\n@keyframes levelUpBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    50% { transform: translate(-50%, -50%) scale(8); opacity: 0.8; }\r\n    100% { transform: translate(-50%, -50%) scale(15); opacity: 0; }\r\n}\r\n\r\n.unit-card.selected {\r\n    border-color: var(--accent-amber) !important;\r\n    background: linear-gradient(145deg, rgba(74, 20, 140, 0.3), rgba(114, 47, 55, 0.3)) !important;\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.4), inset 0 0 10px rgba(255, 140, 0, 0.1) !important;\r\n    transform: translateY(-3px) scale(1.02) !important;\r\n}\r\n\r\n.unit-card.disabled:hover {\r\n    transform: none !important;\r\n    border-color: var(--dark-bronze) !important;\r\n    box-shadow: none !important;\r\n}\r\n\r\n\r\n@keyframes readyPulse {\r\n    0%, 100% { \r\n        box-shadow: \r\n            0 0 20px rgba(27, 94, 32, 0.3),\r\n            0 4px 15px rgba(27, 94, 32, 0.2);\r\n    }\r\n    50% { \r\n        box-shadow: \r\n            0 0 35px rgba(27, 94, 32, 0.5),\r\n            0 4px 15px rgba(27, 94, 32, 0.2);\r\n    }\r\n}\r\n\r\n@keyframes readyGlow {\r\n    from { \r\n        box-shadow: \r\n            0 0 20px rgba(255, 140, 0, 0.4),\r\n            0 4px 15px rgba(255, 140, 0, 0.3);\r\n    }\r\n    to { \r\n        box-shadow: \r\n            0 0 40px rgba(255, 140, 0, 0.7),\r\n            0 4px 15px rgba(255, 140, 0, 0.3);\r\n    }\r\n}\r\n\r\n@keyframes startGamePulse {\r\n    0%, 100% { \r\n        box-shadow: 0 0 25px rgba(74, 20, 140, 0.4);\r\n    }\r\n    50% { \r\n        box-shadow: 0 0 40px rgba(74, 20, 140, 0.7);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/* Building Shop Container */\r\n#buildingShop {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 8px;\r\n    padding: 10px;\r\n    overflow-y: auto;\r\n    max-height: calc(100vh - 200px);\r\n}\r\n\r\n/* Building Section */\r\n.building-section {\r\n    margin-bottom: 20px;\r\n}\r\n\r\n.building-section-header {\r\n    color: var(--primary-gold);\r\n    font-family: var(--font-title);\r\n    margin-bottom: 10px;\r\n    font-size: 1rem;\r\n}\r\n\r\n/* Building Card */\r\n.building-card {\r\n    background: linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    margin-bottom: 8px;\r\n    cursor: pointer;\r\n    transition: all 0.3s ease;\r\n    font-size: 0.85rem;\r\n    position: relative;\r\n}\r\n\r\n.building-card.owned {\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n.building-card.locked {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.building-card.phase-disabled {\r\n    opacity: 0.6;\r\n    filter: grayscale(0.5);\r\n}\r\n\r\n.building-card.hover {\r\n    transform: scale(1.02) translateY(-2px);\r\n    box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.building-card.shake {\r\n    animation: shake 0.5s;\r\n}\r\n\r\n/* Building Card Header */\r\n.building-card-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.building-card-title {\r\n    font-family: var(--font-title);\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.building-card-progress {\r\n    color: var(--accent-amber);\r\n    font-size: 0.7rem;\r\n}\r\n\r\n/* Building Card Details */\r\n.building-card-cost {\r\n    color: var(--accent-amber);\r\n    font-size: 0.8rem;\r\n    margin-bottom: 6px;\r\n    font-weight: bold;\r\n}\r\n\r\n.building-card-locked {\r\n    color: var(--blood-red);\r\n    font-size: 0.75rem;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.building-card-description {\r\n    font-size: 0.75rem;\r\n    line-height: 1.2;\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.building-card-owned {\r\n    color: var(--forest-green);\r\n    font-size: 0.7rem;\r\n    margin-top: 6px;\r\n}\r\n\r\n/* Upgrade Modal */\r\n.upgrade-modal {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.8);\r\n    z-index: 10000;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    animation: fadeIn 0.2s;\r\n}\r\n\r\n.upgrade-panel {\r\n    background: linear-gradient(145deg, #1a1a2e, #16213e);\r\n    border: 2px solid var(--primary-gold);\r\n    border-radius: 10px;\r\n    padding: 20px;\r\n    max-width: 500px;\r\n    max-height: 80vh;\r\n    overflow-y: auto;\r\n    width: 90%;\r\n}\r\n\r\n.upgrade-panel-header {\r\n    color: var(--primary-gold);\r\n    margin-bottom: 15px;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n/* Upgrade List */\r\n.upgrade-list {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 10px;\r\n    margin-bottom: 15px;\r\n}\r\n\r\n/* Upgrade Card */\r\n.upgrade-card {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    transition: all 0.2s;\r\n}\r\n\r\n.upgrade-card.purchased {\r\n    border-color: var(--forest-green);\r\n}\r\n\r\n.upgrade-card.locked {\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.upgrade-card.available {\r\n    cursor: pointer;\r\n}\r\n\r\n.upgrade-card.available:hover {\r\n    transform: translateX(5px);\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n/* Upgrade Card Header */\r\n.upgrade-card-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: start;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.upgrade-card-name {\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n}\r\n\r\n.upgrade-card-status {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.upgrade-card.purchased .upgrade-card-status {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.upgrade-card.locked .upgrade-card-status {\r\n    color: var(--blood-red);\r\n}\r\n\r\n/* Upgrade Card Details */\r\n.upgrade-card-description {\r\n    color: var(--stone-gray);\r\n    font-size: 0.85rem;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.upgrade-card-requirement {\r\n    color: var(--blood-red);\r\n    font-size: 0.75rem;\r\n}\r\n\r\n/* Upgrade Close Button */\r\n.upgrade-close-button {\r\n    width: 100%;\r\n}\r\n\r\n/* Animations */\r\n@keyframes fadeIn {\r\n    from {\r\n        opacity: 0;\r\n    }\r\n    to {\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\n@keyframes shake {\r\n    0%, 100% {\r\n        transform: translateX(0);\r\n    }\r\n    10%, 30%, 50%, 70%, 90% {\r\n        transform: translateX(-5px);\r\n    }\r\n    20%, 40%, 60%, 80% {\r\n        transform: translateX(5px);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.shop-container {\r\n    display: grid;\r\n    grid-template-columns: 200px 1fr;\r\n    gap: 1rem;\r\n    margin-top: 1rem;\r\n}\r\n\r\n\r\n.action-panel-header {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.6rem;\r\n    font-size: 1.1rem;\r\n    font-weight: bold;\r\n    color: #ffaa00;\r\n    margin-bottom: 1rem;\r\n    padding-bottom: 0.6rem;\r\n    border-bottom: 2px solid rgba(255, 170, 0, 0.3);\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.deselect-btn {\r\n    background: rgba(255, 170, 0, 0.2);\r\n    border: 1px solid rgba(255, 170, 0, 0.5);\r\n    border-radius: 4px;\r\n    padding: 0.3rem 0.6rem;\r\n    color: #ffaa00;\r\n    cursor: pointer;\r\n    font-weight: bold;\r\n    transition: all 0.2s ease;\r\n}\r\n\r\n.deselect-btn:hover {\r\n    background: rgba(255, 170, 0, 0.3);\r\n    border-color: rgba(255, 170, 0, 0.8);\r\n}\r\n\r\n.action-section {\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.action-section:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.action-section-header {\r\n    font-size: 0.85rem;\r\n    font-weight: bold;\r\n    color: #ffaa00;\r\n    margin-bottom: 0.8rem;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n}\r\n\r\n.action-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));\r\n    gap: 0.6rem;\r\n    width: 100%;\r\n}\r\n\r\n.action-btn {\r\n    position: relative;\r\n    background: linear-gradient(145deg, #2a2a3e, #1a1a2e);\r\n    border: 2px solid rgba(255, 170, 0, 0.4);\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n}\r\n\r\n.action-btn:hover:not(.locked):not(.disabled):not(.purchased) {\r\n    background: linear-gradient(145deg, #3a3a4e, #2a2a3e);\r\n    border-color: rgba(255, 170, 0, 0.8);\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 4px 12px rgba(255, 170, 0, 0.3);\r\n}\r\n\r\n.action-btn.locked {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    border-color: rgba(100, 100, 100, 0.4);\r\n}\r\n\r\n.action-btn.disabled {\r\n    opacity: 0.6;\r\n    cursor: not-allowed;\r\n}\r\n\r\n.action-btn.purchased {\r\n    background: linear-gradient(145deg, #2a3a2e, #1a2a1e);\r\n    border-color: rgba(74, 222, 128, 0.6);\r\n    opacity: 0.8;\r\n    cursor: default;\r\n}\r\n\r\n.action-btn-icon {\r\n    font-size: 2rem;\r\n}\r\n\r\n.action-btn-icon > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n\r\n.action-btn-title {\r\n    font-size: 0.75rem;\r\n    font-weight: 600;\r\n    color: #fff;\r\n    text-align: center;\r\n    line-height: 1.2;\r\n}\r\n\r\n.action-btn-cost {\r\n    font-size: 0.75rem;\r\n    color: #ffaa00;\r\n    font-weight: bold;\r\n}\r\n\r\n.action-btn-check {\r\n    color: #4ade80;\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n}\r\n\r\n.action-btn-lock {\r\n    position: absolute;\r\n    top: 4px;\r\n    right: 4px;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.action-btn-tooltip {\r\n    position: absolute;\r\n    bottom: 100%;\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    background: rgba(0, 0, 0, 0.95);\r\n    color: #fff;\r\n    padding: 0.4rem 0.6rem;\r\n    border-radius: 4px;\r\n    font-size: 0.7rem;\r\n    white-space: nowrap;\r\n    opacity: 0;\r\n    pointer-events: none;\r\n    transition: opacity 0.2s ease;\r\n    margin-bottom: 4px;\r\n    z-index: 1000;\r\n}\r\n\r\n.action-btn.locked:hover .action-btn-tooltip {\r\n    opacity: 1;\r\n}\r\n\r\n.action-empty {\r\n    text-align: center;\r\n    color: rgba(255, 255, 255, 0.4);\r\n    font-style: italic;\r\n    padding: 3rem 1rem;\r\n}\r\n\r\n@media (max-width: 768px) {\r\n    .shop-container {\r\n        grid-template-columns: 1fr;\r\n    }\r\n    \r\n    .building-list {\r\n        max-height: 200px;\r\n        display: flex;\r\n        flex-wrap: nowrap;\r\n        overflow-x: auto;\r\n        overflow-y: hidden;\r\n        gap: 0.5rem;\r\n        padding: 0.6rem;\r\n    }\r\n    \r\n    .building-list-item {\r\n        flex-direction: column;\r\n        min-width: 80px;\r\n        margin-bottom: 0;\r\n        padding: 0.5rem;\r\n    }\r\n    \r\n    .building-list-info {\r\n        text-align: center;\r\n    }\r\n    \r\n    .action-grid {\r\n        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));\r\n    }\r\n}",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/interfaces/html/main.html",
      "html": "<!-- Main Menu Screen -->\r\n<div id=\"mainMenu\" class=\"screen active\">\r\n    <div class=\"game-title\">LEGENDS OF THE ARENA</div>\r\n    <div class=\"subtitle\">Where Heroes Rise and Legends Are Forged</div>\r\n    <div class=\"main-menu-buttons\">\r\n        <button id=\"mainMenu_PlayGameBtn\" class=\"btn\">âš”ï¸ ENTER BATTLE</button>\r\n        <button id=\"mainMenu_SettingsBtn\" class=\"btn btn-secondary\">âš™ï¸ SETTINGS</button>\r\n    </div>\r\n</div>\r\n\r\n<!-- Game Mode Selection Screen -->\r\n<div id=\"gameModeSelect\" class=\"screen\">\r\n    <div class=\"mode-selection\">\r\n        <h2>ðŸŽ¯ CHOOSE YOUR DESTINY</h2>\r\n        <div class=\"mode-grid\" id=\"modeGrid\">\r\n            <!-- Game mode cards populated by GameModeManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"gameMode_BackBtn\" class=\"btn btn-secondary\">â† RETURN</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Multiplayer Lobby -->\r\n<div id=\"multiplayerLobby\" class=\"screen\">\r\n    <div class=\"multiplayer-lobby-container\">\r\n        <div class=\"lobby-header\">\r\n            <h1 class=\"lobby-title\">âš”ï¸ WAR COUNCIL</h1>\r\n            <div class=\"room-info\">\r\n                <div class=\"room-id-display\">\r\n                    <span class=\"room-label\">Battle Hall:</span>\r\n                    <span id=\"lobbyRoomId\" class=\"room-id\">------</span>\r\n                    <button id=\"copyRoomIdBtn\" class=\"btn-small\">ðŸ“‹ Copy</button>\r\n                </div>\r\n                <div class=\"connection-status\">\r\n                    <span id=\"connectionStatus\" class=\"status-indicator\">ðŸ”´ Summoning...</span>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"lobby-content\">\r\n            <div class=\"players-section\">\r\n                <h2>âš”ï¸ Warriors (<span id=\"playerCount\">1</span>/2)</h2>\r\n                <div id=\"playersContainer\" class=\"players-grid\">\r\n                    <div class=\"player-card\" id=\"player1Card\">\r\n                        <div class=\"player-name\" id=\"player1Name\">You</div>\r\n                        <div class=\"player-status waiting\" id=\"player1Status\">ðŸŸ¡ Preparing...</div>\r\n                        <div class=\"player-stats\">Ready to battle</div>\r\n                    </div>\r\n                    <div class=\"player-card empty\" id=\"player2Card\">\r\n                        <div class=\"player-name\" id=\"player2Name\">Waiting for opponent</div>\r\n                        <div class=\"player-status empty\" id=\"player2Status\">âšª Empty slot</div>\r\n                        <div class=\"player-stats\">Seeking worthy challenger</div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n\r\n\r\n            <div class=\"lobby-status\">\r\n                <div class=\"status-message\" id=\"lobbyStatusMessage\">Waiting for worthy opponents...</div>\r\n                <div class=\"game-progress\">\r\n                    <div class=\"progress-bar\">\r\n                        <div class=\"progress-fill\" id=\"gameProgressFill\"></div>\r\n                    </div>\r\n                    <div class=\"progress-text\" id=\"gameProgressText\">Preparing battlefield...</div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"game-info\">\r\n                <h3>ðŸ° Battle Configuration</h3>\r\n                <div class=\"game-settings\">\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\">ðŸŽ¯ Game Mode</span>\r\n                        <span class=\"setting-value\" id=\"lobbyGameMode\">Arena Combat</span>\r\n                    </div>\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\">â±ï¸ Turn Timer</span>\r\n                        <span class=\"setting-value\" id=\"lobbyTurnTimer\">30 seconds</span>\r\n                    </div>\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\">ðŸ’° Starting Gold</span>\r\n                        <span class=\"setting-value\" id=\"lobbyStartGold\">100 coins</span>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"lobby-footer\">\r\n                <div class=\"lobby-controls\">\r\n                    <div class=\"lobby-controls-left\">\r\n                        <button id=\"leaveLobbyBtn\" class=\"btn btn-secondary\">ðŸšª Retreat</button>\r\n                    </div>\r\n                    <div class=\"lobby-controls-right\">\r\n                        <button id=\"player1ReadyBtn\" class=\"ready-btn\">ðŸ›¡ï¸ READY FOR BATTLE</button>\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"lobby-tips\">\r\n                    <p>ðŸ—¡ï¸ Prepare your strategies while waiting for opponents</p>\r\n                    <p>ðŸ° Victory requires both tactical skill and wise resource management</p>\r\n                    <p>âš¡ The realm's fate lies in your hands, Commander</p>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Game Screen -->\r\n<div id=\"gameScreen\" class=\"screen\">\r\n    <div id=\"gameContainer\">\r\n        <div id=\"canvasContainer\">\r\n            <canvas id=\"gameCanvas\"></canvas>\r\n        </div>\r\n        <div id=\"resourcesContainer\" class=\"resources\">\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\">ðŸ’°</span>\r\n                <span class=\"resource-value\" id=\"playerGold\">--</span>\r\n            </div>\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\">ðŸ‘¥</span>\r\n                <span class=\"resource-value\" id=\"playerSupplies\">0</span>\r\n            </div>\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\">ðŸ†</span>\r\n                <span class=\"resource-value\" id=\"currentRound\">--</span>\r\n            </div>\r\n        </div>\r\n        <div id=\"unitPromotions\" style=\"display: none\"></div>  \r\n        <div id=\"gameControls\">\r\n            <button id=\"game_ExitBtn\" class=\"btn btn-secondary\" style=\"display:none\">ðŸšª RETREAT</button>\r\n            <button id=\"undoBtn\" class=\"btn btn-secondary\">ðŸ¤¦â€â™‚ï¸ Undo</button>\r\n            <button id=\"placementReadyBtn\" class=\"btn btn-primary\">Ready for Battle!</button>\r\n        </div>\r\n        <div id=\"uiContainer\">              \r\n            <div id=\"miniMapContainer\"></div>\r\n            <div id=\"selectedUnits\"></div>  \r\n            <div id=\"unitPortrait\"></div>            \r\n            <div class=\"action-panel\" id=\"actionPanel\"></div>\r\n        </div>  \r\n    </div>\r\n</div>\r\n\r\n<!-- Victory Screen -->\r\n<div id=\"victoryScreen\" class=\"screen\">\r\n    <div class=\"result-content\">\r\n        <div class=\"result-title victory-title\">ðŸ† GLORIOUS VICTORY! ðŸ†</div>\r\n        <div class=\"stats-grid\" id=\"victoryStats\">\r\n            <!-- Stats populated by ResultsManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"victory_NextRoundBtn\" class=\"btn\">âš¡ NEXT CONQUEST</button>\r\n            <button id=\"victory_RestartBtn\" class=\"btn btn-secondary\">ðŸ”„ RETRY BATTLE</button>\r\n            <button id=\"victory_MainMenuBtn\" class=\"btn btn-secondary\">ðŸ° RETURN HOME</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Defeat Screen -->\r\n<div id=\"defeatScreen\" class=\"screen\">\r\n    <div class=\"result-content\">\r\n        <div class=\"result-title defeat-title\">ðŸ’€ DEFEAT ðŸ’€</div>\r\n        <div class=\"stats-grid\" id=\"defeatStats\">\r\n            <!-- Stats populated by ResultsManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"defeat_RetryBtn\" class=\"btn\">âš¡ SEEK REVENGE</button>\r\n            <button id=\"defeat_ChangeModeBtn\" class=\"btn btn-secondary\">ðŸŽ¯ CHANGE PATH</button>\r\n            <button id=\"defeat_MainMenuBtn\" class=\"btn btn-secondary\">ðŸ° RETURN HOME</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Pause Menu (Overlay) -->\r\n<div id=\"pauseMenu\" class=\"pause-overlay\">\r\n    <div class=\"pause-content\">\r\n        <h2>â³ WAR COUNCIL RECESS</h2>\r\n        <button id=\"paused_ResumeBtn\" class=\"btn\">â–¶ï¸ RETURN TO BATTLE</button>\r\n        <button id=\"paused_RestartBtn\" class=\"btn btn-secondary\">ðŸ”„ RESTART CAMPAIGN</button>\r\n        <button id=\"paused_MainMenuBtn\" class=\"btn btn-secondary\">ðŸ° RETURN HOME</button>\r\n    </div>\r\n</div>\r\n\r\n<!-- Loading Screen -->\r\n<div id=\"loadingScreen\" class=\"screen\">\r\n    <div class=\"loading-content\">\r\n        <div class=\"loading-spinner\"></div>\r\n        <div class=\"loading-text\">ðŸ”® SUMMONING WARRIORS...</div>\r\n        <div class=\"loading-tip\">Tip: Position ranged units behind your frontline for maximum effectiveness</div>\r\n    </div>\r\n</div>"
    }
  },
  "libraries": {
    "CodeMirror.js.min.js": {
      "title": "CodeMirror.js.min.js",
      "href-disabled": "https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/javascript/javascript.min.js",
      "className": "CodeMirror.js",
      "fileName": "CodeMirror.js.min.js"
    },
    "codemirror.min.js": {
      "title": "CodeMirror.min.js",
      "href-disabled": "https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js",
      "className": "CodeMirror",
      "fileName": "codemirror.min.js"
    },
    "jszip.min.js": {
      "title": "jszip.min.js",
      "href": "/node_modules/jszip/dist/jszip.min.js",
      "fileName": "jszip.min.js"
    },
    "Rapier": {
      "fileName": "Rapier",
      "href": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
      "requireName": "RAPIER",
      "importName": "RAPIER",
      "isModule": true
    },
    "socket.io.min.js": {
      "title": "Socket.IO",
      "fileName": "socket.io.min.js",
      "href": "https://cdn.socket.io/4.7.2/socket.io.min.js",
      "isModule": true
    },
    "threejs": {
      "title": "THREE",
      "filePath": "/node_modules/three/build/three.module.min.js",
      "requireName": "THREE",
      "importName": "three",
      "fileName": "threejs",
      "windowName": "THREE",
      "isModule": true
    },
    "three_EffectComposer": {
      "title": "THREE.EffectComposer",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "EffectComposer",
      "importName": "EffectComposer",
      "fileName": "three_EffectComposer"
    },
    "three_OrbitControls": {
      "title": "THREE.OrbitControls",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "OrbitControls",
      "importName": "OrbitControls",
      "fileName": "three_OrbitControls"
    },
    "three_OutputPass": {
      "title": "THREE.OutputPass",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "OutputPass",
      "importName": "OutputPass",
      "fileName": "three_OutputPass"
    },
    "three_PointerLockControls": {
      "title": "THREE.PointerLockControls",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/PointerLockControls.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "PointerLockControls",
      "importName": "PointerLockControls",
      "fileName": "three_PointerLockControls"
    },
    "BaseECSGame": {
      "filePath": "/global/libraries/js/BaseECSGame.js",
      "fileName": "BaseECSGame"
    },
    "BaseSystem": {
      "filePath": "/global/libraries/js/BaseSystem.js",
      "fileName": "BaseSystem"
    },
    "three_RenderPixelatedPass": {
      "title": "THREE.RenderPixelatedPass",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "RenderPixelatedPass",
      "importName": "RenderPixelatedPass",
      "fileName": "three_RenderPixelatedPass"
    },
    "ClientNetworkManager": {
      "filePath": "/global/libraries/js/ClientNetworkManager.js",
      "fileName": "ClientNetworkManager"
    },
    "Compiler": {
      "filePath": "/global/libraries/js/Compiler.js",
      "fileName": "Compiler"
    },
    "CompilerModule": {
      "filePath": "/global/libraries/js/CompilerModule.js",
      "fileName": "CompilerModule"
    },
    "ECSGame": {
      "filePath": "/global/libraries/js/ECSGame.js",
      "fileName": "ECSGame"
    },
    "ECGame": {
      "filePath": "/global/libraries/js/ECGame.js",
      "fileName": "ECGame"
    },
    "GameLoader": {
      "filePath": "/global/libraries/js/GameLoader.js",
      "fileName": "GameLoader"
    },
    "GameRoom": {
      "filePath": "/global/libraries/js/GameRoom.js",
      "fileName": "GameRoom"
    },
    "InputManager": {
      "filePath": "/global/libraries/js/InputManager.js",
      "fileName": "InputManager"
    },
    "MultiplayerECSGame": {
      "filePath": "/global/libraries/js/MultiplayerECSGame.js",
      "fileName": "MultiplayerECSGame"
    },
    "InstancePool": {
      "filePath": "/global/libraries/js/InstancePool.js",
      "fileName": "InstancePool"
    },
    "SceneManager": {
      "filePath": "/global/libraries/js/SceneManager.js",
      "fileName": "SceneManager"
    },
    "SeededRandom": {
      "filePath": "/global/libraries/js/SeededRandom.js",
      "fileName": "SeededRandom"
    },
    "ServerECSGame": {
      "filePath": "/global/libraries/js/ServerECSGame.js",
      "fileName": "ServerECSGame"
    },
    "ServerEventManager": {
      "filePath": "/global/libraries/js/ServerEventManager.js",
      "fileName": "ServerEventManager"
    },
    "ServerGameLoader": {
      "filePath": "/global/libraries/js/ServerGameLoader.js",
      "fileName": "ServerGameLoader"
    },
    "ServerGameRoom": {
      "filePath": "/global/libraries/js/ServerGameRoom.js",
      "fileName": "ServerGameRoom"
    },
    "ServerMatchmakingService": {
      "filePath": "/global/libraries/js/ServerMatchmakingService.js",
      "fileName": "ServerMatchmakingService"
    },
    "ServerNetworkManager": {
      "filePath": "/global/libraries/js/ServerNetworkManager.js",
      "fileName": "ServerNetworkManager"
    },
    "ServerSceneManager": {
      "filePath": "/global/libraries/js/ServerSceneManager.js",
      "fileName": "ServerSceneManager"
    },
    "SE_GizmoManager": {
      "filePath": "/global/libraries/js/SE_GizmoManager.js",
      "fileName": "SE_GizmoManager"
    },
    "PerformanceProfiler": {
      "filePath": "/global/libraries/js/PerformanceProfiler.js",
      "fileName": "PerformanceProfiler"
    },
    "SceneEditor": {
      "filePath": "/global/libraries/js/SceneEditor.js",
      "fileName": "SceneEditor"
    },
    "AIPromptPanel": {
      "fileName": "AIPromptPanel",
      "filePath": "/global/libraries/js/AIPromptPanel.js"
    },
    "BufferGeometryUtils": {
      "title": "THREE.BufferGeometryUtils",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "BufferGeometryUtils",
      "importName": "BufferGeometryUtils",
      "filePath": "/global/libraries/js/BufferGeometryUtils.js",
      "fileName": "BufferGeometryUtils"
    },
    "ExportScripts": {
      "fileName": "ExportScripts",
      "filePath": "/global/libraries/js/ExportScripts.js"
    },
    "CanvasUtility": {
      "fileName": "CanvasUtility",
      "filePath": "/global/libraries/js/CanvasUtility.js"
    },
    "AudioEditor": {
      "fileName": "AudioEditor",
      "filePath": "/global/libraries/js/AudioEditor.js"
    },
    "GE_GroupManager": {
      "title": "GE_GroupManager",
      "fileName": "GE_GroupManager",
      "filePath": "/global/libraries/js/GE_GroupManager.js"
    },
    "Component": {
      "fileName": "Component",
      "filePath": "/global/libraries/js/Component.js"
    },
    "GE_EquipmentEditor": {
      "title": "GE_EquipmentEditor",
      "fileName": "GE_EquipmentEditor",
      "filePath": "/global/libraries/js/GE_EquipmentEditor.js"
    },
    "GE_RotationUtils": {
      "title": "GE_RotationUtils",
      "fileName": "GE_RotationUtils",
      "filePath": "/global/libraries/js/GE_RotationUtils.js"
    },
    "GE_SceneRenderer": {
      "title": "GE_SceneRenderer",
      "fileName": "GE_SceneRenderer",
      "filePath": "/global/libraries/js/GE_SceneRenderer.js"
    },
    "GE_EventManager": {
      "title": "GE_EventManager",
      "fileName": "GE_EventManager",
      "filePath": "/global/libraries/js/GE_EventManager.js"
    },
    "GE_ShapeManager": {
      "title": "GE_ShapeManager",
      "fileName": "GE_ShapeManager",
      "filePath": "/global/libraries/js/GE_ShapeManager.js"
    },
    "GE_GizmoManager": {
      "title": "GE_GizmoManager",
      "fileName": "GE_GizmoManager",
      "filePath": "/global/libraries/js/GE_GizmoManager.js"
    },
    "AmmoWorker": {
      "fileName": "AmmoWorker",
      "filePath": "/global/libraries/js/AmmoWorker.js"
    },
    "GE_AnimationManager": {
      "title": "GE_AnimationManager",
      "fileName": "GE_AnimationManager",
      "filePath": "/global/libraries/js/GE_AnimationManager.js"
    },
    "GE_UIManager": {
      "title": "GE_UIManager",
      "fileName": "GE_UIManager",
      "filePath": "/global/libraries/js/GE_UIManager.js"
    },
    "Entity": {
      "fileName": "Entity",
      "filePath": "/global/libraries/js/Entity.js"
    },
    "GameState": {
      "fileName": "GameState",
      "filePath": "/global/libraries/js/GameState.js"
    },
    "CoordinateTranslator": {
      "fileName": "CoordinateTranslator",
      "filePath": "/global/libraries/js/CoordinateTranslator.js"
    },
    "GraphicsEditor": {
      "fileName": "GraphicsEditor",
      "title": "GraphicsEditor",
      "filePath": "/global/libraries/js/GraphicsEditor.js"
    },
    "GLTFLoader": {
      "title": "GLTF Loader",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "GLTFLoader",
      "importName": "GLTFLoader",
      "fileName": "GLTFLoader",
      "filePath": "/global/libraries/js/GLTFLoader.js"
    },
    "ImageManager": {
      "fileName": "ImageManager",
      "filePath": "/global/libraries/js/ImageManager.js"
    },
    "ModelManager": {
      "title": "ModelManager",
      "fileName": "ModelManager",
      "filePath": "/global/libraries/js/ModelManager.js"
    },
    "NetworkManager": {
      "fileName": "NetworkManager",
      "filePath": "/global/libraries/js/NetworkManager.js"
    },
    "PhysicsEngine": {
      "title": "PhysicsEngine",
      "fileName": "PhysicsEngine",
      "filePath": "/global/libraries/js/PhysicsEngine.js"
    },
    "ShapeFactory": {
      "fileName": "ShapeFactory",
      "filePath": "/global/libraries/js/ShapeFactory.js"
    },
    "RapierWorker": {
      "fileName": "RapierWorker",
      "script": "",
      "filePath": "/global/libraries/js/RapierWorker.js"
    },
    "ScriptEditor": {
      "fileName": "ScriptEditor",
      "filePath": "/global/libraries/js/ScriptEditor.js"
    },
    "SimplexNoise": {
      "title": "SimplexNoise",
      "fileName": "SimplexNoise",
      "filePath": "/global/libraries/js/SimplexNoise.js"
    },
    "SpatialGrid": {
      "fileName": "SpatialGrid",
      "filePath": "/global/libraries/js/SpatialGrid.js"
    },
    "TerrainMapEditor": {
      "fileName": "TerrainMapEditor",
      "filePath": "/global/libraries/js/TerrainMapEditor.js"
    },
    "TextureEditor": {
      "title": "TextureEditor",
      "fileName": "TextureEditor",
      "filePath": "/global/libraries/js/TextureEditor.js"
    },
    "three-nebula": {
      "fileName": "three-nebula",
      "isModule": true,
      "importName": "Nebula",
      "requireName": "Nebula",
      "filePath": "/global/libraries/js/three-nebula.js"
    },
    "three_MeshBVH": {
      "title": "THREE MeshBVH",
      "isModule": true,
      "windowContext": "THREE_",
      "fileName": "three_MeshBVH",
      "filePath": "/global/libraries/js/three_MeshBVH.js"
    },
    "three_SkeletonUtils": {
      "title": "THREE SkeletonUtils",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "SkeletonUtils",
      "importName": "SkeletonUtils",
      "fileName": "three_SkeletonUtils",
      "filePath": "/global/libraries/js/three_SkeletonUtils.js"
    },
    "TileMap": {
      "fileName": "TileMap",
      "filePath": "/global/libraries/js/TileMap.js"
    },
    "ZipExporter": {
      "fileName": "ZipExporter",
      "filePath": "/global/libraries/js/ZipExporter.js"
    },
    "TerrainImageProcessor": {
      "fileName": "TerrainImageProcessor",
      "filePath": "/global/libraries/js/TerrainImageProcessor.js"
    },
    "TerrainGenerator": {
      "title": "TerrainGenerator",
      "fileName": "TerrainGenerator",
      "filePath": "/global/libraries/js/TerrainGenerator.js"
    },
    "DesyncDebugger": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/DesyncDebugger.js",
      "fileName": "DesyncDebugger"
    },
    "EnemyStrategy": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/EnemyStrategy.js",
      "fileName": "EnemyStrategy"
    },
    "FantasyUIEnhancements": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/FantasyUIEnhancements.js",
      "fileName": "FantasyUIEnhancements"
    },
    "GameModeConfigs": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameModeConfigs.js",
      "fileName": "GameModeConfigs"
    },
    "GameUtils": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameUtils.js",
      "fileName": "GameUtils"
    },
    "MinHeap": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/MinHeap.js",
      "fileName": "MinHeap"
    },
    "PlacementPreview": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/PlacementPreview.js",
      "fileName": "PlacementPreview"
    },
    "NotificationSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/NotificationSystem.js",
      "fileName": "NotificationSystem"
    },
    "UIComponents": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/UIComponents.js",
      "fileName": "UIComponents"
    }
  },
  "modals": {
    "addTerrainType": {
      "title": "Add Terrain Type",
      "fileName": "addTerrainType",
      "html": "\r\n<h4 id=\"formTitle\">Add Terrain Type</h4>\r\n<input type=\"hidden\" id=\"editingType\" value=\"\">\r\n<div class=\"form-group\">\r\n    <label for=\"terrainType\">Type:</label>\r\n    <input type=\"text\" id=\"terrainType\" placeholder=\"grass, water, etc.\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainColor\">Color:</label>\r\n    <input type=\"text\" id=\"terrainColorText\">\r\n    <input type=\"color\" id=\"terrainColor\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainImage\">Sprite Sheet:</label>\r\n    <input type=\"textarea\" id=\"terrainImage\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainTexture\">Texture:</label>\r\n    <select id=\"terrainTexture\"></select>\r\n</div>\r\n<div class=\"form-group\">\r\n    <img id=\"terrain-image-display\" alt=\"Terrain Image\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainBuildable\">Buildable:</label>\r\n    <input type=\"checkbox\" id=\"terrainBuildable\">\r\n</div>\r\n<div class=\"form-actions\">\r\n    <button id=\"saveTerrainBtn\" class=\"primary\">Save</button>\r\n    <button id=\"cancelTerrainBtn\">Cancel</button>\r\n</div>\r\n<input type=\"hidden\" id=\"editingId\">\r\n",
      "filePath": "/global/modals/html/addTerrainType.html"
    },
    "compilerModal": {
      "title": "Compiler Modal",
      "fileName": "compilerModal",
      "filePath": "/global/modals/html/compilerModal.html",
      "html": "\n<div class=\"modal-header\">\n    <h2>Compile Game</h2>\n</div>\n<div class=\"modal-body\">\n    <div class=\"form-group\">\n        <label>\n            <input type=\"checkbox\" id=\"compileIncludeMetadata\" />\n            Include metadata file\n        </label>\n    </div>\n    <div class=\"form-group\">\n        <label>\n            <input type=\"checkbox\" id=\"compileCreateZip\" />\n            Download as zip file\n        </label>\n    </div>\n    <div class=\"compilation-output\" id=\"compilationOutput\" style=\"display: none;\">\n        <h3>Output:</h3>\n        <pre id=\"compilationLog\"></pre>\n    </div>\n</div>\n<div class=\"modal-footer\">\n    <button class=\"btn btn-primary\" onclick=\"window.compilerModule.compile()\">\n        Compile\n    </button>\n    <button class=\"btn btn-secondary\" onclick=\"this.closest('.modal').classList.remove('show')\">\n        Cancel\n    </button>\n</div>"
    },
    "aiPromptPanel": {
      "title": "AI Prompt Panel",
      "fileName": "aiPromptPanel",
      "html": "<h2>AI Object Generator</h2>\r\n                <div class=\"form-group\">\r\n                    <label for=\"ai-prompt-textarea\">Prompt:</label>\r\n                    <textarea id=\"ai-prompt-textarea\" rows=\"6\" placeholder=\"Enter your AI generation prompt\"></textarea>\r\n                    <textarea id=\"ai-pre-prompt-textarea\" rows=\"6\" placeholder=\"context\"></textarea>\r\n                </div>\r\n                <div class=\"actions\">\r\n                    <button id=\"send-ai-prompt-btn\" class=\"primary\">Send to AI</button>\r\n                    <button id=\"close-ai-prompt-modal\">Cancel</button>\r\n                </div>\r\n                <div class=\"preview-section\">\r\n                    <h3>AI Response Preview</h3>\r\n                    <textarea id=\"ai-response-preview\" rows=\"6\"></textarea>\r\n                    <div class=\"preview-actions\">\r\n                        <button id=\"apply-ai-response-btn\" class=\"primary\" style=\"display:none;\">Apply Response</button>\r\n                    </div>\r\n                </div>",
      "filePath": "/global/modals/html/aiPromptPanel.html"
    },
    "moveAllShapes": {
      "title": "Move All Shapes",
      "fileName": "moveAllShapes",
      "html": "\r\n<h3>Move All Shapes</h3>\r\n<div class=\"form-row\">\r\n    <label for=\"move-x\">X Offset:</label>\r\n    <input type=\"number\" id=\"move-x\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div class=\"form-row\">\r\n    <label for=\"move-y\">Y Offset:</label>\r\n    <input type=\"number\" id=\"move-y\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div class=\"form-row\">\r\n    <label for=\"move-z\">Z Offset:</label>\r\n    <input type=\"number\" id=\"move-z\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n    <button id=\"move-cancel\">Cancel</button>\r\n    <button id=\"move-apply\">Apply</button>\r\n</div>\r\n",
      "filePath": "/global/modals/html/moveAllShapes.html"
    },
    "generateIsometric": {
      "title": "Generate Isometric Sprites",
      "fileName": "generateIsometric",
      "html": " <h3 style=\"margin-bottom: 20px; color: #e0e0e0; font-size: 18px;\">Generate Isometric Sprites</h3>                 <div class=\"form-row\">                     <label for=\"iso-frustum\">Frustum Size:</label>                     <input type=\"number\" id=\"iso-frustum\" value=\"48\" step=\"1\" min=\"1\">                 </div>                 <div class=\"form-row\">                     <label for=\"iso-distance\">Distance:</label>                     <input type=\"number\" id=\"iso-distance\" value=\"100\" step=\"1\" min=\"1\">                 </div>                 <div class=\"form-row\">                     <label for=\"iso-size\">Sprite Size:</label>                     <input type=\"number\" id=\"iso-size\" value=\"64\" step=\"1\" min=\"1\">                 </div>                 <div style=\"display: flex; gap: 10px; margin-top: 20px;\">                     <button id=\"iso-cancel\">Cancel</button>                     <button id=\"iso-generate\">Generate</button>                 </div>           ",
      "filePath": "/global/modals/html/generateIsometric.html"
    },
    "rotateShapes": {
      "title": "Rotate Shapes",
      "fileName": "rotateShapes",
      "html": "\r\n                <h3>Rotate All Shapes</h3>\r\n                <div class=\"form-row\">\r\n                    <label for=\"rotate-angle\">Angle (degrees):</label>\r\n                    <input type=\"number\" id=\"rotate-angle\" value=\"0\" step=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"rotate-axis\">Axis:</label>\r\n                    <select id=\"rotate-axis\">\r\n                        <option value=\"x\">X</option>\r\n                        <option value=\"y\" selected>Y</option>\r\n                        <option value=\"z\">Z</option>\r\n                    </select>\r\n                </div>\r\n                <div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n                    <button id=\"rotate-cancel\">Cancel</button>\r\n                    <button id=\"rotate-apply\">Apply</button>\r\n                </div>\r\n",
      "filePath": "/global/modals/html/rotateShapes.html"
    },
    "generateIsoSprites": {
      "title": "Generate Spritesheet",
      "fileName": "generateIsoSprites",
      "html": "\r\n                <h3 style=\"margin-bottom: 20px; color: #e0e0e0; font-size: 18px;\">Generate Isometric Sprites</h3>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-frustum\">Frustum Size:</label>\r\n                    <input type=\"number\" id=\"iso-frustum\" value=\"48\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-distance\">Distance:</label>\r\n                    <input type=\"number\" id=\"iso-distance\" value=\"100\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-size\">Sprite Size:</label>\r\n                    <input type=\"number\" id=\"iso-size\" value=\"64\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n                    <button id=\"iso-cancel\">Cancel</button>\r\n                    <button id=\"iso-generate\">Generate</button>\r\n                </div>\r\n",
      "filePath": "/global/modals/html/generateIsoSprites.html"
    }
  },
  "renderers": {
    "MapRenderer": {
      "filePath": "/global/renderers/js/MapRenderer.js",
      "fileName": "MapRenderer"
    },
    "ModelRenderer": {
      "title": "Model Renderer",
      "fileName": "ModelRenderer",
      "parameters": "[\"objectType\",\"spawnType\"]",
      "filePath": "/global/renderers/js/ModelRenderer.js"
    },
    "Renderer": {
      "fileName": "Renderer",
      "filePath": "/global/renderers/js/Renderer.js"
    },
    "Health": {
      "fileName": "Health",
      "filePath": "/global/renderers/js/Health.js"
    }
  },
  "themes": {
    "codeMirrorTheme": {
      "title": "Code - Ez On Eyes",
      "fileName": "codeMirrorTheme",
      "css": ".CodeMirror {    background: #1e1e1e;    color: #d4d4d4;    font-size: 14px; } .CodeMirror-gutters {    background: #252525;  border-right: 1px solid #444; } .CodeMirror-linenumber {    color: #888; }.CodeMirror-cursor {    border-left: 1px solid #d4d4d4; } .CodeMirror-selected {    background: #3a3a3a; }.CodeMirror-focused .CodeMirror-selected {    background: #404040; /* Slightly lighter when focused */}.CodeMirror-activeline-background {    background: #2a2a2a; /* Subtle active line highlight */}.CodeMirror-matchingbracket {    color: #b5cea8; /* Muted green for matching brackets */}.CodeMirror-nonmatchingbracket {    color: #d16969; /* Soft red for non-matching */}/* Override default theme's syntax highlighting */.cm-s-default .cm-header { color: #dcdcaa; } /* Soft yellow (overrides #00f blue) */.cm-s-default .cm-quote { color: #b5cea8; } /* Muted green (overrides #090) */.cm-negative { color: #d16969; } /* Soft red */.cm-positive { color: #6a9955; } /* Muted green */.cm-header, .cm-strong { font-weight: 700; }.cm-em { font-style: italic; }.cm-s-default .cm-link { color: #d7ba7d; text-decoration: underline; } /* Muted yellow (overrides #00c blue) */.cm-strikethrough { text-decoration: line-through; }.cm-s-default .cm-keyword { color: #ce9178; } /* Soft orange (overrides #708 purple) */.cm-s-default .cm-atom { color: #d4d4d4; } /* Light gray (overrides #219 blue) */.cm-s-default .cm-number { color: #b5cea8; } /* Muted green (overrides #164) */.cm-s-default .cm-def { color: #dcdcaa; } /* Soft yellow (overrides #00f blue) */.cm-s-default .cm-variable-2 { color: #d4d4d4; } /* Light gray (overrides #05a blue) */.cm-s-default .cm-variable-3, .cm-s-default .cm-type { color: #dcdcaa; } /* Soft yellow (overrides #085 blue) */.cm-s-default .cm-comment { color: #6a9955; } /* Muted green (overrides #a50) */.cm-s-default .cm-string { color: #ce9178; } /* Soft orange (overrides #a11) */.cm-s-default .cm-string-2 { color: #d7ba7d; } /* Muted yellow (overrides #f50) */.cm-s-default .cm-meta { color: #d4d4d4; } /* Light gray (overrides #555) */.cm-s-default .cm-qualifier { color: #d4d4d4; } /* Light gray (overrides #555) */.cm-s-default .cm-builtin { color: #dcdcaa; } /* Soft yellow (overrides #30a) */.cm-s-default .cm-bracket { color: #d4d4d4; } /* Light gray (overrides #997) */.cm-s-default .cm-tag { color: #dcdcaa; } /* Soft yellow (overrides #170) */.cm-s-default .cm-attribute { color: #d4d4d4; } /* Light gray (overrides #00c blue) */.cm-s-default .cm-hr { color: #888; } /* Muted gray (overrides #999) */.cm-s-default .cm-link { color: #d7ba7d; } /* Muted yellow (overrides #00c blue) */.cm-s-default .cm-error { color: #d16969; } /* Soft red (overrides red) */.cm-invalidchar { color: #d16969; } /* Soft red *//* Search highlight */.cm-searching {    background-color: rgba(255, 255, 0, 0.2); /* Subtle yellow */}",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/codeMirrorTheme.css"
    },
    "claude2": {
      "title": "Claude 2",
      "fileName": "claude2",
      "css": "/* Professional Theme - Clean UI */ @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap');  :root {   --bg-primary: #16192e;   --bg-secondary: #1d2035;   --bg-tertiary: #252a43;   --accent-primary: #4d7cff;   --accent-muted: rgba(77, 124, 255, 0.15);   --text-primary: #e9edf5;   --text-secondary: #a9b1c3;   --border-color: rgba(108, 123, 163, 0.25);   --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.2);   --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.25); }  body {   font-family: 'Inter', sans-serif;   background-color: var(--bg-primary);   color: var(--text-primary);   line-height: 1.6; }  /* Sidebar styling */ .sidebar {   background-color: var(--bg-secondary);   border-right: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  .object-item {   background-color: transparent;   border-left: 2px solid transparent;   text-transform: none;   letter-spacing: 0.2px;   color: var(--text-secondary);   font-weight: 400;   transition: all 0.2s ease;   padding: 10px 14px;   margin-bottom: 2px; }  .object-item:hover {   background-color: var(--bg-tertiary);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary); }  .object-item.selected {   background-color: var(--accent-muted);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary);   font-weight: 500; }  /* Editor area */ .editor {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  #three-js-container {   border: 1px solid var(--border-color);   border-radius: 4px;   background: var(--bg-primary); }  .preview-canvas-container {   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  .preview {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  #preview-canvas {   background-color: transparent;   border: 1px solid var(--border-color);   border-radius: 2px; }  /* Camera controls */ .camera-controls {   background: var(--bg-tertiary);   border: 1px solid var(--border-color);   border-radius: 4px;   padding: 12px; }  .camera-controls button {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   color: var(--text-primary);   border-radius: 3px;   padding: 8px 12px;   transition: all 0.2s ease; }  .camera-controls button:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .camera-controls .color-picker {   border: 1px solid var(--border-color);   border-radius: 3px; }  .camera-controls .size-slider {   background: var(--bg-secondary);   border: 1px solid var(--border-color);   border-radius: 3px;   height: 5px; }  .camera-controls .size-slider::-webkit-slider-thumb {   background: var(--accent-primary);   border-radius: 50%;   cursor: pointer; }  /* Form elements */ label {   font-weight: 500;   color: var(--text-primary);   margin-bottom: 6px;   display: block;   font-size: 0.875rem; }  input, textarea, select {   border: 1px solid var(--border-color);   background-color: var(--bg-secondary);   color: var(--text-primary);   border-radius: 3px;   width: calc(100% - 24px);  padding: 8px 12px;   transition: all 0.2s ease;   font-family: 'IBM Plex Mono', monospace; }  input:focus, textarea:focus, select:focus {   outline: none;   border-color: var(--accent-primary);   box-shadow: 0 0 0 2px var(--accent-muted); }  /* Button styles */ button {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color);   color: var(--text-primary);   font-weight: 500;   padding: 8px 14px;   border-radius: 3px;   transition: all 0.2s ease; }  button:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  button.primary {   background-color: var(--accent-primary);   border: 1px solid var(--accent-primary);   color: white; }  button.primary:hover {   background-color: #3a6ae6;   border-color: #3a6ae6;   box-shadow: var(--shadow-sm); }  button.danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444; }  button.danger:hover {   background-color: rgba(235, 68, 68, 0.25);   box-shadow: var(--shadow-sm); }  button.active {   background-color: rgba(52, 199, 154, 0.15);   border: 1px solid #34c79a;   color: #34c79a; }  /* Modal styling */ .modal {   background-color: rgba(22, 25, 46, 0.8); }  .modal-content {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-md);   border-radius: 4px; }  .property-list {   border: 1px solid var(--border-color);   background-color: var(--bg-tertiary);   border-radius: 4px; }  /* Tab navigation */ .tab-navigation {   border-bottom: 1px solid var(--border-color);   display: flex;   padding: 0 4px; }  .tab {   padding: 10px 16px;   color: var(--text-secondary);   transition: all 0.2s ease; }  .tab:hover {   background-color: var(--bg-tertiary);   color: var(--text-primary); }  .tab.active {   color: var(--accent-primary);   font-weight: 500;   border-bottom: 2px solid var(--accent-primary); }  /* Info and warning boxes */ .instructions {   background-color: var(--bg-tertiary);   border-left: 3px solid var(--accent-primary);   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0; }  #grid-display {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  .success-message {   color: #34c79a;   font-weight: 500;   animation: fadeOut 2s forwards;   animation-delay: 1.5s;   padding: 8px 12px; }  @keyframes fadeOut {   from { opacity: 1; }   to { opacity: 0; } }  .warning {   background-color: rgba(235, 68, 68, 0.1);   border-left: 3px solid #eb4444;   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0; }  /* Main containers */ .main-content-container {   background-color: var(--bg-primary);   color: var(--text-primary); }  .content-sidebar {   background: var(--bg-secondary);   border-right: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  #graphics-rightbar {   background: var(--bg-secondary);   border-left: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  /* Subtle grid background */ .grid-background {   background: var(--bg-primary);   background-image:      linear-gradient(rgba(108, 123, 163, 0.05) 1px, transparent 1px),     linear-gradient(90deg, rgba(108, 123, 163, 0.05) 1px, transparent 1px);   background-size: 20px 20px; }  /* Toolbar */ .toolbar {   background: var(--bg-secondary);   border-bottom: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   padding: 8px 16px;   display: flex;   align-items: center;   gap: 8px; }  /* Button variations */ .btn {   border: 1px solid var(--border-color);   background-color: var(--bg-tertiary);   color: var(--text-primary);   font-weight: 500;   padding: 8px 14px;   border-radius: 3px;   transition: all 0.2s ease;   font-size: 0.875rem; }  .btn:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .btn-primary {   background-color: var(--accent-primary);   border: 1px solid var(--accent-primary);   color: white; }  .btn-primary:hover {   background-color: #3a6ae6;   border-color: #3a6ae6; }  .btn-danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444; }  .btn-danger:hover {   background-color: rgba(235, 68, 68, 0.25); }  .btn-secondary {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color); }  .btn-secondary:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .btn-special {   background-color: rgba(52, 199, 154, 0.15);   border: 1px solid #34c79a;   color: #34c79a; }  .btn-special:hover {   background-color: rgba(52, 199, 154, 0.25); }  /* Shape list */ #shape-list {   border-bottom: 1px solid var(--border-color);   padding-bottom: 16px;   margin-bottom: 16px; }  .shape-item {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color);   border-radius: 3px;   padding: 10px 14px;   margin-bottom: 6px;   transition: all 0.2s ease;   display: flex;   align-items: center;   gap: 8px; }  .shape-item:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .shape-item.active {   background-color: rgba(52, 199, 154, 0.1);   border-color: #34c79a;   color: #34c79a;   font-weight: 500; }  /* Inspector panel */ #inspector {   background: var(--bg-secondary);   border-top: 1px solid var(--border-color);   padding: 16px; }  .form-row {   margin-bottom: 12px; }  .form-row label {   color: var(--text-primary);   margin-bottom: 6px; }  .form-row input, .form-row select {   width: 100%;   border: 1px solid var(--border-color);   background-color: var(--bg-secondary);   color: var(--text-primary);   padding: 8px 12px;   border-radius: 3px; }  /* Scene info */ .scene-info {   background: var(--bg-tertiary);   color: var(--text-primary);   border: 1px solid var(--border-color);   border-radius: 4px;   padding: 12px 16px;   margin-bottom: 16px; }  .button-danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444;   padding: 8px 14px;   border-radius: 3px;   font-weight: 500;   transition: all 0.2s ease; }  .button-danger:hover {   background-color: rgba(235, 68, 68, 0.25); }  /* Typography */ h2, h3 {   color: var(--text-primary);   margin-bottom: 16px;   padding-bottom: 8px;   border-bottom: 1px solid var(--border-color);   font-weight: 600; }  /* Scrollbars */ ::-webkit-scrollbar {   width: 6px;   height: 6px; }  ::-webkit-scrollbar-track {   background: var(--bg-tertiary);   border-radius: 3px; }  ::-webkit-scrollbar-thumb {   background: rgba(108, 123, 163, 0.5);   border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {   background: rgba(108, 123, 163, 0.7); }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/claude2.css"
    },
    "aurora": {
      "title": "Aurora",
      "fileName": "aurora",
      "css": "/* Aurora Theme - Modern gradient-based design for GUTS Editor */\r\n@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap');\r\n\r\n:root {\r\n  /* Override editor module variables with Aurora theme */\r\n  --editor-primary: #10b981;\r\n  --editor-primary-hover: #059669;\r\n  --editor-secondary: #3b82f6;\r\n  --editor-secondary-hover: #2563eb;\r\n  --editor-danger: #f43f5e;\r\n  --editor-danger-hover: #e11d48;\r\n  --editor-success: #10b981;\r\n  --editor-warning: #f59e0b;\r\n\r\n  /* Aurora-specific colors */\r\n  --aurora-teal: #14b8a6;\r\n  --aurora-blue: #0ea5e9;\r\n  --aurora-purple: #8b5cf6;\r\n  --aurora-pink: #ec4899;\r\n\r\n  /* Background layers - darker for comfort */\r\n  --editor-bg-dark: #050810;\r\n  --editor-bg-medium: #0a0e1a;\r\n  --editor-bg-light: #0f172a;\r\n  --editor-bg-lighter: #1e293b;\r\n\r\n  /* Text colors - softer for eyes */\r\n  --editor-text-primary: #cbd5e1;\r\n  --editor-text-secondary: #94a3b8;\r\n  --editor-text-muted: #64748b;\r\n\r\n  /* Borders */\r\n  --editor-border-color: rgba(20, 184, 166, 0.12);\r\n  --editor-border-color-hover: rgba(20, 184, 166, 0.25);\r\n\r\n  /* Shadows with aurora glow - softer */\r\n  --editor-shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.5);\r\n  --editor-shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);\r\n  --editor-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.3);\r\n  --aurora-glow: 0 0 15px rgba(16, 185, 129, 0.2);\r\n  --aurora-glow-strong: 0 0 25px rgba(16, 185, 129, 0.3), 0 0 50px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Base body with aurora gradient background - darker and subtle */\r\nbody {\r\n  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\r\n  background-color: var(--editor-bg-dark);\r\n  color: var(--editor-text-primary);\r\n  background-image:\r\n    radial-gradient(ellipse at 20% 20%, rgba(16, 185, 129, 0.04) 0%, transparent 50%),\r\n    radial-gradient(ellipse at 80% 80%, rgba(59, 130, 246, 0.04) 0%, transparent 50%),\r\n    radial-gradient(ellipse at 50% 50%, rgba(139, 92, 246, 0.02) 0%, transparent 60%);\r\n  background-attachment: fixed;\r\n}\r\n\r\n/* Monospace font for code */\r\ninput[type=\"text\"],\r\ntextarea,\r\n.editor-module__textarea,\r\n.script-editor__code {\r\n  font-family: 'Fira Code', 'Monaco', 'Courier New', monospace;\r\n}\r\n\r\n/* Force dark backgrounds on all inputs - easy on the eyes */\r\ninput,\r\ntextarea,\r\nselect,\r\n.editor-module__input,\r\n.editor-module__textarea,\r\n.editor-module__select,\r\ninput[type=\"text\"],\r\ninput[type=\"number\"],\r\ninput[type=\"email\"],\r\ninput[type=\"password\"],\r\ninput[type=\"search\"],\r\ninput[type=\"url\"] {\r\n  background-color: var(--editor-bg-dark) !important;\r\n  border: 1px solid var(--editor-border-color) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n/* Darker background for color pickers */\r\ninput[type=\"color\"],\r\n.editor-module__color-picker {\r\n  background-color: var(--editor-bg-medium) !important;\r\n  border: 1px solid var(--editor-border-color) !important;\r\n}\r\n\r\n/* Sidebar styling with aurora glow */\r\n.sidebar {\r\n  background: linear-gradient(180deg, var(--editor-bg-medium) 0%, var(--editor-bg-dark) 100%);\r\n  border-right: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset -1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n/* Main editor area */\r\n.editor {\r\n  background-color: var(--editor-bg-medium);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n/* Object items in sidebar - softer colors */\r\n.object-item {\r\n  background-color: transparent;\r\n  border-left: 2px solid transparent;\r\n  color: var(--editor-text-muted);\r\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\r\n}\r\n\r\n.object-item:hover {\r\n  background-color: rgba(16, 185, 129, 0.05);\r\n  border-left-color: rgba(16, 185, 129, 0.5);\r\n  color: var(--editor-text-secondary);\r\n  transform: translateX(3px);\r\n}\r\n\r\n.object-item.selected {\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.1), transparent);\r\n  border-left-color: var(--editor-primary);\r\n  color: var(--editor-text-primary);\r\n  box-shadow: var(--aurora-glow);\r\n  font-weight: 500;\r\n}\r\n\r\n/* Buttons with aurora styling - much darker and easier on eyes */\r\nbutton {\r\n  font-family: 'Inter', sans-serif;\r\n  font-weight: 500;\r\n  text-transform: none;\r\n  letter-spacing: 0.02em;\r\n  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\nbutton:hover {\r\n  transform: translateY(-1px);\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\nbutton:active {\r\n  transform: translateY(0);\r\n}\r\n\r\nbutton.primary {\r\n  background-color: rgba(16, 185, 129, 0.12) !important;\r\n  border-color: rgba(16, 185, 129, 0.3) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: none !important;\r\n}\r\n\r\nbutton.primary:hover {\r\n  background-color: rgba(16, 185, 129, 0.18) !important;\r\n  box-shadow: 0 0 8px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\nbutton.danger {\r\n  background-color: rgba(244, 63, 94, 0.08) !important;\r\n  border-color: rgba(244, 63, 94, 0.3) !important;\r\n  color: rgba(244, 63, 94, 0.75) !important;\r\n}\r\n\r\nbutton.danger:hover {\r\n  background-color: rgba(244, 63, 94, 0.12) !important;\r\n  box-shadow: 0 0 8px rgba(244, 63, 94, 0.12) !important;\r\n}\r\n\r\n/* Editor module buttons - much darker with !important to override base styles */\r\n.editor-module__btn {\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n}\r\n\r\n.editor-module__btn:hover {\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\n.editor-module__btn--primary {\r\n  background-color: rgba(16, 185, 129, 0.15) !important;\r\n  border-color: rgba(16, 185, 129, 0.35) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: none !important;\r\n}\r\n\r\n.editor-module__btn--primary:hover {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--secondary {\r\n  background-color: rgba(59, 130, 246, 0.12) !important;\r\n  border-color: rgba(59, 130, 246, 0.3) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n.editor-module__btn--secondary:hover {\r\n  background-color: rgba(59, 130, 246, 0.18) !important;\r\n  box-shadow: 0 0 10px rgba(59, 130, 246, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--active {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.5) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.15) !important;\r\n}\r\n\r\n.editor-module__btn--danger {\r\n  background-color: rgba(244, 63, 94, 0.12) !important;\r\n  border-color: rgba(244, 63, 94, 0.35) !important;\r\n  color: rgba(244, 63, 94, 0.85) !important;\r\n}\r\n\r\n.editor-module__btn--danger:hover {\r\n  background-color: rgba(244, 63, 94, 0.18) !important;\r\n  border-color: rgba(244, 63, 94, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(244, 63, 94, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--success {\r\n  background-color: rgba(16, 185, 129, 0.15) !important;\r\n  border-color: rgba(16, 185, 129, 0.35) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n.editor-module__btn--success:hover {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--warning {\r\n  background-color: rgba(245, 158, 11, 0.12) !important;\r\n  border-color: rgba(245, 158, 11, 0.35) !important;\r\n  color: rgba(245, 158, 11, 0.9) !important;\r\n}\r\n\r\n.editor-module__btn--warning:hover {\r\n  background-color: rgba(245, 158, 11, 0.18) !important;\r\n  border-color: rgba(245, 158, 11, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(245, 158, 11, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--small {\r\n  background-color: rgba(15, 23, 42, 0.5) !important;\r\n}\r\n\r\n.editor-module__btn--small:hover {\r\n  background-color: rgba(15, 23, 42, 0.7) !important;\r\n}\r\n\r\n.editor-module__btn--icon {\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n}\r\n\r\n.editor-module__btn--icon:hover {\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\n/* Form inputs with aurora accent - soft glow on focus */\r\ninput:focus,\r\ntextarea:focus,\r\nselect:focus,\r\n.editor-module__input:focus,\r\n.editor-module__select:focus,\r\n.editor-module__textarea:focus {\r\n  background-color: var(--editor-bg-medium) !important;\r\n  border-color: var(--editor-primary) !important;\r\n  box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.1) !important;\r\n  outline: none !important;\r\n}\r\n\r\n/* Range sliders - darker */\r\n.editor-module__range::-webkit-slider-thumb {\r\n  background: rgba(16, 185, 129, 0.6);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n.editor-module__range::-moz-range-thumb {\r\n  background: rgba(16, 185, 129, 0.6);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Modal styling */\r\n.modal {\r\n  background-color: rgba(10, 14, 26, 0.75);\r\n  backdrop-filter: blur(8px);\r\n}\r\n\r\n.modal-content {\r\n  background-color: var(--editor-bg-medium);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-lg), var(--aurora-glow);\r\n}\r\n\r\n/* Property list and panels */\r\n.property-list {\r\n  background-color: var(--editor-bg-light);\r\n  border: 1px solid var(--editor-border-color);\r\n}\r\n\r\n.editor-module__panel {\r\n  background-color: var(--editor-bg-light);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-sm);\r\n}\r\n\r\n/* Section titles with aurora accent - softer */\r\n.editor-module__section-title,\r\n.editor-module__panel-title {\r\n  color: var(--editor-text-primary);\r\n  position: relative;\r\n  padding-bottom: 8px;\r\n}\r\n\r\n.editor-module__section-title::after,\r\n.editor-module__panel-title::after {\r\n  content: '';\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 40px;\r\n  height: 2px;\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.6), transparent);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.3);\r\n}\r\n\r\n/* Items with aurora hover effect - subtle */\r\n.editor-module__item:hover {\r\n  background-color: rgba(16, 185, 129, 0.04);\r\n  border-color: var(--editor-border-color-hover);\r\n  box-shadow: none;\r\n}\r\n\r\n.editor-module__item--active,\r\n.editor-module__item--selected {\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.12), transparent);\r\n  border-color: var(--editor-primary);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Toolbar styling */\r\n.toolbar,\r\n.editor-module__toolbar {\r\n  background: linear-gradient(180deg, rgba(15, 23, 42, 0.8), rgba(10, 14, 26, 0.8));\r\n  border-bottom: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Grid background with aurora tint */\r\n.grid-background,\r\n.editor-module__grid-background {\r\n  background-image:\r\n    linear-gradient(rgba(16, 185, 129, 0.05) 1px, transparent 1px),\r\n    linear-gradient(90deg, rgba(16, 185, 129, 0.05) 1px, transparent 1px);\r\n  background-size: 20px 20px;\r\n}\r\n\r\n/* Status bar */\r\n.editor-module__status-bar {\r\n  background: linear-gradient(90deg, rgba(10, 14, 26, 0.9), rgba(15, 23, 42, 0.9));\r\n  border-top: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(8px);\r\n}\r\n\r\n/* Success messages */\r\n.success-message,\r\n.editor-module__message--success {\r\n  color: var(--editor-primary);\r\n  background-color: rgba(16, 185, 129, 0.1);\r\n  border-color: var(--editor-primary);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Warning messages */\r\n.warning,\r\n.editor-module__message--warning {\r\n  color: var(--editor-warning);\r\n  background-color: rgba(245, 158, 11, 0.1);\r\n  border-color: var(--editor-warning);\r\n}\r\n\r\n/* Instructions */\r\n.instructions {\r\n  background-color: rgba(59, 130, 246, 0.08);\r\n  border-left: 3px solid var(--editor-secondary);\r\n}\r\n\r\n/* Scrollbar styling - darker */\r\n::-webkit-scrollbar {\r\n  width: 8px;\r\n  height: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n  background: var(--editor-bg-dark);\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n  background: rgba(16, 185, 129, 0.25);\r\n  border-radius: 4px;\r\n  box-shadow: none;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n  background: rgba(16, 185, 129, 0.35);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Canvas containers */\r\n#three-js-container,\r\n.preview-canvas-container {\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Camera controls */\r\n.camera-controls {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Content sidebars */\r\n.content-sidebar,\r\n.editor-module__sidebar {\r\n  background: linear-gradient(180deg, var(--editor-bg-medium) 0%, var(--editor-bg-dark) 100%);\r\n  border-right: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset -1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n.editor-module__sidebar--right {\r\n  border-right: none;\r\n  border-left: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset 1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n/* Shape list items */\r\n.shape-item,\r\n.graphics-editor__shape-item,\r\n.graphics-editor__group-item {\r\n  border-left-color: rgba(16, 185, 129, 0.3);\r\n}\r\n\r\n.shape-item:hover,\r\n.graphics-editor__shape-item:hover,\r\n.graphics-editor__group-item:hover {\r\n  background-color: rgba(16, 185, 129, 0.08);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Active/selected state - Aurora theme colors (teal/green glow) */\r\n.terrain-editor__terrain-item:has(.terrain-editor__color-option.active),\r\n.terrain-editor__terrain-item:has(.terrain-editor__color-option--active),\r\n.terrain-editor__environment-item.active,\r\n.terrain-editor__environment-item--active,\r\n.editor-module__selectable-item.active,\r\n.editor-module__selectable-item--active {\r\n  background-color: rgba(16, 185, 129, 0.12) !important;\r\n  border-color: rgba(16, 185, 129, 0.4) !important;\r\n  box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.4), 0 0 8px rgba(16, 185, 129, 0.2) !important;\r\n}\r\n\r\n.terrain-editor__color-option.active,\r\n.terrain-editor__color-option--active {\r\n  box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.6), 0 0 12px rgba(16, 185, 129, 0.5) !important;\r\n}\r\n\r\n/* Audio editor value displays */\r\n.audio-editor__value-display {\r\n  color: var(--editor-primary);\r\n  text-shadow: 0 0 8px rgba(16, 185, 129, 0.5);\r\n}\r\n\r\n/* Animations - disabled pulsing for comfort */\r\n@keyframes aurora-pulse {\r\n  0%, 100% {\r\n    box-shadow: 0 0 15px rgba(16, 185, 129, 0.2);\r\n  }\r\n  50% {\r\n    box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);\r\n  }\r\n}\r\n\r\n/* Removed automatic pulsing animation for eye comfort */\r\n/* .editor-module__btn--primary:hover,\r\n.editor-module__item--active,\r\n.object-item.selected {\r\n  animation: aurora-pulse 2s ease-in-out infinite;\r\n} */\r\n\r\n/* Typography enhancements */\r\nh1, h2, h3, h4 {\r\n  color: var(--editor-text-primary);\r\n  font-weight: 600;\r\n}\r\n\r\n/* Labels */\r\nlabel,\r\n.editor-module__label {\r\n  color: var(--editor-text-secondary);\r\n  font-weight: 500;\r\n}\r\n\r\n/* Info boxes */\r\n.editor-module__info {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Scene info */\r\n.scene-info {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-sm);\r\n}\r\n",
      "filePath": "/global/themes/css/aurora.css"
    },
    "cyberpunk": {
      "title": "Cyber Punk",
      "fileName": "cyberpunk",
      "css": "/* Default Cyberpunk Theme */ @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@300;400;500;600;700&display=swap');  body {     font-family: 'Orbitron', 'Rajdhani', sans-serif;     background-color: #0a0a16;     color: #00f0ff; }  .sidebar {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 10px #00f0ff, inset 0 0 20px rgba(0, 240, 255, 0.2); }  .object-item {     background-color: rgba(0, 0, 35, 0.6);     border-left: 2px solid #fe01fe;     text-transform: uppercase;     letter-spacing: 1px; }  .object-item:hover {     background-color: rgba(254, 1, 254, 0.2);     transform: translateX(5px); }  .object-item.selected {     background-color: rgba(254, 1, 254, 0.3);     border-left: 4px solid #fe01fe;     box-shadow: 0 0 8px rgba(254, 1, 254, 0.5); }  .editor {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #fe01fe;     box-shadow: 0 0 15px rgba(254, 1, 254, 0.3); }  #three-js-container {     border: 1px solid rgba(0, 240, 255, 0.5); }  .preview-canvas-container {     border: 1px solid #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.3); }  .preview {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.3); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(0, 240, 255, 0.5); }  .camera-controls {     background: rgba(0, 0, 20, 0.7);     border: 1px solid #00f0ff; }  .camera-controls button {     background-color: rgba(0, 240, 255, 0.2);     border: 1px solid #00f0ff;     color: #00f0ff; }  .camera-controls .color-picker {     border: 1px solid #00f0ff; }  .camera-controls .size-slider {     background: #101028;     border: 1px solid #00f0ff; }  label {     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1px;     color: #fe01fe; }  input, textarea, select {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6);     color: #00f0ff;     box-shadow: 0 0 5px rgba(0, 240, 255, 0.3); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5); }  button {     background-color: rgba(0, 240, 255, 0.2);     border: 1px solid #00f0ff;     color: #00f0ff;     text-transform: uppercase;     letter-spacing: 1px; }  button:after {     background: linear-gradient(to right, transparent, rgba(0, 240, 255, 0.2), transparent); }  button:hover {     background-color: rgba(0, 240, 255, 0.3);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5), 0 0 20px rgba(0, 240, 255, 0.2);     transform: translateY(-2px); }  button:hover:after {     transform: translateX(100%) rotate(30deg); }  button.primary {     background-color: rgba(254, 1, 254, 0.2);     border: 1px solid #fe01fe;     color: #fe01fe; }  button.primary:hover {     background-color: rgba(254, 1, 254, 0.3);     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5), 0 0 20px rgba(254, 1, 254, 0.2); }  button.danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  button.danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5), 0 0 20px rgba(255, 0, 76, 0.2); }  button.active {     border: 1px solid #00ff9d;     box-shadow: 0 0 10px rgba(0, 255, 157, 0.5);     color: #00ff9d; }  .modal {     background-color: rgba(0, 0, 20, 0.85);     backdrop-filter: blur(5px); }  .modal-content {     background-color: rgba(15, 15, 35, 0.9);     border: 1px solid #00f0ff;     box-shadow: 0 0 30px rgba(0, 240, 255, 0.3), 0 0 60px rgba(0, 240, 255, 0.1); }  .property-list {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6); }  .tab-navigation {     border-bottom: 1px solid #00f0ff; }  .tab {     text-transform: uppercase;     letter-spacing: 1px; }  .tab:hover {     background-color: rgba(0, 240, 255, 0.1); }  .tab.active {     border-bottom: 3px solid #fe01fe;     box-shadow: 0 5px 10px -5px rgba(254, 1, 254, 0.5);     font-weight: bold; }  .instructions {     background-color: rgba(0, 0, 35, 0.6);     border-left: 4px solid #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.2); }  #grid-display {     background-color: rgba(0, 0, 20, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 10px rgba(0, 240, 255, 0.3); }  .success-message {     color: #00ff9d;     text-transform: uppercase;     letter-spacing: 1px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(255, 0, 76, 0.1);     border-left: 4px solid #ff004c;     box-shadow: 0 0 10px rgba(255, 0, 76, 0.2); }  .main-content-container {     background-color: #080815;     color: #00f0ff; }  .content-sidebar {     background: linear-gradient(180deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-right: 1px solid #00f0ff;     box-shadow: 0 0 20px rgba(0, 240, 255, 0.2); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-left: 1px solid #00f0ff;     box-shadow: 0 0 20px rgba(0, 240, 255, 0.2); }  .grid-background {     background: #05051a;     background-image: radial-gradient(rgba(0, 240, 255, 0.1) 1px, transparent 1px);     background-size: 20px 20px; }  .toolbar {     background: linear-gradient(90deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-bottom: 1px solid #00f0ff; }  .btn {     border: 1px solid #00f0ff;     background-color: rgba(0, 240, 255, 0.1);     color: #00f0ff;     text-transform: uppercase; }  .btn:hover {     background-color: rgba(0, 240, 255, 0.2);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);     transform: translateY(-2px); }  .btn-primary {     background-color: rgba(254, 1, 254, 0.2);     border: 1px solid #fe01fe;     color: #fe01fe; }  .btn-primary:hover {     background-color: rgba(254, 1, 254, 0.3);     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5); }  .btn-danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  .btn-danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5); }  .btn-secondary {     background-color: rgba(0, 240, 255, 0.15);     border: 1px solid #00f0ff; }  .btn-secondary:hover {     background-color: rgba(0, 240, 255, 0.25);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5); }  .btn-special {     background-color: rgba(0, 255, 157, 0.2);     border: 1px solid #00ff9d;     color: #00ff9d; }  .btn-special:hover {     background-color: rgba(0, 255, 157, 0.3);     box-shadow: 0 0 10px rgba(0, 255, 157, 0.5); }  #shape-list {     border-bottom: 1px solid rgba(0, 240, 255, 0.2); }  .shape-item {     background-color: rgba(0, 0, 35, 0.6);     border: 1px solid #00f0ff; }  .shape-item:hover {     background-color: rgba(0, 240, 255, 0.1);     transform: translateX(5px); }  .shape-item.active {     background-color: rgba(0, 255, 157, 0.1);     border-color: #00ff9d;     color: #00ff9d;     box-shadow: 0 0 10px rgba(0, 255, 157, 0.3); }  #inspector {     background: rgba(20, 20, 50, 0.8);     border-top: 1px solid #00f0ff; }  .form-row label {     color: #fe01fe; }  .form-row input, .form-row select {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6);     color: #00f0ff;     box-shadow: 0 0 5px rgba(0, 240, 255, 0.3); }  .scene-info {     background: rgba(0, 0, 20, 0.8);     color: #00f0ff;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);     border: 1px solid #00f0ff; }  .button-danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  .button-danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5); }  h2, h3 {     color: #fe01fe;     text-transform: uppercase;     letter-spacing: 3px;     margin-bottom: 15px;     padding-bottom: 5px;     border-bottom: 1px solid #00f0ff;     text-shadow: 0 0 5px rgba(254, 1, 254, 0.7); }  h2:hover, h3:hover {     text-shadow: -2px 0 #00f0ff, 2px 0 #ff004c; }  .container::before {     content: '';     position: fixed;     top: 0;     left: 0;     right: 0;     bottom: 0;     background:          linear-gradient(rgba(0, 240, 255, 0.07) 1px, transparent 1px),         linear-gradient(90deg, rgba(0, 240, 255, 0.07) 1px, transparent 1px);     background-size: 40px 40px;     background-position: center center;     z-index: -1;     perspective: 1000px;     transform-style: preserve-3d;     transform: rotateX(75deg) translateZ(-100px);     pointer-events: none; }  #json-content {     background-color: rgba(0, 0, 35, 0.8);     border: 1px solid #00f0ff;     color: #00ff9d;     font-family: 'Courier New', monospace;     padding: 15px;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.2), inset 0 0 30px rgba(0, 0, 35, 0.5); }  .ref-value-item {     background-color: #405060; }  .remove-ref-btn {     background: none;     border: none;     color: #ff6b6b;     cursor: pointer; }  ::-webkit-scrollbar {     width: 8px;     height: 8px; }  ::-webkit-scrollbar-track {     background: rgba(0, 0, 35, 0.6); }  ::-webkit-scrollbar-thumb {     background: #00f0ff;     border-radius: 0; }  ::-webkit-scrollbar-thumb:hover {     background: #fe01fe; }  button:active::before {     content: '';     position: absolute;     top: 0;     left: 0;     width: 100%;     height: 100%;     background: linear-gradient(90deg, transparent, rgba(0, 240, 255, 0.4), transparent);     animation: loading 1s infinite; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/cyberpunk.css"
    },
    "medieval": {
      "title": "Medieval",
      "fileName": "medieval",
      "css": "/* Medieval Theme */ @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=IM+Fell+English&display=swap');  body {     font-family: 'Cinzel', 'IM Fell English', serif;     background-color: #2b1e12; /* Dark brown, earthy tone */     color: #d4b98a; /* Parchment-like beige */ }  .sidebar {     background-color: rgba(50, 40, 30, 0.8); /* Dark wood */     border: 1px solid #8a5c2e; /* Bronze */     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5), inset 0 0 20px rgba(50, 40, 30, 0.3); }  .object-item {     background-color: rgba(60, 50, 40, 0.6); /* Aged wood */     border-left: 2px solid #b8860b; /* Gold accent */     text-transform: uppercase;     letter-spacing: 1px; }  .object-item:hover {     background-color: rgba(184, 134, 11, 0.2); /* Golden hover */     transform: translateX(5px); }  .object-item.selected {     background-color: rgba(184, 134, 11, 0.3);     border-left: 4px solid #b8860b;     box-shadow: 0 0 8px rgba(184, 134, 11, 0.5); }  .editor {     background-color: rgba(50, 40, 30, 0.7);     border: 1px solid #b8860b;     box-shadow: 0 0 15px rgba(184, 134, 11, 0.3); }  #three-js-container {     border: 1px solid rgba(138, 92, 46, 0.5); /* Bronze edge */ }  .preview-canvas-container {     border: 1px solid #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.3); }  .preview {     background-color: rgba(50, 40, 30, 0.7);     border: 1px solid #8a5c2e;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.3); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(138, 92, 46, 0.5); }  .camera-controls {     background: rgba(40, 30, 20, 0.7); /* Dark stone */     border: 1px solid #8a5c2e; }  .camera-controls button {     background-color: rgba(138, 92, 46, 0.2);     border: 1px solid #8a5c2e;     color: #d4b98a; }  .camera-controls .color-picker {     border: 1px solid #8a5c2e; }  .camera-controls .size-slider {     background: #3c2f1e; /* Darker wood */     border: 1px solid #8a5c2e; }  label {     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1px;     color: #b8860b; /* Gold text */ }  input, textarea, select {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6);     color: #d4b98a;     box-shadow: 0 0 5px rgba(138, 92, 46, 0.3); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5); }  button {     background-color: rgba(138, 92, 46, 0.2);     border: 1px solid #8a5c2e;     color: #d4b98a;     text-transform: uppercase;     letter-spacing: 1px; }  button:hover {     background-color: rgba(138, 92, 46, 0.3);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5), 0 0 20px rgba(138, 92, 46, 0.2);     transform: translateY(-2px); }  button.primary {     background-color: rgba(184, 134, 11, 0.2);     border: 1px solid #b8860b;     color: #b8860b; }  button.primary:hover {     background-color: rgba(184, 134, 11, 0.3);     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5), 0 0 20px rgba(184, 134, 11, 0.2); }  button.danger {     background-color: rgba(139, 0, 0, 0.2); /* Crimson */     border: 1px solid #8b0000;     color: #ff4040; }  button.danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5), 0 0 20px rgba(139, 0, 0, 0.2); }  button.active {     border: 1px solid #228b22; /* Forest green */     box-shadow: 0 0 10px rgba(34, 139, 34, 0.5);     color: #228b22; }  .modal {     background-color: rgba(40, 30, 20, 0.85); /* Stone texture */     backdrop-filter: blur(5px); }  .modal-content {     background-color: rgba(50, 40, 30, 0.9);     border: 1px solid #8a5c2e;     box-shadow: 0 0 30px rgba(138, 92, 46, 0.3), 0 0 60px rgba(138, 92, 46, 0.1); }  .property-list {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6); }  .tab-navigation {     border-bottom: 1px solid #8a5c2e; }  .tab {     text-transform: uppercase;     letter-spacing: 1px; }  .tab:hover {     background-color: rgba(138, 92, 46, 0.1); }  .tab.active {     border-bottom: 3px solid #b8860b;     box-shadow: 0 5px 10px -5px rgba(184, 134, 11, 0.5);     font-weight: bold; }  .instructions {     background-color: rgba(60, 50, 40, 0.6);     border-left: 4px solid #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.2); }  #grid-display {     background-color: rgba(40, 30, 20, 0.7);     border: 1px solid #8a5c2e;     box-shadow: 0 0 10px rgba(138, 92, 46, 0.3); }  .success-message {     color: #228b22; /* Forest green */     text-transform: uppercase;     letter-spacing: 1px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(139, 0, 0, 0.1);     border-left: 4px solid #8b0000;     box-shadow: 0 0 10px rgba(139, 0, 0, 0.2); }  .main-content-container {     background-color: #251a10; /* Darker brown */     color: #d4b98a; }  .content-sidebar {     background: linear-gradient(180deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-right: 1px solid #8a5c2e;     box-shadow: 0 0 20px rgba(138, 92, 46, 0.2); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-left: 1px solid #8a5c2e;     box-shadow: 0 0 20px rgba(138, 92, 46, 0.2); }  .grid-background {     background: #1e150d;     background-image: radial-gradient(rgba(138, 92, 46, 0.1) 1px, transparent 1px);     background-size: 20px 20px; }  .toolbar {     background: linear-gradient(90deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-bottom: 1px solid #8a5c2e; }  .btn {     border: 1px solid #8a5c2e;     background-color: rgba(138, 92, 46, 0.1);     color: #d4b98a;     text-transform: uppercase; }  .btn:hover {     background-color: rgba(138, 92, 46, 0.2);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5);     transform: translateY(-2px); }  .btn-primary {     background-color: rgba(184, 134, 11, 0.2);     border: 1px solid #b8860b;     color: #b8860b; }  .btn-primary:hover {     background-color: rgba(184, 134, 11, 0.3);     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5); }  .btn-danger {     background-color: rgba(139, 0, 0, 0.2);     border: 1px solid #8b0000;     color: #ff4040; }  .btn-danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }  .btn-secondary {     background-color: rgba(138, 92, 46, 0.15);     border: 1px solid #8a5c2e; }  .btn-secondary:hover {     background-color: rgba(138, 92, 46, 0.25);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5); }  .btn-special {     background-color: rgba(34, 139, 34, 0.2); /* Forest green */     border: 1px solid #228b22;     color: #228b22; }  .btn-special:hover {     background-color: rgba(34, 139, 34, 0.3);     box-shadow: 0 0 10px rgba(34, 139, 34, 0.5); }  #shape-list {     border-bottom: 1px solid rgba(138, 92, 46, 0.2); }  .shape-item {     background-color: rgba(60, 50, 40, 0.6);     border: 1px solid #8a5c2e; }  .shape-item:hover {     background-color: rgba(138, 92, 46, 0.1);     transform: translateX(5px); }  .shape-item.active {     background-color: rgba(34, 139, 34, 0.1);     border-color: #228b22;     color: #228b22;     box-shadow: 0 0 10px rgba(34, 139, 34, 0.3); }  #inspector {     background: rgba(60, 50, 40, 0.8);     border-top: 1px solid #8a5c2e; }  .form-row label {     color: #b8860b; }  .form-row input, .form-row select {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6);     color: #d4b98a;     box-shadow: 0 0 5px rgba(138, 92, 46, 0.3); }  .scene-info {     background: rgba(40, 30, 20, 0.8);     color: #d4b98a;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.3);     border: 1px solid #8a5c2e; }  .button-danger {     background-color: rgba(139, 0, 0, 0.2);     border: 1px solid #8b0000;     color: #ff4040; }  .button-danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }  h2, h3 {     color: #b8860b;     text-transform: uppercase;     letter-spacing: 3px;     margin-bottom: 15px;     padding-bottom: 5px;     border-bottom: 1px solid #8a5c2e;     text-shadow: 0 0 5px rgba(184, 134, 11, 0.7); }   .container::before {     content: '';     position: fixed;     top: 0;     left: 0;     right: 0;     bottom: 0;     background:          linear-gradient(rgba(138, 92, 46, 0.07) 1px, transparent 1px),         linear-gradient(90deg, rgba(138, 92, 46, 0.07) 1px, transparent 1px);     background-size: 40px 40px;     background-position: center center;     z-index: -1;     perspective: 1000px;     transform-style: preserve-3d;     transform: rotateX(75deg) translateZ(-100px);     pointer-events: none; }  #json-content {     background-color: rgba(60, 50, 40, 0.8);     border: 1px solid #8a5c2e;     color: #228b22; /* Green ink */     font-family: 'IM Fell English', serif;     padding: 15px;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.2), inset 0 0 30px rgba(60, 50, 40, 0.5); }  .ref-value-item {     background-color: #4a3a2a; /* Darker wood */ }  .remove-ref-btn {     background: none;     border: none;     color: #ff4040;     cursor: pointer; }  ::-webkit-scrollbar {     width: 8px;     height: 8px; }  ::-webkit-scrollbar-track {     background: rgba(60, 50, 40, 0.6); }  ::-webkit-scrollbar-thumb {     background: #8a5c2e;     border-radius: 0; }  ::-webkit-scrollbar-thumb:hover {     background: #b8860b; }  /* Category Styling for Medieval Theme */ .type-selector {     background-color: rgba(50, 40, 30, 0.7); /* Dark wood */     border: 1px solid #8a5c2e; /* Bronze */     box-shadow: inset 0 0 10px rgba(138, 92, 46, 0.3); }  .category-header {     background-color: rgba(60, 50, 40, 0.8); /* Aged wood */     border: 1px solid #8a5c2e;     color: #d4b98a; /* Parchment beige */     text-transform: uppercase;     letter-spacing: 1px;     font-weight: bold; }  .category-header:hover {     background-color: rgba(138, 92, 46, 0.2); /* Bronze hover */     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5); }  .category-types {     background-color: rgba(40, 30, 20, 0.6); /* Dark stone */ }  .object-type-item {     background-color: rgba(60, 50, 40, 0.6); /* Aged wood */     border-left: 2px solid #b8860b; /* Gold accent */     color: #d4b98a;     text-transform: uppercase;     letter-spacing: 1px; }  .object-type-item:hover {     background-color: rgba(184, 134, 11, 0.2); /* Golden hover */     transform: translateX(5px); }  .object-type-item.selected {     background-color: rgba(184, 134, 11, 0.3);     border-left: 4px solid #b8860b;     box-shadow: 0 0 8px rgba(184, 134, 11, 0.5); }  .object-list {     background-color: rgba(50, 40, 30, 0.5); /* Slightly lighter wood */ }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/medieval.css"
    },
    "professional": {
      "title": "Professional",
      "fileName": "professional",
      "css": "/* Professional Theme */ @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');  body {     font-family: 'Inter', 'Roboto Mono', sans-serif;     background-color: #1a1a2e;     color: #e6e6fa;     line-height: 1.6; }  .sidebar {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.2); }  .object-item {     background-color: rgba(34, 34, 54, 0.8);     border-left: 2px solid #8a4af0;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .object-item:hover {     background-color: rgba(138, 74, 240, 0.15);     transform: translateX(3px); }  .object-item.selected {     background-color: rgba(138, 74, 240, 0.25);     border-left: 3px solid #8a4af0;     box-shadow: 0 0 6px rgba(138, 74, 240, 0.4); }  .editor {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #three-js-container {     border: 1px solid rgba(75, 94, 135, 0.6); }  .preview-canvas-container {     border: 1px solid #8a4af0;     box-shadow: 0 4px 12px rgba(138, 74, 240, 0.1); }  .preview {     background-color: rgba(34, 34, 54, 0.9);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(75, 94, 135, 0.5); }  .camera-controls {     background: rgba(26, 26, 46, 0.9);     border: 1px solid #4b5e87; }  .camera-controls button {     background-color: rgba(75, 94, 135, 0.3);     border: 1px solid #4b5e87;     color: #e6e6fa;     transition: all 0.3s ease; }  .camera-controls button:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3); }  .camera-controls .color-picker {     border: 1px solid #4b5e87; }  .camera-controls .size-slider {     background: #2a2a42;     border: 1px solid #4b5e87; }  label {     font-weight: 500;     text-transform: uppercase;     letter-spacing: 0.5px;     color: #8a4af0; }  input, textarea, select {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8);     color: #e6e6fa;     box-shadow: 0 2px 6px rgba(75, 94, 135, 0.1);     transition: all 0.3s ease; }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #8a4af0;     box-shadow: 0 0 8px rgba(138, 74, 240, 0.3); }  button {     background-color: rgba(75, 94, 135, 0.3);     border: 1px solid #4b5e87;     color: #e6e6fa;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3);     transform: translateY(-1px); }  button.primary {     background-color: rgba(138, 74, 240, 0.3);     border: 1px solid #8a4af0;     color: #e6e6fa; }  button.primary:hover {     background-color: rgba(138, 74, 240, 0.5);     box-shadow: 0 2px 8px rgba(138, 74, 240, 0.3); }  button.danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  button.danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  button.active {     border: 1px solid #00cc99;     box-shadow: 0 0 8px rgba(0, 204, 153, 0.4);     color: #00cc99; }  .modal {     background-color: rgba(26, 26, 46, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 8px 24px rgba(75, 94, 135, 0.2); }  .property-list {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8); }  .tab-navigation {     border-bottom: 1px solid #4b5e87; }  .tab {     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .tab:hover {     background-color: rgba(75, 94, 135, 0.2); }  .tab.active {     border-bottom: 2px solid #8a4af0;     box-shadow: 0 4px 8px -4px rgba(138, 74, 240, 0.4);     font-weight: 600; }  .instructions {     background-color: rgba(34, 34, 54, 0.8);     border-left: 3px solid #8a4af0;     box-shadow: 0 2px 6px rgba(138, 74, 240, 0.1); }  #grid-display {     background-color: rgba(26, 26, 46, 0.9);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  .success-message {     color: #00cc99;     text-transform: uppercase;     letter-spacing: 0.5px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(240, 74, 74, 0.15);     border-left: 3px solid #f04a4a;     box-shadow: 0 2px 6px rgba(240, 74, 74, 0.1); }  .main-content-container {     background-color: #1f1f38;     color: #e6e6fa; }  .content-sidebar {     background: linear-gradient(180deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-right: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-left: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  .grid-background {     background: #1a1a2e;     background-image: radial-gradient(rgba(75, 94, 135, 0.15) 1px, transparent 1px);     background-size: 30px 30px; }  .toolbar {     background: linear-gradient(90deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-bottom: 1px solid #4b5e87; }  .btn {     border: 1px solid #4b5e87;     background-color: rgba(75, 94, 135, 0.3);     color: #e6e6fa;     text-transform: uppercase;     transition: all 0.3s ease; }  .btn:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3);     transform: translateY(-1px); }  .btn-primary {     background-color: rgba(138, 74, 240, 0.3);     border: 1px solid #8a4af0;     color: #e6e6fa; }  .btn-primary:hover {     background-color: rgba(138, 74, 240, 0.5);     box-shadow: 0 2px 8px rgba(138, 74, 240, 0.3); }  .btn-danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  .btn-danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  .btn-secondary {     background-color: rgba(75, 94, 135, 0.25);     border: 1px solid #4b5e87; }  .btn-secondary:hover {     background-color: rgba(75, 94, 135, 0.4);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3); }  .btn-special {     background-color: rgba(0, 204, 153, 0.3);     border: 1px solid #00cc99;     color: #e6e6fa; }  .btn-special:hover {     background-color: rgba(0, 204, 153, 0.5);     box-shadow: 0 2px 8px rgba(0, 204, 153, 0.3); }  #shape-list {     border-bottom: 1px solid rgba(75, 94, 135, 0.3); }  .shape-item {     background-color: rgba(34, 34, 54, 0.8);     border: 1px solid #4b5e87;     transition: all 0.3s ease; }  .shape-item:hover {     background-color: rgba(75, 94, 135, 0.2);     transform: translateX(3px); }  .shape-item.active {     background-color: rgba(0, 204, 153, 0.15);     border-color: #00cc99;     color: #00cc99;     box-shadow: 0 0 8px rgba(0, 204, 153, 0.3); }  #inspector {     background: rgba(34, 34, 54, 0.95);     border-top: 1px solid #4b5e87; }  .form-row label {     color: #8a4af0; }  .form-row input, .form-row select {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8);     color: #e6e6fa;     box-shadow: 0 2px 6px rgba(75, 94, 135, 0.1); }  .scene-info {     background: rgba(26, 26, 46, 0.9);     color: #e6e6fa;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15);     border: 1px solid #4b5e87; }  .button-danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  .button-danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  h2, h3 {     color: #8a4af0;     text-transform: uppercase;     letter-spacing: 1px;     margin-bottom: 12px;     padding-bottom: 4px;     border-bottom: 1px solid #4b5e87;     text-shadow: 0 0 4px rgba(138, 74, 240, 0.3); }  ::-webkit-scrollbar {     width: 6px;     height: 6px; }  ::-webkit-scrollbar-track {     background: rgba(34, 34, 54, 0.8); }  ::-webkit-scrollbar-thumb {     background: #4b5e87;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #8a4af0; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional.css"
    },
    "professional2": {
      "title": "Professional Warm",
      "fileName": "professional2",
      "css": "/* Professional Cyberpunk Variation - Warm Edition */ @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');  body {     font-family: 'Inter', 'Roboto Mono', sans-serif;     background-color: #2b1e1e; /* Deep reddish-brown */     color: #f4e1d2; /* Soft cream for text */     line-height: 1.6; }  .sidebar {     background-color: rgba(54, 36, 36, 0.95); /* Muted dark red */     border: 1px solid #7a4e4e; /* Subtle reddish-gray */     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.2); }  .object-item {     background-color: rgba(54, 36, 36, 0.8);     border-left: 2px solid #d97706; /* Warm amber */     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .object-item:hover {     background-color: rgba(217, 119, 6, 0.15);     transform: translateX(3px); }  .object-item.selected {     background-color: rgba(217, 119, 6, 0.25);     border-left: 3px solid #d97706;     box-shadow: 0 0 6px rgba(217, 119, 6, 0.4); }  .editor {     background-color: rgba(54, 36, 36, 0.95);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #three-js-container {     border: 1px solid rgba(122, 78, 78, 0.6); }  .preview-canvas-container {     border: 1px solid #d97706;     box-shadow: 0 4px 12px rgba(217, 119, 6, 0.1); }  .preview {     background-color: rgba(54, 36, 36, 0.9);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(122, 78, 78, 0.5); }  .camera-controls {     background: rgba(46, 28, 28, 0.9); /* Darker reddish tint */     border: 1px solid #7a4e4e; }  .camera-controls button {     background-color: rgba(122, 78, 78, 0.3);     border: 1px solid #7a4e4e;     color: #f4e1d2;     transition: all 0.3s ease; }  .camera-controls button:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3); }  .camera-controls .color-picker {     border: 1px solid #7a4e4e; }  .camera-controls .size-slider {     background: #3a2424;     border: 1px solid #7a4e4e; }  label {     font-weight: 500;     text-transform: uppercase;     letter-spacing: 0.5px;     color: #d97706; /* Amber for labels */ }  input, textarea, select {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8);     color: #f4e1d2;     box-shadow: 0 2px 6px rgba(122, 78, 78, 0.1);     transition: all 0.3s ease; }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #d97706;     box-shadow: 0 0 8px rgba(217, 119, 6, 0.3); }  button {     background-color: rgba(122, 78, 78, 0.3);     border: 1px solid #7a4e4e;     color: #f4e1d2;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3);     transform: translateY(-1px); }  button.primary {     background-color: rgba(217, 119, 6, 0.3);     border: 1px solid #d97706;     color: #f4e1d2; }  button.primary:hover {     background-color: rgba(217, 119, 6, 0.5);     box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3); }  button.danger {     background-color: rgba(220, 38, 38, 0.3); /* Softer red */     border: 1px solid #dc2626;     color: #f4e1d2; }  button.danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  button.active {     border: 1px solid #10b981; /* Emerald green for active state */     box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);     color: #10b981; }  .modal {     background-color: rgba(46, 28, 28, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background-color: rgba(54, 36, 36, 0.95);     border: 1px solid #7a4e4e;     box-shadow: 0 8px 24px rgba(122, 78, 78, 0.2); }  .property-list {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8); }  .tab-navigation {     border-bottom: 1px solid #7a4e4e; }  .tab {     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .tab:hover {     background-color: rgba(122, 78, 78, 0.2); }  .tab.active {     border-bottom: 2px solid #d97706;     box-shadow: 0 4px 8px -4px rgba(217, 119, 6, 0.4);     font-weight: 600; }  .instructions {     background-color: rgba(54, 36, 36, 0.8);     border-left: 3px solid #d97706;     box-shadow: 0 2px 6px rgba(217, 119, 6, 0.1); }  #grid-display {     background-color: rgba(46, 28, 28, 0.9);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  .success-message {     color: #10b981; /* Emerald green for success */     text-transform: uppercase;     letter-spacing: 0.5px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(220, 38, 38, 0.15);     border-left: 3px solid #dc2626;     box-shadow: 0 2px 6px rgba(220, 38, 38, 0.1); }  .main-content-container {     background-color: #332121; /* Slightly lighter reddish-brown */     color: #f4e1d2; }  .content-sidebar {     background: linear-gradient(180deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-right: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-left: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  .grid-background {     background: #2b1e1e;     background-image: radial-gradient(rgba(122, 78, 78, 0.15) 1px, transparent 1px);     background-size:30px 30px; }  .toolbar {     background: linear-gradient(90deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-bottom: 1px solid #7a4e4e; }  .btn {     border: 1px solid #7a4e4e;     background-color: rgba(122, 78, 78, 0.3);     color: #f4e1d2;     text-transform: uppercase;     transition: all 0.3s ease; }  .btn:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3);     transform: translateY(-1px); }  .btn-primary {     background-color: rgba(217, 119, 6, 0.3);     border: 1px solid #d97706;     color: #f4e1d2; }  .btn-primary:hover {     background-color: rgba(217, 119, 6, 0.5);     box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3); }  .btn-danger {     background-color: rgba(220, 38, 38, 0.3);     border: 1px solid #dc2626;     color: #f4e1d2; }  .btn-danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  .btn-secondary {     background-color: rgba(122, 78, 78, 0.25);     border: 1px solid #7a4e4e; }  .btn-secondary:hover {     background-color: rgba(122, 78, 78, 0.4);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3); }  .btn-special {     background-color: rgba(16, 185, 129, 0.3);     border: 1px solid #10b981;     color: #f4e1d2; }  .btn-special:hover {     background-color: rgba(16, 185, 129, 0.5);     box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3); }  #shape-list {     border-bottom: 1px solid rgba(122, 78, 78, 0.3); }  .shape-item {     background-color: rgba(54, 36, 36, 0.8);     border: 1px solid #7a4e4e;     transition: all 0.3s ease; }  .shape-item:hover {     background-color: rgba(122, 78, 78, 0.2);     transform: translateX(3px); }  .shape-item.active {     background-color: rgba(16, 185, 129, 0.15);     border-color: #10b981;     color: #10b981;     box-shadow: 0 0 8px rgba(16, 185, 129, 0.3); }  #inspector {     background: rgba(54, 36, 36, 0.95);     border-top: 1px solid #7a4e4e; }  .form-row label {     color: #d97706; }  .form-row input, .form-row select {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8);     color: #f4e1d2;     box-shadow: 0 2px 6px rgba(122, 78, 78, 0.1); }  .scene-info {     background: rgba(46, 28, 28, 0.9prisma);     color: #f4e1d2;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15);     border: 1px solid #7a4e4e; }  .button-danger {     background-color: rgba(220, 38, 38, 0.3);     border: 1px solid #dc2626;     color: #f4e1d2; }  .button-danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  h2, h3 {     color: #d97706;     text-transform: uppercase;     letter-spacing: 1px;     margin-bottom: 12px;     padding-bottom: 4px;     border-bottom: 1px solid #7a4e4e;     text-shadow: 0 0 4px rgba(217, 119, 6, 0.3); }  ::-webkit-scrollbar {     width: 6px;     height: 6px; }  ::-webkit-scrollbar-track {     background: rgba(54, 36, 36, 0.8); }  ::-webkit-scrollbar-thumb {     background: #7a4e4e;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #d97706; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional2.css"
    },
    "Neon Dune": {
      "title": "Neon Dune",
      "fileName": "Neon Dune",
      "css": "body { background-color: #1a0f05; color: #ffffff; font-family: 'Arial', sans-serif; }\r\n\r\nh1, h2, h3 { color: #00ffbf; }\r\n\r\n.button-primary { background-color: #00ffbf; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; transition: all 0.3s ease; }\r\n.button-primary:hover { transform: scale(1.05); box-shadow: 0 0 15px #00ffbf; }\r\n\r\n.link { color: #00ffbf; text-decoration: none; }\r\n.link:hover { text-decoration: underline; }\r\n\r\n.card { background-color: #2d1e13; border-radius: 10px; padding: 20px; margin: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }\r\n\r\ninput, textarea { background-color: #2d1e13; color: #ffffff; border: 1px solid #00ffbf; padding: 8px; border-radius: 5px; }\r\n\r\nheader { background-color: #00ffbf; padding: 20px; text-align: center; box-shadow: 0 4px 6px rgba(0,255,191,0.3); }\r\n\r\nfooter { background-color: #2d1e13; color: #ffffff; padding: 20px; text-align: center; border-top: 1px solid #00ffbf; }\r\n",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/Neon Dune.css"
    },
    "professional3": {
      "title": "Claude",
      "fileName": "professional3",
      "css": "/* Eclipse Theme - A premium dark UI experience */ @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500;600&display=swap');  :root {   --bg-primary: #0f111a;   --bg-secondary: #141725;   --bg-tertiary: #1a1d2d;   --accent-primary: #7c4dff;   --accent-secondary: #00bcd4;   --accent-tertiary: #ff4081;   --text-primary: #eceff1;   --text-secondary: #b0bec5;   --border-light: rgba(99, 114, 166, 0.25);   --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);   --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);   --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);   --gradient-bg: linear-gradient(135deg, rgba(20, 23, 37, 0.95), rgba(15, 17, 26, 0.95));   --gradient-accent: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); }  body {   font-family: 'Space Grotesk', sans-serif;   background-color: var(--bg-primary);   color: var(--text-primary);   line-height: 1.6;   transition: background-color 0.3s ease;   background-image:      radial-gradient(circle at 15% 15%, rgba(124, 77, 255, 0.08) 0%, transparent 25%),     radial-gradient(circle at 85% 85%, rgba(0, 188, 212, 0.08) 0%, transparent 25%); }  /* Modern sidebar with glassmorphism effect */ .sidebar {   background: var(--gradient-bg);   border-right: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  .object-item {   background-color: transparent;   border-left: 2px solid transparent;   text-transform: uppercase;   letter-spacing: 0.5px;   color: var(--text-secondary);   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   margin-bottom: 4px;   border-radius: 0 4px 4px 0; }  .object-item:hover {   background-color: rgba(124, 77, 255, 0.1);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary);   transform: translateX(2px); }  .object-item.selected {   background: linear-gradient(90deg, rgba(124, 77, 255, 0.15), rgba(124, 77, 255, 0.05));   border-left: 3px solid var(--accent-primary);   color: var(--accent-primary);   box-shadow: 0 0 12px rgba(124, 77, 255, 0.2);   font-weight: 600; }  /* Editor area with polished look */ .editor {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px;   overflow: hidden; }  #three-js-container {   border: 1px solid var(--border-light);   border-radius: 6px;   box-shadow: inset 0 0 16px rgba(0, 0, 0, 0.2);   background: rgba(15, 17, 26, 0.5); }  .preview-canvas-container {   border: 1px solid var(--accent-primary);   box-shadow: 0 0 16px rgba(124, 77, 255, 0.15);   border-radius: 6px;   overflow: hidden; }  .preview {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px; }  #preview-canvas {   background-color: transparent;   border: 1px solid var(--border-light);   border-radius: 4px; }  /* Enhanced camera controls with dynamic hover effects */ .camera-controls {   background: var(--bg-tertiary);   border: 1px solid var(--border-light);   border-radius: 6px;   padding: 12px;   box-shadow: var(--shadow-sm); }  .camera-controls button {   background-color: rgba(99, 114, 166, 0.15);   border: 1px solid var(--border-light);   color: var(--text-primary);   border-radius: 4px;   padding: 8px 12px;   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }  .camera-controls button:hover {   background-color: rgba(124, 77, 255, 0.15);   border-color: var(--accent-primary);   box-shadow: 0 0 12px rgba(124, 77, 255, 0.2);   transform: translateY(-2px) scale(1.02); }  .camera-controls button:active {   transform: translateY(1px); }  .camera-controls .color-picker {   border: 1px solid var(--border-light);   border-radius: 4px;   overflow: hidden;   box-shadow: var(--shadow-sm); }  .camera-controls .size-slider {   background: var(--bg-secondary);   border: 1px solid var(--border-light);   border-radius: 4px;   height: 6px;   box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.2); }  .camera-controls .size-slider::-webkit-slider-thumb {   background: var(--accent-primary);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.4);   border-radius: 50%;   cursor: pointer;   transition: all 0.2s ease; }  .camera-controls .size-slider::-webkit-slider-thumb:hover {   transform: scale(1.2); }  /* Form elements with attractive focus states */ label {   font-weight: 500;   text-transform: uppercase;   letter-spacing: 0.5px;   color: var(--accent-primary);   margin-bottom: 6px;   display: block;   font-size: 0.85rem; }  input, textarea, select {   border: 1px solid var(--border-light);   background-color: rgba(15, 17, 26, 0.6);   color: var(--text-primary);   border-radius: 4px;   padding: 10px 12px;   box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);   transition: all 0.3s ease;   font-family: 'JetBrains Mono', monospace; }  input:focus, textarea:focus, select:focus {   outline: none;   border-color: var(--accent-primary);   box-shadow: 0 0 0 3px rgba(124, 77, 255, 0.2), inset 0 2px 4px rgba(0, 0, 0, 0.1);   background-color: rgba(20, 23, 37, 0.8); }  /* Modern button styles with micro-interactions */ button {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-light);   color: var(--text-primary);   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 10px 16px;   border-radius: 4px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   position: relative;   overflow: hidden; }  button:hover {   background-color: rgba(99, 114, 166, 0.2);   border-color: var(--border-light);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);   transform: translateY(-2px); }  button:active {   transform: translateY(1px); }  button::after {   content: '';   position: absolute;   top: 50%;   left: 50%;   width: 100%;   height: 100%;   background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, transparent 50%);   transform: scale(0);   opacity: 0;   transition: transform 0.5s, opacity 0.3s;   pointer-events: none; }  button:active::after {   transform: scale(2);   opacity: 1;   transition: 0s; }  button.primary {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(0, 188, 212, 0.2));   border: 1px solid var(--accent-primary);   color: var(--text-primary);   position: relative;   z-index: 1; }  button.primary:hover {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.3), rgba(0, 188, 212, 0.3));   box-shadow: 0 4px 16px rgba(124, 77, 255, 0.3); }  button.primary::before {   content: '';   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   background: var(--gradient-accent);   opacity: 0;   z-index: -1;   transition: opacity 0.3s ease;   border-radius: 3px; }  button.primary:hover::before {   opacity: 0.1; }  button.danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336; }  button.danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2); }  button.active {   border: 1px solid var(--accent-secondary);   box-shadow: 0 0 12px rgba(0, 188, 212, 0.3);   color: var(--accent-secondary);   background-color: rgba(0, 188, 212, 0.15); }  /* Modal with glassmorphism effect */ .modal {   background-color: rgba(15, 17, 26, 0.7);   backdrop-filter: blur(8px);   -webkit-backdrop-filter: blur(8px); }  .modal-content {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-lg);   border-radius: 8px;   overflow: hidden;   animation: modalAppear 0.3s ease; }  @keyframes modalAppear {   from {     opacity: 0;     transform: scale(0.95) translateY(-10px);   }   to {     opacity: 1;     transform: scale(1) translateY(0);   } }  .property-list {   border: 1px solid var(--border-light);   background-color: var(--bg-tertiary);   border-radius: 6px;   overflow: hidden; }  /* Tab navigation with smooth transitions */ .tab-navigation {   border-bottom: 1px solid var(--border-light);   display: flex;   gap: 4px;   padding: 0 6px; }  .tab {   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 10px 16px;   color: var(--text-secondary);   position: relative;   transition: all 0.3s ease;   border-radius: 4px 4px 0 0; }  .tab:hover {   background-color: rgba(99, 114, 166, 0.1);   color: var(--text-primary); }  .tab.active {   color: var(--accent-primary);   font-weight: 600;   background-color: rgba(124, 77, 255, 0.05); }  .tab.active::after {   content: '';   position: absolute;   bottom: -1px;   left: 0;   right: 0;   height: 2px;   background: var(--gradient-accent);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.5); }  /* Stylized instructions and warnings */ .instructions {   background-color: rgba(124, 77, 255, 0.05);   border-left: 3px solid var(--accent-primary);   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0;   box-shadow: var(--shadow-sm);   position: relative; }  .instructions::before {   content: 'i';   position: absolute;   left: -12px;   top: 10px;   width: 20px;   height: 20px;   background: var(--accent-primary);   border-radius: 50%;   display: flex;   align-items: center;   justify-content: center;   font-weight: bold;   font-style: italic;   color: white;   font-size: 14px; }  #grid-display {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px;   overflow: hidden; }  .success-message {   color: #4caf50;   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   animation: fadeOut 2s forwards;   animation-delay: 1.5s;   padding: 8px 12px;   background-color: rgba(76, 175, 80, 0.1);   border-radius: 4px;   display: inline-block; }  @keyframes fadeOut {   from { opacity: 1; }   to { opacity: 0; } }  .warning {   background-color: rgba(244, 67, 54, 0.1);   border-left: 3px solid #f44336;   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0;   box-shadow: var(--shadow-sm);   position: relative; }  .warning::before {   content: '!';   position: absolute;   left: -12px;   top: 10px;   width: 20px;   height: 20px;   background: #f44336;   border-radius: 50%;   display: flex;   align-items: center;   justify-content: center;   font-weight: bold;   color: white;   font-size: 14px; }  /* Content containers with subtle gradients */ .main-content-container {   background-color: var(--bg-primary);   color: var(--text-primary); }  .content-sidebar {   background: var(--gradient-bg);   border-right: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  #graphics-rightbar {   background: var(--gradient-bg);   border-left: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  /* Subtle grid background */ .grid-background {   background: var(--bg-primary);   background-image:      linear-gradient(rgba(99, 114, 166, 0.05) 1px, transparent 1px),     linear-gradient(90deg, rgba(99, 114, 166, 0.05) 1px, transparent 1px);   background-size: 20px 20px; }  /* Toolbar with subtle glassmorphism */ .toolbar {   background: var(--gradient-bg);   border-bottom: 1px solid var(--border-light);   box-shadow: var(--shadow-sm);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px);   padding: 8px 16px;   display: flex;   align-items: center;   gap: 8px; }  /* Button variations with consistent styling */ .btn {   border: 1px solid var(--border-light);   background-color: rgba(99, 114, 166, 0.1);   color: var(--text-primary);   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 8px 14px;   border-radius: 4px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   position: relative;   overflow: hidden;   font-size: 0.85rem; }  .btn:hover {   background-color: rgba(99, 114, 166, 0.2);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);   transform: translateY(-2px); }  .btn:active {   transform: translateY(1px); }  .btn-primary {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(0, 188, 212, 0.2));   border: 1px solid var(--accent-primary);   color: var(--text-primary);   position: relative;   z-index: 1; }  .btn-primary:hover {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.3), rgba(0, 188, 212, 0.3));   box-shadow: 0 4px 16px rgba(124, 77, 255, 0.2); }  .btn-primary::before {   content: '';   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   background: var(--gradient-accent);   opacity: 0;   z-index: -1;   transition: opacity 0.3s ease;   border-radius: 3px; }  .btn-primary:hover::before {   opacity: 0.1; }  .btn-danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336; }  .btn-danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2); }  .btn-secondary {   background-color: rgba(99, 114, 166, 0.1);   border: 1px solid var(--border-light); }  .btn-secondary:hover {   background-color: rgba(99, 114, 166, 0.2);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }  .btn-special {   background-color: rgba(0, 188, 212, 0.15);   border: 1px solid var(--accent-secondary);   color: var(--accent-secondary); }  .btn-special:hover {   background-color: rgba(0, 188, 212, 0.25);   box-shadow: 0 4px 16px rgba(0, 188, 212, 0.2); }  /* Shape list with improved visual hierarchy */ #shape-list {   border-bottom: 1px solid var(--border-light);   padding-bottom: 16px;   margin-bottom: 16px; }  .shape-item {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-light);   border-radius: 4px;   padding: 10px 14px;   margin-bottom: 6px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   display: flex;   align-items: center;   gap: 8px; }  .shape-item:hover {   background-color: rgba(99, 114, 166, 0.15);   transform: translateX(3px);   border-color: var(--border-light); }  .shape-item.active {   background-color: rgba(0, 188, 212, 0.1);   border-color: var(--accent-secondary);   color: var(--accent-secondary);   box-shadow: 0 0 12px rgba(0, 188, 212, 0.15);   font-weight: 500; }  /* Inspector panel with clean design */ #inspector {   background: var(--bg-secondary);   border-top: 1px solid var(--border-light);   padding: 16px; }  .form-row {   margin-bottom: 12px; }  .form-row label {   color: var(--accent-primary);   margin-bottom: 6px; }  .form-row input, .form-row select {   width: 100%;   border: 1px solid var(--border-light);   background-color: rgba(15, 17, 26, 0.6);   color: var(--text-primary);   padding: 10px 12px;   border-radius: 4px; }  /* Scene info with modern styling */ .scene-info {   background: var(--bg-tertiary);   color: var(--text-primary);   border: 1px solid var(--border-light);   border-radius: 6px;   padding: 12px 16px;   margin-bottom: 16px;   box-shadow: var(--shadow-sm); }  .button-danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336;   padding: 10px 16px;   border-radius: 4px;   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }  .button-danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2);   transform: translateY(-2px); }  /* Typography improvements */ h2, h3 {   color: var(--accent-primary);   text-transform: uppercase;   letter-spacing: 1px;   margin-bottom: 16px;   padding-bottom: 8px;   border-bottom: 1px solid var(--border-light);   font-weight: 600;   text-shadow: 0 0 20px rgba(124, 77, 255, 0.3);   position: relative; }  h2::after, h3::after {   content: '';   position: absolute;   bottom: -1px;   left: 0;   width: 50px;   height: 2px;   background: var(--gradient-accent);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.5); }  /* Sleek scrollbars */ ::-webkit-scrollbar {   width: 6px;   height: 6px; }  ::-webkit-scrollbar-track {   background: var(--bg-tertiary);   border-radius: 3px; }  ::-webkit-scrollbar-thumb {   background: rgba(124, 77, 255, 0.3);   border-radius: 3px;   border: 1px solid var(--bg-tertiary); }  ::-webkit-scrollbar-thumb:hover {   background: var(--accent-primary); }  /* Animations and transitions */ @keyframes pulse {   0% { box-shadow: 0 0 0 0 rgba(124, 77, 255, 0.4); }   70% { box-shadow: 0 0 0 10px rgba(124, 77, 255, 0); }   100% { box-shadow: 0 0 0 0 rgba(124, 77, 255, 0); } }  .pulse-animation {   animation: pulse 2s infinite; }  /* Tooltips */ [data-tooltip] {   position: relative; }  [data-tooltip]::after {   content: attr(data-tooltip);   position: absolute;   bottom: 125%;   left: 50%;   transform: translateX(-50%);   padding: 6px 10px;   background: var(--bg-tertiary);   color: var(--text-primary);   border-radius: 4px;   font-size: 0.75rem;   white-space: nowrap;   opacity: 0;   visibility: hidden;   transition: all 0.3s ease;   z-index: 100;   box-shadow: var(--shadow-md);   border: 1px solid var(--border-light); }  [data-tooltip]:hover::after {   opacity: 1;   visibility: visible; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional3.css"
    },
    "scifi2": {
      "title": "SciFi2.0",
      "fileName": "scifi2",
      "css": "@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap'); :root {     --primary-bg: #0a0a1a;     --secondary-bg: #121228;     --accent-color: #00ffff;     --text-color: #e0e7ff;     --border-color: #2a2a4a;     --highlight-color: #ff00ff;     --hover-color: rgba(0, 255, 255, 0.2); }  body {     background-color: var(--primary-bg);     color: var(--text-color);     font-family: 'Orbitron', 'Arial', sans-serif;     line-height: 1.6; }  .container {     background-color: var(--secondary-bg);     border: 2px solid var(--border-color);     box-shadow: 0 0 20px rgba(0, 255, 255, 0.1); }  /* Sidebar Styling */ .sidebar {     background-color: #0f0f2a;     border-right: 1px solid var(--border-color); }  .object-item, .object-type-item {     background-color: var(--secondary-bg);     border: 1px solid var(--border-color);     color: var(--text-color);     transition: all 0.3s ease; }  .object-item:hover, .object-type-item:hover {     background-color: var(--hover-color);     border-color: var(--accent-color); }  .object-item.selected, .object-type-item.selected {     background-color: var(--accent-color);     color: var(--primary-bg); }  /* Button Styling */ button {     background-color: var(--secondary-bg);     color: var(--accent-color);     border: 2px solid var(--accent-color);     transition: all 0.3s ease;     position: relative;     overflow: hidden; }  button:before {     content: '';     position: absolute;     top: 0;     left: -100%;     width: 100%;     height: 100%;     background: linear-gradient(120deg, transparent, var(--highlight-color), transparent);     transition: all 0.5s ease; }  button:hover:before {     left: 100%; }  button:hover {     background-color: var(--accent-color);     color: var(--primary-bg); }  .primary {     background-color: var(--accent-color);     color: var(--primary-bg); }  .danger {     border-color: #ff4444;     color: #ff4444; }  /* Input Styling */ input, textarea, select {     background-color: var(--secondary-bg);     color: var(--text-color);     border: 1px solid var(--border-color);     transition: border-color 0.3s ease; }  input:focus, textarea:focus, select:focus {     border-color: var(--accent-color);     outline: none;     box-shadow: 0 0 10px rgba(0, 255, 255, 0.2); }  /* Modal Styling */ .modal {     background-color: rgba(10, 10, 26, 0.9); }  .modal-content {     background-color: var(--secondary-bg);     border: 2px solid var(--border-color);     box-shadow: 0 0 30px rgba(0, 255, 255, 0.1); }  /* Graphics Editor Enhancements */ #canvas-container {     background:          linear-gradient(45deg, rgba(0,255,255,0.05) 25%, transparent 25%) 0 0,         linear-gradient(-45deg, rgba(0,255,255,0.05) 25%, transparent 25%) 0 0,         linear-gradient(45deg, transparent 75%, rgba(0,255,255,0.05) 75%) 0 0,         linear-gradient(-45deg, transparent 75%, rgba(0,255,255,0.05) 75%) 0 0;     background-size: 20px 20px;     background-color: var(--primary-bg); }  .scene-info {     background-color: rgba(18, 18, 40, 0.8);     border: 1px solid var(--border-color);     color: var(--accent-color); }  /* Toolbar Styling */ .toolbar .btn {     background-color: var(--secondary-bg);     border-color: var(--border-color);     color: var(--accent-color); }  .toolbar .btn:hover {     background-color: var(--accent-color);     color: var(--primary-bg); }  /* Tab and Category Styling */ .tab, .category-header {     color: var(--text-color);     transition: color 0.3s ease; }  .tab:hover, .category-header:hover {     color: var(--accent-color); }  .tab.active {     border-bottom-color: var(--accent-color); }  /* Scrollbar (for browsers that support) */ ::-webkit-scrollbar {     width: 10px; }  ::-webkit-scrollbar-track {     background: var(--secondary-bg); }  ::-webkit-scrollbar-thumb {     background: var(--accent-color);     border-radius: 5px; }  ::-webkit-scrollbar-thumb:hover {     background: var(--highlight-color); }  /* Subtle Sci-Fi Animations */ @keyframes pulse-border {     0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }     50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); } }  @keyframes grid-pulse {     0%, 100% { opacity: 0.1; }     50% { opacity: 0.3; } }  /* Additional Futuristic Effects */ body::before {     content: '';     position: fixed;     top: 0;     left: 0;     width: 100%;     height: 100%;     pointer-events: none;     background:          repeating-linear-gradient(             0deg,             rgba(0, 0, 0, 0.15),             rgba(0, 0, 0, 0.15) 1px,             transparent 1px,             transparent 2px         );     opacity: 0.3;     z-index: 9999; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/scifi2.css"
    },
    "videogame": {
      "title": "Video Game",
      "fileName": "videogame",
      "css": "@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');  body {     font-family: 'Orbitron', 'Share Tech Mono', sans-serif;     background-color: #0a0a0a; /* Deep black */     color: #00d4ff; /* Neon blue */     overflow: hidden; }  .sidebar {     background: linear-gradient(135deg, rgba(10, 10, 10, 0.9), rgba(155, 0, 255, 0.1)); /* Black to purple fade */     border: 1px solid #ff007a; /* Hot pink */     box-shadow: 0 0 15px rgba(0, 212, 255, 0.5), inset 0 0 10px rgba(155, 0, 255, 0.3); }  .inventory-item {     background-color: rgba(12, 12, 12, 0.7);     border-left: 3px solid #9b00ff; /* Electric purple */     text-transform: uppercase;     letter-spacing: 2px;     transition: all 0.2s ease; }  .inventory-item:hover {     background-color: rgba(0, 212, 255, 0.2);     transform: scale(1.03);     box-shadow: 0 0 10px rgba(0, 212, 255, 0.7); }  .inventory-item.active {     background-color: rgba(255, 0, 122, 0.3); /* Pink glow */     border-left: 5px solid #ff007a;     box-shadow: 0 0 15px rgba(255, 0, 122, 0.8); }  .hud {     background: rgba(10, 10, 10, 0.8);     border: 1px solid #00d4ff;     box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); }  #game-canvas {     border: 1px dashed #c0c0c0; /* Silver dashed */     background: radial-gradient(circle, rgba(155, 0, 255, 0.1), transparent); }  .hologram-display {     border: 2px solid #9b00ff;     box-shadow: 0 0 25px rgba(155, 0, 255, 0.6);     animation: pulseGlow 2s infinite alternate; }  @keyframes pulseGlow {     0% { box-shadow: 0 0 25px rgba(155, 0, 255, 0.6); }     100% { box-shadow: 0 0 35px rgba(155, 0, 255, 0.9); } }  .control-panel {     background: rgba(0, 0, 0, 0.85);     border: 1px solid #c0c0c0; }  .control-panel button {     background-color: rgba(0, 212, 255, 0.2);     border: 1px solid #00d4ff;     color: #fff;     text-transform: uppercase;     transition: all 0.3s ease; }  .control-panel button:hover {     background-color: rgba(0, 212, 255, 0.4);     box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);     transform: translateY(-3px); }  label {     color: #ff007a; /* Hot pink */     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1.5px; }  input, textarea, select {     border: 1px solid #9b00ff;     background-color: rgba(10, 10, 10, 0.7);     color: #00d4ff;     box-shadow: 0 0 8px rgba(155, 0, 255, 0.4); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #ff007a;     box-shadow: 0 0 12px rgba(255, 0, 122, 0.7); }  button {     background-color: rgba(155, 0, 255, 0.2);     border: 1px solid #9b00ff;     color: #fff;     text-transform: uppercase;     letter-spacing: 1px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(155, 0, 255, 0.4);     box-shadow: 0 0 15px rgba(155, 0, 255, 0.7);     transform: translateY(-2px) scale(1.05); }  button.primary {     background-color: rgba(0, 212, 255, 0.3);     border: 1px solid #00d4ff;     color: #fff; }  button.primary:hover {     background-color: rgba(0, 212, 255, 0.5);     box-shadow: 0 0 20px rgba(0, 212, 255, 0.9); }  button.alert {     background-color: rgba(255, 0, 122, 0.2);     border: 1px solid #ff007a;     color: #fff; }  button.alert:hover {     background-color: rgba(255, 0, 122, 0.4);     box-shadow: 0 0 15px rgba(255, 0, 122, 0.7); }  .modal {     background: rgba(0, 0, 0, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background: linear-gradient(45deg, rgba(10, 10, 10, 0.9), rgba(0, 212, 255, 0.1));     border: 1px solid #00d4ff;     box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }  .notification {     background-color: rgba(155, 0, 255, 0.3);     border-left: 4px solid #9b00ff;     color: #fff;     animation: slideIn 0.5s ease-out; }  @keyframes slideIn {     0% { transform: translateX(100%); opacity: 0; }     100% { transform: translateX(0); opacity: 1; } }  .main-content {     background: #0a0a0a;     animation: glitch 4s infinite; }   .grid-overlay {     background: repeating-linear-gradient(45deg, rgba(155, 0, 255, 0.05), rgba(155, 0, 255, 0.05) 10px, transparent 10px, transparent 20px); }  .btn {     border: 1px solid #c0c0c0;     background-color: rgba(0, 212, 255, 0.15);     color: #fff; }  .btn:hover {     background-color: rgba(0, 212, 255, 0.3);     box-shadow: 0 0 10px rgba(0, 212, 255, 0.6); }  .btn-primary {     background-color: rgba(9b, 0, 255, 0.25);     border: 1px solid #9b00ff; }  .btn-primary:hover {     background-color: rgba(155, 0, 255, 0.45);     box-shadow: 0 0 15px rgba(155, 0, 255, 0.8); }  ::-webkit-scrollbar {     width: 6px; }  ::-webkit-scrollbar-track {     background: #0a0a0a; }  ::-webkit-scrollbar-thumb {     background: #00d4ff;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #ff007a; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/videogame.css"
    },
    "videoGame2": {
      "title": "Video Game 2",
      "fileName": "videoGame2",
      "css": "/* retro-theme.css - Pixel Art Retro Video Game Theme */\r\n\r\n/* Import pixel font from Google Fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\r\n\r\n/* Base Styles */\r\nbody {\r\n    background-color: #1a1a1a; /* Dark retro background */\r\n    font-family: 'Press Start 2P', cursive; /* Pixelated font */\r\n    image-rendering: pixelated; /* Ensures crisp pixel art rendering */\r\n    color: #fff; /* Default text color */\r\n}\r\n\r\n/* Container */\r\n.container {\r\n    background: #2b2b2b; /* Retro gray */\r\n    border: 4px solid #000; /* Thick black border */\r\n    padding: .5em;\r\n}\r\n\r\n/* Sidebar */\r\n.sidebar {\r\n    background: #3c3c3c; /* Mid-gray retro */\r\n    border: 4px solid #000;\r\n}\r\n\r\n.sidebar img {\r\n    image-rendering: pixelated;\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n/* Object List */\r\n.object-item {\r\n    background: #5a5a5a; /* Darker gray */\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px; /* Smaller for pixel readability */\r\n}\r\n\r\n.object-item:hover, .object-item.selected {\r\n    background: #ffcc00; /* Bright retro yellow */\r\n    color: #000;\r\n}\r\n.object-type-item.selected {\r\n    color: #ffcc00;\r\n}\r\n\r\n/* Buttons */\r\nbutton {\r\n    background: #ff3333; /* Retro red */\r\n    color: #fff;\r\n    border: 2px solid #000;\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n    text-transform: uppercase; /* Retro game style */\r\n    transition: background 0.1s ease;\r\n}\r\n\r\nbutton:hover {\r\n    background: #33cc33; /* Retro green */\r\n}\r\n\r\nbutton.primary {\r\n    background: #33cc33; /* Green for primary actions */\r\n}\r\n\r\nbutton.primary:hover {\r\n    background: #ffcc00; /* Yellow on hover */\r\n}\r\n\r\n/* Main Content */\r\n.main-content {\r\n    background: #2b2b2b;\r\n}\r\n\r\n/* Editor */\r\n.editor {\r\n    background: #3c3c3c;\r\n    border: 4px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Canvas and Grid Containers */\r\n#canvas-container, .grid-container {\r\n    background: #000; /* Black canvas background */\r\n    border: 4px solid #fff;\r\n}\r\n\r\n#canvas, #grid {\r\n    image-rendering: pixelated;\r\n    background: repeating-linear-gradient(\r\n        45deg,\r\n        #333 0px,\r\n        #333 10px,\r\n        #000 10px,\r\n        #000 20px\r\n    ); /* Retro checkerboard grid */\r\n}\r\n\r\n.scene-info {\r\n    background: rgba(0, 0, 0, 0.8);\r\n    border: 2px solid #fff;\r\n    color: #00ff00; /* Neon green */\r\n    font-size: 8px;\r\n}\r\n\r\n/* Toolbar */\r\n.toolbar {\r\n    background: #5a5a5a;\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n.btn {\r\n    background: #ff3333; /* Retro red */\r\n    color: #fff;\r\n    border: 2px solid #000;\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n    transition: background 0.1s ease;\r\n}\r\n\r\n.btn:hover {\r\n    background: #33cc33; /* Retro green */\r\n}\r\n\r\n.btn.btn-danger {\r\n    background: #ff0000; /* Bright red */\r\n}\r\n\r\n.btn.btn-danger:hover {\r\n    background: #cc0000; /* Darker red */\r\n}\r\n\r\n.btn.btn-secondary {\r\n    background: #6666ff; /* Retro blue */\r\n}\r\n\r\n.btn.btn-secondary:hover {\r\n    background: #9999ff; /* Lighter blue */\r\n}\r\n\r\n.btn.btn-special {\r\n    background: #ff00ff; /* Retro magenta */\r\n}\r\n\r\n.btn.btn-special:hover {\r\n    background: #cc00cc; /* Darker magenta */\r\n}\r\n\r\n/* Modals */\r\n.modal {\r\n    background: rgba(0, 0, 0, 0.8);\r\n}\r\n\r\n.modal-content {\r\n    background: #3c3c3c;\r\n    border: 4px solid #fff;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Form Elements */\r\n.form-group label {\r\n    color: #00ff00; /* Neon green */\r\n    font-size: 10px;\r\n}\r\n\r\ninput, textarea, select {\r\n    background: #000;\r\n    border: 2px solid #fff;\r\n    color: #ffcc00; /* Retro yellow */\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n}\r\n\r\ninput[type=\"color\"] {\r\n    padding: 0; /* Fix color picker padding */\r\n    height: 20px; /* Consistent height */\r\n}\r\n\r\n/* Tabs */\r\n.tab-navigation {\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n.tab {\r\n    background: #5a5a5a;\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n.tab.active {\r\n    background: #ffcc00; /* Yellow for active tab */\r\n    color: #000;\r\n}\r\n\r\n/* Inspector and JSON Editor */\r\n#inspector, #json-editor {\r\n    background: #3c3c3c;\r\n    border: 2px solid #000;\r\n}\r\n\r\n#json-content {\r\n    background: #000;\r\n    color: #00ff00; /* Green for code-like text */\r\n}\r\n\r\n/* Translation Controls */\r\n.translation-controls button {\r\n    background: #6666ff; /* Retro blue */\r\n}\r\n\r\n.translation-controls button:hover {\r\n    background: #9999ff;\r\n}\r\n\r\n/* Shape List */\r\n.shape-item {\r\n    background: #5a5a5a;\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n.shape-item:hover {\r\n    background: #ffcc00;\r\n    color: #000;\r\n}\r\n\r\n.type-selector .object-item {\r\n  font-size: .6em;\r\n}\r\n\r\n/* codemirror-retro.css - Retro Pixel Art Theme for CodeMirror */\r\n\r\n/* Import pixel font from Google Fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\r\n\r\n/* Base CodeMirror Styles */\r\n.CodeMirror {\r\n    height: 100% !important;\r\n    font-family: 'Press Start 2P', cursive !important;\r\n    font-size: 10px !important; /* Small size for pixel readability */\r\n    background: #000 !important; /* Black background like a CRT screen */\r\n    color: #00ff00 !important; /* Neon green default text */\r\n    border: 4px solid #fff !important; /* Thick white border */\r\n    image-rendering: pixelated; /* Crisp rendering */\r\n}\r\n.CodeMirror-gutters {\r\n background-color: #000;\r\n}\r\n\r\n/* Retro Theme Definition */\r\n.cm-s-retro .CodeMirror-gutters {\r\n    background: #1a1a1a !important; /* Dark gray gutter */\r\n    border-right: 2px solid #fff !important; /* White separator */\r\n    color: #ffcc00 !important; /* Yellow line numbers */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-linenumber {\r\n    color: #ffcc00 !important; /* Yellow line numbers */\r\n    padding: 0 5px !important;\r\n}\r\n\r\n.cm-s-retro .CodeMirror-cursor {\r\n    border-left: 2px solid #ff3333 !important; /* Red blinking cursor */\r\n    animation: blink 1s step-end infinite; /* Retro blink effect */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-selected {\r\n    background: #ff3333 !important; /* Red selection highlight */\r\n    opacity: 0.5; /* Slightly transparent for retro effect */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-focused .CodeMirror-selected {\r\n    background: #ff3333 !important;\r\n}\r\n\r\n/* Syntax Highlighting */\r\n.cm-s-retro .cm-comment {\r\n    color: #6666ff !important; /* Blue for comments */\r\n    font-style: italic; /* Slight retro flair */\r\n}\r\n\r\n.cm-s-retro .cm-string {\r\n    color: #ffcc00 !important; /* Yellow for strings */\r\n}\r\n\r\n.cm-s-retro .cm-number {\r\n    color: #33cc33 !important; /* Green for numbers */\r\n}\r\n\r\n.cm-s-retro .cm-keyword {\r\n    color: #ff00ff !important; /* Magenta for keywords */\r\n    font-weight: bold; /* Bold for emphasis */\r\n}\r\n\r\n.cm-s-retro .cm-operator {\r\n    color: #fff !important; /* White for operators */\r\n}\r\n\r\n.cm-s-retro .cm-variable {\r\n    color: #00ff00 !important; /* Green for variables */\r\n}\r\n\r\n.cm-s-retro .cm-variable-2 {\r\n    color: #33cc33 !important; /* Lighter green for secondary variables */\r\n}\r\n\r\n.cm-s-retro .cm-def {\r\n    color: #ff00ff !important; /* Magenta for definitions */\r\n}\r\n\r\n.cm-s-retro .cm-property {\r\n    color: #ffcc00 !important; /* Yellow for properties */\r\n}\r\n\r\n.cm-s-retro .cm-function {\r\n    color: #ff00ff !important; /* Magenta for functions */\r\n}\r\n\r\n.cm-s-retro .cm-builtin {\r\n    color: #33cc33 !important; /* Green for built-ins */\r\n}\r\n\r\n.cm-s-retro .cm-tag {\r\n    color: #ff3333 !important; /* Red for tags (if HTML mode is used) */\r\n}\r\n\r\n.cm-s-retro .cm-attribute {\r\n    color: #ffcc00 !important; /* Yellow for attributes */\r\n}\r\n\r\n/* Matching Brackets */\r\n.cm-s-retro .CodeMirror-matchingbracket {\r\n    color: #33cc33 !important; /* Green for matching brackets */\r\n    border-bottom: 2px solid #33cc33 !important;\r\n    background: none !important;\r\n}\r\n\r\n.cm-s-retro .CodeMirror-nonmatchingbracket {\r\n    color: #ff3333 !important; /* Red for non-matching brackets */\r\n    border-bottom: 2px solid #ff3333 !important;\r\n}\r\n\r\n/* Autocomplete Hints */\r\n.CodeMirror-hints {\r\n    background: #2b2b2b !important; /* Dark retro gray */\r\n    border: 2px solid #fff !important; /* White border */\r\n    color: #fff !important;\r\n    font-family: 'Press Start 2P', cursive !important;\r\n    font-size: 10px !important;\r\n    box-shadow: 4px 4px 0 #000; /* Retro shadow effect */\r\n}\r\n\r\n.CodeMirror-hints .CodeMirror-hint {\r\n    color: #ffcc00 !important; /* Yellow for hint items */\r\n    padding: 5px !important;\r\n}\r\n\r\n.CodeMirror-hints .CodeMirror-hint-active {\r\n    background: #ff3333 !important; /* Red for selected hint */\r\n    color: #000 !important;\r\n}\r\n\r\n/* Scrollbars (minimal retro style) */\r\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar {\r\n    background: #3c3c3c !important;\r\n}\r\n\r\n.CodeMirror-scrollbar-filler {\r\n    background: #000 !important;\r\n}\r\n\r\n/* Animations */\r\n@keyframes blink {\r\n    50% { opacity: 0; }\r\n}",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/videoGame2.css"
    }
  },
  "attackSounds": {
    "laser": {
      "title": "Laser",
      "audio": {
        "waveform": "triangle",
        "frequency": 197,
        "duration": 0.1,
        "envelope": {
          "attack": 0.001,
          "decay": 0.076,
          "sustain": 0.5,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 3.41,
          "end": 0.23,
          "time": 0.1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 400,
            "Q": 1
          },
          "distortion": 5,
          "delay": {
            "time": 0.27,
            "feedback": 0.09
          },
          "reverb": 0,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    },
    "gunshot": {
      "title": "GunShot",
      "audio": {
        "waveform": "noise",
        "frequency": 200,
        "duration": 0.5,
        "noise": {
          "type": "pink",
          "amount": 0.8,
          "filter": {
            "type": "lowpass",
            "frequency": 400
          }
        },
        "envelope": {
          "attack": 0.01,
          "decay": 0.3,
          "sustain": 0.2,
          "release": 0.1
        },
        "pitchEnvelope": {
          "start": 4,
          "end": 2,
          "time": 0.5
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 800,
            "Q": 1
          },
          "distortion": 2,
          "delay": {
            "time": 0.1,
            "feedback": 0.3
          },
          "reverb": 0.4,
          "bitcrusher": 0.5,
          "pan": 0
        }
      }
    },
    "missileLaunch": {
      "title": "Missile Launch",
      "audio": {
        "waveform": "noise",
        "frequency": 341,
        "duration": 0.4,
        "noise": {
          "type": "brown",
          "amount": 0.63,
          "filter": {
            "type": "bandpass",
            "frequency": 20
          }
        },
        "envelope": {
          "attack": 0.252,
          "decay": 0.4,
          "sustain": 0,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 3.38,
          "end": 0.59,
          "time": 0.4
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 20000,
            "Q": 1
          },
          "distortion": 0,
          "delay": {
            "time": 0,
            "feedback": 0
          },
          "reverb": 0.11,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    },
    "plasma": {
      "title": "Plasma",
      "audio": {
        "waveform": "triangle",
        "frequency": 197,
        "duration": 0.1,
        "envelope": {
          "attack": 0.001,
          "decay": 0.076,
          "sustain": 0.5,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 3.41,
          "end": 0.23,
          "time": 0.1
        },
        "effects": {
          "filter": {
            "type": "highpass",
            "frequency": 4000,
            "Q": 1
          },
          "distortion": 5,
          "delay": {
            "time": 0,
            "feedback": 0
          },
          "reverb": 0,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    },
    "TeslaAttack": {
      "title": "Tesla Attack",
      "audio": {
        "waveform": "noise",
        "frequency": 200,
        "duration": 0.15,
        "envelope": {
          "attack": 0.001,
          "decay": 0.03,
          "sustain": 0.4,
          "release": 0.02
        },
        "pitchEnvelope": {
          "start": 2.5,
          "end": 0.8,
          "time": 0.15
        },
        "effects": {
          "filter": {
            "type": "bandpass",
            "frequency": 1200,
            "Q": 3
          },
          "distortion": 30,
          "delay": {
            "time": 0.05,
            "feedback": 0.05
          },
          "reverb": 0.05,
          "bitcrusher": 0.5,
          "pan": 0
        }
      }
    }
  },
  "hitSounds": {
    "explosion": {
      "title": "Explosion",
      "audio": {
        "waveform": "noise",
        "frequency": 100,
        "duration": 1,
        "noise": {
          "type": "white",
          "amount": 0,
          "filter": {
            "type": "none",
            "frequency": 2000
          }
        },
        "envelope": {
          "attack": 0.005,
          "decay": 0.2,
          "sustain": 0.3,
          "release": 0.3
        },
        "pitchEnvelope": {
          "start": 2,
          "end": 0.5,
          "time": 1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 800,
            "Q": 1
          },
          "distortion": 3,
          "delay": {
            "time": 0.15,
            "feedback": 0.25
          },
          "reverb": 0.5,
          "bitcrusher": 0.5,
          "pan": 0
        }
      }
    },
    "explosion_loud": {
      "title": "Explosion Loud",
      "audio": {
        "waveform": "noise",
        "frequency": 100,
        "duration": 1,
        "noise": {
          "type": "white",
          "amount": 0,
          "filter": {
            "type": "none",
            "frequency": 2000
          }
        },
        "envelope": {
          "attack": 0.005,
          "decay": 0.2,
          "sustain": 0.3,
          "release": 0.3
        },
        "pitchEnvelope": {
          "start": 2,
          "end": 0.5,
          "time": 1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 800,
            "Q": 1
          },
          "distortion": 3,
          "delay": {
            "time": 0.15,
            "feedback": 0.25
          },
          "reverb": 0.5,
          "bitcrusher": 0.5,
          "pan": 0
        }
      }
    },
    "plasma": {
      "title": "Plasma",
      "audio": {
        "waveform": "noise",
        "frequency": 48,
        "duration": 0.1,
        "noise": {
          "type": "white",
          "amount": 0,
          "filter": {
            "type": "none",
            "frequency": 20
          }
        },
        "envelope": {
          "attack": 0.012,
          "decay": 0.064,
          "sustain": 0.01,
          "release": 0.062
        },
        "pitchEnvelope": {
          "start": 2.45,
          "end": 0.72,
          "time": 0.1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 13141,
            "Q": 0.1
          },
          "distortion": 1,
          "delay": {
            "time": 0.05,
            "feedback": 0.03
          },
          "reverb": 0,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    }
  },
  "sounds": {
    "pickup": {
      "title": "Pickup",
      "audio": {
        "waveform": "triangle",
        "frequency": 200,
        "duration": 0.1,
        "envelope": {
          "attack": 0.001,
          "decay": 0,
          "sustain": 0,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 0.34,
          "end": 1.89,
          "time": 0.1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 400,
            "Q": 1
          },
          "distortion": 20,
          "delay": {
            "time": 0,
            "feedback": 0.2
          },
          "reverb": 0,
          "bitcrusher": 0.1,
          "pan": 0
        }
      }
    },
    "placeTower": {
      "title": "Place Tower",
      "audio": {
        "waveform": "sine",
        "frequency": 20,
        "duration": 0.2,
        "noise": {
          "type": "pink",
          "amount": 0.8,
          "filter": {
            "type": "lowpass",
            "frequency": 400
          }
        },
        "envelope": {
          "attack": 0.01,
          "decay": 0,
          "sustain": 0.1,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 4,
          "end": 4,
          "time": 0.2
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 500,
            "Q": 1
          },
          "distortion": 0,
          "delay": {
            "time": 0.05,
            "feedback": 0.2
          },
          "reverb": 0.3,
          "bitcrusher": 0.4,
          "pan": 0
        }
      }
    },
    "test": {
      "title": "test",
      "audio": {
        "waveform": "noise",
        "frequency": 440,
        "duration": 0.6,
        "noise": {
          "type": "pink",
          "amount": 1,
          "filter": {
            "type": "bandpass",
            "frequency": 1200,
            "Q": 1.8
          }
        },
        "envelope": {
          "attack": 0.02,
          "decay": 0.4,
          "sustain": 0,
          "release": 0
        },
        "pitchEnvelope": {
          "start": 1.8,
          "end": 0.4,
          "time": 0.5
        },
        "effects": {
          "filter": {
            "type": "none",
            "frequency": 20000,
            "Q": 1
          },
          "distortion": 0.2,
          "delay": {
            "time": 0,
            "feedback": 0
          },
          "reverb": 0.15,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    }
  },
  "actions": {
    "build": {
      "title": "Peasant Build",
      "icon": "building_townHall",
      "actionSet": "peasant_buildings",
      "ability": "BuildAbility"
    },
    "hold": {
      "title": "Hold",
      "icon": "order_hold",
      "order": "holdPosition"
    },
    "mineGold": {
      "title": "Peasant Mine Gold",
      "icon": "building_goldMine",
      "ability": "MineGoldAbility"
    },
    "move": {
      "title": "Force Move",
      "icon": "order_move",
      "order": "moveOrderAction"
    }
  },
  "actionSets": {
    "defaultUnitActions": {
      "title": "Default Unit Actions",
      "actions": [
        "move",
        "hold"
      ]
    },
    "peasant_actions": {
      "title": "Peasant Actions",
      "actions": [
        "move",
        "hold",
        "build"
      ]
    },
    "peasant_buildings": {
      "title": "Peasant Buildings",
      "buildings": [
        "goldMine",
        "townHall",
        "cottage",
        "barracks",
        "fletchersHall",
        "mageTower",
        "sentryTower"
      ]
    }
  },
  "animations": {
    "1h_spell_throw": {
      "title": "1h_spell_throw",
      "file": "animations/1h_spell_throw.glb"
    },
    "1h_axe_swing": {
      "title": "1h_axe_swing",
      "file": "animations/1h_axe_swing.glb"
    },
    "2h_slash": {
      "title": "2h_slash",
      "file": "animations/2h_slash.glb"
    },
    "2h_spell_blast": {
      "title": "2h_spell_blast",
      "file": "animations/2h_spell_blast.glb"
    },
    "2h_spell_cast": {
      "title": "2h_spell_cast",
      "file": "animations/2h_spell_cast.glb"
    },
    "2h_spell_calldown": {
      "title": "2h_spell_calldown",
      "file": "animations/2h_spell_calldown.glb"
    },
    "2h_spell_slam": {
      "title": "2h_spell_slam",
      "file": "animations/2h_spell_slam.glb"
    },
    "dance_gangnamstyle": {
      "title": "GangnamStyle",
      "file": "animations/dance_gangnamstyle.glb"
    },
    "2h_spell_summon": {
      "title": "2h_spell_summon",
      "file": "animations/2h_spell_summon.glb"
    },
    "dance_thriller": {
      "title": "Dance Thriller",
      "file": "animations/dance_thriller.glb"
    },
    "death_delayed": {
      "title": "death_delayed",
      "file": "animations/death_delayed.glb"
    },
    "death_fallback": {
      "title": "death_fallback",
      "file": "animations/death_fallback.glb"
    },
    "death_fallforward": {
      "title": "death_fallforward",
      "file": "animations/death_fallforward.glb"
    },
    "death_flyback": {
      "title": "death_flyback",
      "file": "animations/death_flyback.glb"
    },
    "hovering": {
      "title": "hovering",
      "file": "animations/hovering.glb"
    },
    "idle": {
      "title": "idle",
      "file": "animations/idle.glb"
    },
    "mutant_idle": {
      "title": "mutant_idle",
      "file": "animations/mutant_idle.glb"
    },
    "mutant_run": {
      "title": "mutant_run",
      "file": "animations/mutant_run.glb"
    },
    "mutant_swipe": {
      "title": "mutant_swipe",
      "file": "animations/mutant_swipe.glb"
    },
    "mutant_walk": {
      "title": "mutant_walk",
      "file": "animations/mutant_walk.glb"
    },
    "shooting_arrow": {
      "title": "shooting_arrow",
      "file": "animations/shooting_arrow.glb"
    },
    "running_with_2h": {
      "title": "running_with_2h",
      "file": "animations/running_with_2h.glb"
    },
    "swimming": {
      "title": "swimming",
      "file": "animations/swimming.glb"
    },
    "sword_and_shield_cast": {
      "title": "sword_and_shield_cast",
      "file": "animations/sword_and_shield_cast.glb"
    },
    "sword_slash": {
      "title": "sword_slash",
      "file": "animations/sword_slash.glb"
    },
    "walk_bow": {
      "title": "walk_bow",
      "file": "animations/walk_bow.glb"
    },
    "walk_steady_right_hand": {
      "title": "walk_steady_right_hand",
      "file": "animations/walk_steady_right_hand.glb"
    },
    "walk_with_shield": {
      "title": "walk_with_shield",
      "file": "animations/walk_with_shield.glb"
    }
  },
  "effects": {
    "goldPerTrip": {
      "title": "Gold Per Trip",
      "desc": "Extra gold per trip.",
      "type": "upgrade",
      "value": 5
    },
    "slow": {
      "id": "slow",
      "title": "Slow",
      "desc": "Target is slowed",
      "stat": "speed",
      "lifeTime": 100
    },
    "weaken": {
      "id": "weaken",
      "title": "Weakened",
      "desc": "Target's armor is reduced",
      "stat": "armor",
      "lifeTime": 100
    },
    "spellDamage": {
      "title": "Spell Damage",
      "description": "",
      "type": "upgrade",
      "value": 10
    }
  },
  "models": {
    "position": {
      "title": "Position",
      "x": 0,
      "y": 0,
      "z": 0
    }
  },
  "modifierSets": {
    "global": {
      "maxBloodCoreHP": 100,
      "bloodShardMultiplier": 1,
      "towerCostMod": 1,
      "damageMultiplier": 1,
      "healingMultiplier": 1,
      "essenceMultiplier": 1,
      "towerDamageReduction": 1,
      "population": 0,
      "maxPopulation": 5
    }
  },
  "upgrades": {
    "peasantEfficiency": {
      "title": "Peasant Efficiency",
      "description": "Increase Gold Per Trip by 5",
      "value": 100,
      "effects": [
        "goldPerTrip"
      ]
    },
    "spellDamage": {
      "title": "Spell Damage",
      "description": "Increase Spell Damage",
      "value": 100,
      "effects": [
        "spellDamage"
      ]
    }
  },
  "cameras": {
    "main": {
      "title": "Main Orthographic",
      "near": 0.1,
      "far": 50000,
      "position": "{ \"x\": 64, \"y\": 512, \"z\": 512}",
      "lookAt": "{ \"x\": 64, \"y\": 16, \"z\": 64}",
      "zoom": 1
    },
    "main_perspective": {
      "title": "Main Perspective",
      "near": 0.1,
      "far": 4000,
      "position": "{ \"x\": 1000, \"y\": 750, \"z\": 1000}",
      "lookAt": "{ \"x\": 384, \"y\": 15, \"z\": 384 }",
      "fov": 75
    }
  },
  "fogs": {
    "sunnyDayFog": {
      "title": "Sunny Day Fog",
      "color": "#b3e5fc",
      "density": 0.00004,
      "enabled": false
    }
  },
  "heightMaps": {
    "fiveStep": {
      "title": "Five Step and Smoothing",
      "heightStep": 15,
      "smoothing": false,
      "enabled": true,
      "resolutionDivisor": 4
    }
  },
  "lightings": {
    "sunnyDayLighting": {
      "title": "Sunny Day Lighting",
      "ambientColor": "#b3e5fc",
      "ambientIntensity": 0.4,
      "directionalColor": "#ffcc80",
      "directionalIntensity": 0.7,
      "skyColor": "#b3e5fc",
      "groundColor": "#5a8a4f",
      "hemisphereIntensity": 0.5,
      "direction": "{\"x\":0,\"y\":-1,\"z\":-1}"
    }
  },
  "scenes": {
    "client": {
      "title": "client",
      "type": "ECS",
      "sceneData": [
        {
          "id": 1,
          "objectType": "gamePrefabs",
          "spawnType": "multiplayer",
          "parent": null,
          "children": [],
          "managers": [
            {
              "type": "ComponentManager"
            },
            {
              "type": "GameManager"
            },
            {
              "type": "GameModeManager"
            },
            {
              "type": "KeyboardManager"
            },
            {
              "type": "LoadingManager"
            },
            {
              "type": "ResultsManager"
            },
            {
              "type": "SaveManager"
            },
            {
              "type": "ScreenManager"
            },
            {
              "type": "UnitCreationManager"
            },
            {
              "type": "SquadManager"
            },
            {
              "type": "MultiplayerNetworkManager"
            },
            {
              "type": "InputManager"
            }
          ],
          "systems": [
            {
              "type": "TerrainSystem"
            },
            {
              "type": "WorldSystem"
            },
            {
              "type": "PostProcessingSystem"
            },
            {
              "type": "RenderSystem"
            },
            {
              "type": "AISystem"
            },
            {
              "type": "CommandQueueSystem"
            },
            {
              "type": "MovementSystem"
            },
            {
              "type": "CombatAISystem"
            },
            {
              "type": "ProjectileSystem"
            },
            {
              "type": "AnimationSystem"
            },
            {
              "type": "ArmyDisplaySystem"
            },
            {
              "type": "EffectsSystem"
            },
            {
              "type": "GridSystem"
            },
            {
              "type": "MultiplayerPlacementSystem"
            },
            {
              "type": "MultiplayerUISystem"
            },
            {
              "type": "ShopSystem"
            },
            {
              "type": "TeamHealthSystem"
            },
            {
              "type": "HealthBarSystem"
            },
            {
              "type": "UnitRadiusSystem"
            },
            {
              "type": "EquipmentSystem"
            },
            {
              "type": "DeathSystem"
            },
            {
              "type": "DamageSystem"
            },
            {
              "type": "AbilitySystem"
            },
            {
              "type": "ParticleSystem"
            },
            {
              "type": "SquadExperienceSystem"
            },
            {
              "type": "LifetimeSystem"
            },
            {
              "type": "MultiplayerUISystem"
            },
            {
              "type": "SchedulingSystem"
            },
            {
              "type": "GoldMineSystem"
            },
            {
              "type": "PathfindingSystem"
            },
            {
              "type": "FogOfWarSystem"
            },
            {
              "type": "SelectedUnitSystem"
            },
            {
              "type": "UnitOrderSystem"
            },
            {
              "type": "MiniMapSystem"
            },
            {
              "type": "CameraControlSystem"
            },
            {
              "type": "DamageNumberSystem"
            },
            {
              "type": "VisionSystem"
            },
            {
              "type": "SupplySystem"
            }
          ],
          "classes": [
            {
              "collection": "abilities",
              "baseClass": "BaseAbility"
            }
          ]
        }
      ]
    },
    "server": {
      "title": "server",
      "type": "ECS",
      "sceneData": [
        {
          "id": 1,
          "objectType": "gamePrefabs",
          "spawnType": "multiplayer",
          "managers": [
            {
              "type": "ComponentManager"
            },
            {
              "type": "GameManager"
            },
            {
              "type": "UnitCreationManager"
            },
            {
              "type": "SquadManager"
            }
          ],
          "systems": [
            {
              "type": "TerrainSystem"
            },
            {
              "type": "AISystem"
            },
            {
              "type": "CommandQueueSystem"
            },
            {
              "type": "MovementSystem"
            },
            {
              "type": "CombatAISystem"
            },
            {
              "type": "ProjectileSystem"
            },
            {
              "type": "TeamHealthSystem"
            },
            {
              "type": "DeathSystem"
            },
            {
              "type": "DamageSystem"
            },
            {
              "type": "AbilitySystem"
            },
            {
              "type": "SquadExperienceSystem"
            },
            {
              "type": "ServerBattlePhaseSystem"
            },
            {
              "type": "ServerPlacementSystem"
            },
            {
              "type": "LifetimeSystem"
            },
            {
              "type": "GridSystem"
            },
            {
              "type": "SchedulingSystem"
            },
            {
              "type": "PathfindingSystem"
            },
            {
              "type": "GoldMineSystem"
            },
            {
              "type": "VisionSystem"
            },
            {
              "type": "SupplySystem"
            }
          ],
          "classes": [
            {
              "collection": "abilities",
              "baseClass": "BaseAbility"
            }
          ]
        }
      ]
    }
  },
  "shadows": {
    "sunnyDayShadows": {
      "title": "Sunny Day Shadows",
      "mapSize": 2048,
      "bias": -0.0003,
      "normalBias": 0,
      "radius": 512,
      "enabled": true
    }
  },
  "worlds": {
    "shire": {
      "title": "Shire",
      "lighting": "sunnyDayLighting",
      "shadow": "sunnyDayShadows",
      "fog": "sunnyDayFog",
      "heightMap": "fiveStep",
      "camera": "main",
      "extensionSize": 768,
      "worldObjects": [
        "tree",
        "rock",
        "goldVein"
      ],
      "backgroundColor": "#b3e5fc"
    }
  },
  "buildings": {
    "sentryTower": {
      "title": "Sentry Tower",
      "info": "A structure that fires arrows.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/mage_tower/mage_tower.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "units": [],
      "footprintWidth": 2,
      "footprintHeight": 2,
      "height": 100,
      "size": 50,
      "icon": "unit_archer",
      "damage": 20,
      "attackSpeed": 1,
      "range": 300,
      "projectile": "arrow",
      "element": "physical",
      "hp": 500
    },
    "barracks": {
      "title": "Barracks",
      "info": "Strength based training.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "type": "gltf",
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "metalness": 0,
                    "roughness": 1,
                    "x": 0,
                    "z": 0,
                    "scaleX": 1,
                    "name": "foundation",
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/barracks/barracks.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "units": [
        "1_sd_soldier",
        "1_s_barbarian"
      ],
      "footprintWidth": 2,
      "footprintHeight": 3,
      "height": 100,
      "size": 75,
      "icon": "building_barracks",
      "hp": 1500,
      "supplies": 7
    },
    "castle": {
      "title": "Castle",
      "category": "townhall",
      "value": 100,
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "sphere",
                "width": 24,
                "height": 16,
                "depth": 24,
                "color": "#cfd8dc",
                "x": 0,
                "y": 32,
                "z": 0,
                "size": 24,
                "name": "dome",
                "scaleX": 1
              },
              {
                "type": "cylinder",
                "size": 12,
                "height": 22,
                "color": "#cfd8dc",
                "x": 0,
                "y": 42,
                "z": 0,
                "name": "spire"
              },
              {
                "type": "cone",
                "size": 14,
                "height": 20,
                "color": "#ab47bc",
                "x": 0,
                "y": 62,
                "z": 0,
                "name": "spire roof"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 0.7,
              "z": 1
            }
          },
          "base": {
            "shapes": [
              {
                "type": "box",
                "width": 40,
                "height": 12,
                "depth": 40,
                "color": "#3e4f57",
                "x": 0,
                "y": 6,
                "z": 0,
                "scaleX": 1,
                "name": "base"
              },
              {
                "type": "box",
                "width": 44,
                "height": 4,
                "depth": 44,
                "color": "#3e4f57",
                "x": 0,
                "y": 2,
                "z": 0,
                "name": "foundation"
              },
              {
                "type": "box",
                "width": 32,
                "height": 12,
                "depth": 32,
                "color": "#78909c",
                "x": 0,
                "y": 17,
                "z": 0,
                "name": "main structure"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          },
          "towers": {
            "shapes": [
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": 16,
                "y": 22,
                "z": 16,
                "name": "tower1"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": -16,
                "y": 22,
                "z": 16,
                "name": "tower2"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": 16,
                "y": 22,
                "z": -16,
                "name": "tower3"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": -16,
                "y": 22,
                "z": -16,
                "name": "tower4"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": 16,
                "y": 42,
                "z": 16,
                "name": "tower1roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": -16,
                "y": 42,
                "z": 16,
                "name": "tower2roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": 16,
                "y": 42,
                "z": -16,
                "name": "tower3roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": -16,
                "y": 42,
                "z": -16,
                "name": "tower4roof"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 0.7,
              "z": 1
            }
          }
        }
      },
      "size": 75
    },
    "cottage": {
      "title": "Cottage",
      "info": "A structure that fires arrows.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/cottage/cottage.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        }
      },
      "units": [],
      "footprintWidth": 1,
      "footprintHeight": 1,
      "height": 100,
      "size": 50,
      "icon": "building_cottage",
      "hp": 500,
      "supplyProvided": 8
    },
    "fletchersHall": {
      "title": "Fletchers Hall",
      "info": "Dexterity based training.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/fletchers_hall/fletchers_hall.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "units": [
        "1_di_scout",
        "1_d_archer"
      ],
      "footprintWidth": 2,
      "footprintHeight": 2,
      "height": 100,
      "size": 50,
      "icon": "building_fletchersHall",
      "hp": 1500
    },
    "goldMine": {
      "title": "Gold Mine",
      "info": "Mine gold veins",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/goldmine/goldmine.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1.5,
              "y": 1.5,
              "z": 1.5
            }
          }
        }
      },
      "upgrades": [
        "peasantEfficiency"
      ],
      "units": [],
      "footprintWidth": 2,
      "footprintHeight": 2,
      "size": 50,
      "icon": "building_goldMine",
      "hp": 2000,
      "height": 100
    },
    "keep": {
      "title": "Keep",
      "category": "townhall",
      "value": 100,
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "sphere",
                "width": 24,
                "height": 16,
                "depth": 24,
                "color": "#cfd8dc",
                "x": 0,
                "y": 32,
                "z": 0,
                "size": 24,
                "name": "dome",
                "scaleX": 1
              },
              {
                "type": "cylinder",
                "size": 12,
                "height": 22,
                "color": "#cfd8dc",
                "x": 0,
                "y": 42,
                "z": 0,
                "name": "spire"
              },
              {
                "type": "cone",
                "size": 14,
                "height": 20,
                "color": "#ab47bc",
                "x": 0,
                "y": 62,
                "z": 0,
                "name": "spire roof"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 0.7,
              "z": 1
            }
          },
          "base": {
            "shapes": [
              {
                "type": "box",
                "width": 40,
                "height": 12,
                "depth": 40,
                "color": "#3e4f57",
                "x": 0,
                "y": 6,
                "z": 0,
                "scaleX": 1,
                "name": "base"
              },
              {
                "type": "box",
                "width": 44,
                "height": 4,
                "depth": 44,
                "color": "#3e4f57",
                "x": 0,
                "y": 2,
                "z": 0,
                "name": "foundation"
              },
              {
                "type": "box",
                "width": 32,
                "height": 12,
                "depth": 32,
                "color": "#78909c",
                "x": 0,
                "y": 17,
                "z": 0,
                "name": "main structure"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          },
          "towers": {
            "shapes": [
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": 16,
                "y": 22,
                "z": 16,
                "name": "tower1"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": -16,
                "y": 22,
                "z": 16,
                "name": "tower2"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": 16,
                "y": 22,
                "z": -16,
                "name": "tower3"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": -16,
                "y": 22,
                "z": -16,
                "name": "tower4"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": 16,
                "y": 42,
                "z": 16,
                "name": "tower1roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": -16,
                "y": 42,
                "z": 16,
                "name": "tower2roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": 16,
                "y": 42,
                "z": -16,
                "name": "tower3roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": -16,
                "y": 42,
                "z": -16,
                "name": "tower4roof"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 0.7,
              "z": 1
            }
          }
        }
      },
      "size": 75
    },
    "mageTower": {
      "title": "Mage Tower",
      "info": "Intelligence based training.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/mage_tower/mage_tower.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "upgrades": [
        "spellDamage"
      ],
      "units": [
        "1_is_acolyte",
        "1_i_apprentice"
      ],
      "footprintWidth": 2,
      "footprintHeight": 2,
      "height": 100,
      "anchored": true,
      "size": 50,
      "icon": "building_mageTower",
      "hp": 1500
    },
    "townHall": {
      "title": "Town Hall",
      "category": "townhall",
      "value": 100,
      "upgrades": [
        "peasantEfficiency"
      ],
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "purpleMColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "purpleMColor"
                },
                "roughness": 1,
                "metalness": 0,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/townhall/townhall.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "footprintWidth": 3,
      "footprintHeight": 3,
      "units": [
        "peasant"
      ],
      "height": 1000,
      "size": 75,
      "icon": "building_townHall",
      "hp": 2500,
      "visionRange": 2000,
      "supplyProvided": 10
    },
    "underConstruction": {
      "title": "Under Construction",
      "info": "Under Construction",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/underConstruction/underConstruction.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "units": [],
      "footprintWidth": 3,
      "footprintHeight": 2,
      "height": 100,
      "size": 75,
      "hp": 1000
    }
  },
  "cliffs": {
    "atom_four": {
      "title": "Atom Four",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "greyMColor"
                },
                "metalness": 0,
                "roughness": 1,
                "name": "main",
                "url": "models/atom_four/atom_four.glb",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.375,
              "z": 0.375
            }
          }
        }
      }
    },
    "atom_three": {
      "title": "Atom Three",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "greyMColor"
                },
                "metalness": 0,
                "roughness": 1,
                "name": "main",
                "url": "models/atom_three_grass/atom_three_grass.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.375,
              "y": 1.01,
              "z": 0.375
            }
          }
        }
      }
    },
    "atom_one": {
      "title": "Atom One",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "greyMColor"
                },
                "metalness": 0,
                "roughness": 1,
                "name": "main",
                "url": "models/atom_one_grass/atom_one_grass.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.375,
              "y": 1.01,
              "z": 0.375
            }
          }
        }
      }
    },
    "atom_two": {
      "title": "Atom Two",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "greyMColor"
                },
                "metalness": 0,
                "roughness": 1,
                "name": "main",
                "url": "models/atom_two_grass/atom_two_grass.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.375,
              "z": 0.375,
              "y": 1.01
            }
          }
        }
      }
    }
  },
  "gamePrefabs": {
    "main": {
      "title": "main",
      "entity": "ECSGame",
      "palette": "main",
      "mapRenderer": "level1",
      "mapManager": "level1",
      "threeJsWorld": "level1"
    }
  },
  "items": {
    "axe1h": {
      "title": "Axe 1H",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_axe_1h/item_axe_1h.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "knightShield": {
      "title": "Knight Shield",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_shield_knight/item_shield_knight.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "knightSword": {
      "title": "Knight Sword",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_sword_knight/item_sword_knight.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "shieldLeaf": {
      "title": "Leaf Shield",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_shield_leaf/item_shield_leaf.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "shieldSnowflake": {
      "title": "Snowflake Shield",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_shield_snowflake/item_shield_snowflake.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "staff_feathers": {
      "title": "Feathered Staff",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_staff_feathers/item_staff_feathers.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "woodBow": {
      "title": "Wood Bow",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1,
              "z": 0
            },
            "rotation": {
              "x": -4.40619762898109e-16,
              "z": -0.008513801229241034
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_bow_peasant/item_bow_peasant.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "position": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "scale": {
                  "x": 2,
                  "y": 2,
                  "z": 5
                }
              }
            ]
          }
        }
      }
    },
    "woodStaff": {
      "title": "Wood Staff",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_staff_wood/item_staff_wood.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "position": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "scale": {
                  "x": 0.99,
                  "y": 0.99,
                  "z": 0.99
                }
              }
            ]
          }
        }
      }
    }
  },
  "particles": {
    "smoke": {
      "title": "Smoke",
      "render": {
        "animations": {
          "idle": [
            {
              "shapes": {
                "shapes": [
                  {
                    "type": "sphere",
                    "size": 1,
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "id": 0
                  }
                ]
              }
            },
            {
              "shapes": {
                "shapes": [
                  {
                    "type": "sphere",
                    "size": 1,
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "id": 0
                  }
                ],
                "scale": {
                  "x": 2,
                  "y": 2,
                  "z": 2
                }
              }
            },
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "id": 0
                  }
                ],
                "scale": {
                  "x": 4,
                  "y": 4,
                  "z": 4
                }
              }
            },
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "id": 0
                  }
                ],
                "scale": {
                  "x": 8,
                  "y": 8,
                  "z": 8
                }
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "sphere",
                "size": 1,
                "color": "#000000",
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      },
      "lifeSpan": 0.66
    }
  },
  "projectiles": {
    "bolt": {
      "damageType": "physical",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/projectile_arrow/projectile_arrow.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "z": 0.25,
              "y": 0.25,
              "x": 0.25
            }
          }
        }
      },
      "speed": 1000,
      "title": "Bolt",
      "attackSound": "plasma",
      "hitSound": "plasma",
      "homing": false,
      "homingStrength": 0
    },
    "arrow": {
      "damageType": "physical",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/projectile_arrow/projectile_arrow.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "y": 0.5,
              "x": 0.5,
              "z": 0.5
            }
          }
        }
      },
      "speed": 1000,
      "title": "Arrow",
      "attackSound": "plasma",
      "hitSound": "plasma",
      "homing": false,
      "homingStrength": 0
    },
    "boulder": {
      "damageType": "fire",
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "name": "ball",
                    "type": "sphere",
                    "size": 12,
                    "x": 0,
                    "z": 0,
                    "rotationX": 90,
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "rotationY": 0,
                    "rotationZ": 0,
                    "scaleX": 1,
                    "scaleY": 1,
                    "scaleZ": 1,
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "name": "ball",
                "type": "sphere",
                "size": 12,
                "x": 0,
                "z": 0,
                "rotationX": 90,
                "color": {
                  "paletteColor": "greyDColor"
                },
                "rotationY": 0,
                "rotationZ": 0,
                "scaleX": 1,
                "scaleY": 1,
                "scaleZ": 1
              }
            ],
            "position": {
              "x": -3.00653594771243,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      },
      "speed": 100,
      "title": "Boulder",
      "ballistic": true,
      "homing": false,
      "homingStrength": 0,
      "particle": "smoke",
      "shadows": false,
      "hitSound": "explosion",
      "attackSound": "missileLaunch"
    },
    "elvenArrow": {
      "damageType": "physical",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/projectile_arrow/projectile_arrow.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "z": 0.25,
              "y": 0.25,
              "x": 0.25
            }
          }
        }
      },
      "speed": 1000,
      "title": "Elven Arrow",
      "attackSound": "plasma",
      "hitSound": "plasma",
      "homing": true,
      "homingStrength": 0.5
    },
    "fireball": {
      "damageType": "fire",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "name": "ball",
                "type": "sphere",
                "x": 0,
                "y": 0,
                "z": 0,
                "size": 0.2,
                "color": {
                  "paletteColor": "redDColor"
                },
                "rotationY": 0,
                "rotationZ": 0,
                "scaleX": 1,
                "scaleY": 1,
                "scaleZ": 1
              }
            ],
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      },
      "speed": 300,
      "title": "Fireball",
      "ballistic": false,
      "homing": false,
      "homingStrength": 0,
      "particle": "smoke",
      "shadows": false,
      "hitSound": "explosion",
      "attackSound": "missileLaunch"
    },
    "huntingArrow": {
      "damageType": "physical",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/projectile_arrow/projectile_arrow.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "z": 0.25,
              "y": 0.25,
              "x": 0.25
            }
          }
        }
      },
      "speed": 1000,
      "title": "Hunting Arrow",
      "attackSound": "plasma",
      "hitSound": "plasma",
      "homing": true,
      "homingStrength": 0.3
    },
    "lightning": {
      "customRenderer": "",
      "damageType": "electric",
      "speed": 5,
      "title": "Lightning"
    }
  },
  "units": {
    "0_golemFire": {
      "title": "Fire Golem",
      "size": 25,
      "height": 100,
      "value": 480,
      "hp": 2500,
      "speed": 15,
      "damage": 40,
      "attackSpeed": 0.7,
      "element": "fire",
      "armor": 8,
      "fireResistance": 1,
      "coldResistance": -0.25,
      "lightningResistance": 0.1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_walk.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_swipe.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/golem_fire/golem_fire.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "BurningAuraAbility"
      ]
    },
    "0_golemIce": {
      "title": "Ice Golem",
      "size": 25,
      "height": 100,
      "value": 480,
      "hp": 2500,
      "speed": 15,
      "damage": 40,
      "attackSpeed": 0.7,
      "element": "cold",
      "armor": 8,
      "coldResistance": 1,
      "lightningResistance": 0.1,
      "fireResistance": -0.25,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_walk.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_swipe.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/golem_ice/golem_ice.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "FreezingAuraAbility"
      ]
    },
    "0_golemStone": {
      "title": "Stone Golem",
      "size": 25,
      "height": 100,
      "value": 480,
      "hp": 2500,
      "speed": 15,
      "damage": 150,
      "attackSpeed": 0.7,
      "element": "physical",
      "armor": 12,
      "fireResistance": 0.1,
      "coldResistance": 0.1,
      "lightningResistance": 0.1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_walk.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_swipe.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/golem/golem.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": true,
      "squadWidth": 1,
      "squadHeight": 1,
      "specUnits": [
        "0_golemIce",
        "0_golemFire"
      ],
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "icon": "unit_stoneGolem"
    },
    "0_skeleton": {
      "title": "Skeleton",
      "size": 25,
      "height": 50,
      "value": -1,
      "hp": 50,
      "speed": 65,
      "damage": 10,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 5,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/skeleton/skeleton.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": -8,
                "y": -5,
                "z": 3
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "1_di_scout": {
      "title": "Rogue",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 150,
      "speed": 60,
      "damage": 40,
      "attackSpeed": 1.2,
      "range": 100,
      "projectile": "arrow",
      "element": "physical",
      "armor": 0,
      "fireResistance": 0.25,
      "coldResistance": 0.25,
      "lightningResistance": 0.25,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/shooting_arrow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/rogue/rogue.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 3,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 90
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_di_shadowAssassin",
        "2_di_trickster",
        "2_di_goblinBomber"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "icon": "unit_rogue",
      "visionRange": 800,
      "supplyCost": 2
    },
    "1_is_acolyte": {
      "title": "Acolyte",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 150,
      "speed": 45,
      "damage": 10,
      "attackSpeed": 0.9,
      "element": "divine",
      "armor": 6,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/acolyte/acolyte.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 5,
                "y": 0,
                "z": -2
              },
              "rotation": {
                "x": 15,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_is_paladin",
        "2_is_crusader",
        "2_is_oathBreaker"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "HealAbility"
      ],
      "icon": "unit_acolyte",
      "visionRange": 500,
      "supplyCost": 2
    },
    "1_d_archer": {
      "title": "Archer",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 150,
      "speed": 55,
      "damage": 16,
      "attackSpeed": 1.1,
      "range": 200,
      "projectile": "arrow",
      "element": "physical",
      "fireResistance": 0.5,
      "coldResistance": 0.5,
      "lightningResistance": 0.5,
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/shooting_arrow.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/scout/scout.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 90
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_d_beastMaster",
        "2_d_ranger",
        "2_d_trapper"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [],
      "icon": "unit_archer",
      "visionRange": 650,
      "supplyCost": 2
    },
    "1_i_apprentice": {
      "title": "Apprentice",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 150,
      "speed": 55,
      "damage": 15,
      "attackSpeed": 1.1,
      "range": 150,
      "element": "fire",
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/1h_spell_throw/1h_spell_throw.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/apprentice/apprentice.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "woodStaff",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 20,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "projectile": "fireball",
      "specUnits": [
        "2_i_elementalist",
        "2_i_enchanter",
        "2_i_necromancer"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [],
      "icon": "unit_apprentice",
      "visionRange": 500,
      "supplyCost": 2
    },
    "1_sd_soldier": {
      "title": "Soldier",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 300,
      "speed": 45,
      "damage": 12,
      "attackSpeed": 0.8,
      "element": "physical",
      "armor": 4,
      "fireResistance": 0.25,
      "coldResistance": 0.25,
      "lightningResistance": 0.25,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/warrior/warrior.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 15,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_sd_knight",
        "2_sd_hoplite",
        "2_sd_crossbowman"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "WindShieldAbility"
      ],
      "icon": "unit_soldier",
      "visionRange": 500,
      "supplyCost": 2
    },
    "2_di_shadowAssassin": {
      "title": "Shadow Assassin (2) [DI]",
      "size": 25,
      "height": 50,
      "value": 320,
      "hp": 500,
      "speed": 80,
      "damage": 28,
      "attackSpeed": 2,
      "element": "physical",
      "armor": 4,
      "fireResistance": 0.1,
      "coldResistance": 0.2,
      "lightningResistance": 0.15,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/walk_bow.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/sword_slash.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/assassin/assassin.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 20,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": -20,
                "z": -910
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "ShadowStrikeAbility"
      ]
    },
    "2_di_trickster": {
      "title": "Trickster (2) [DI]",
      "size": 25,
      "height": 50,
      "value": 320,
      "hp": 350,
      "speed": 80,
      "damage": 28,
      "attackSpeed": 2,
      "element": "poison",
      "armor": 4,
      "fireResistance": 0.1,
      "coldResistance": 0.2,
      "lightningResistance": 0.15,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/walk_bow.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/sword_slash.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/trickster/trickster.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 20,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": -20,
                "z": -910
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "MirrorImagesAbility"
      ]
    },
    "2_d_beastMaster": {
      "title": "Beast Master (2) [D]",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 140,
      "speed": 55,
      "damage": 16,
      "attackSpeed": 1.1,
      "range": 200,
      "projectile": "arrow",
      "element": "physical",
      "fireResistance": 0.5,
      "coldResistance": 0.5,
      "lightningResistance": 0.5,
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/idle/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/shooting_arrow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "cast": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/2h_spell_summon/2h_spell_summon.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/beastmaster/beastmaster.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 90
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "SummonWolfAbility"
      ]
    },
    "2_d_ranger": {
      "title": "Ranger (2) [D]",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 140,
      "speed": 55,
      "damage": 16,
      "attackSpeed": 1.1,
      "range": 400,
      "projectile": "arrow",
      "element": "physical",
      "fireResistance": 0.5,
      "coldResistance": 0.5,
      "lightningResistance": 0.5,
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/shooting_arrow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/ranger/ranger.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": []
    },
    "2_d_trapper": {
      "title": "Trapper (2) [D]",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 140,
      "speed": 55,
      "damage": 16,
      "attackSpeed": 1.1,
      "range": 200,
      "projectile": "arrow",
      "element": "physical",
      "fireResistance": 0.5,
      "coldResistance": 0.5,
      "lightningResistance": 0.5,
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/shooting_arrow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/ranger/ranger.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "ExplosiveTrapAbility"
      ]
    },
    "2_is_crusader": {
      "title": "Templar (2) [IS]",
      "size": 25,
      "height": 50,
      "value": 110,
      "hp": 200,
      "speed": 35,
      "damage": 14,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 6,
      "fireResistance": 0.2,
      "coldResistance": 0.2,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/templar/templar.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": -1,
                "y": 10,
                "z": 2
              },
              "rotation": {
                "x": 0,
                "y": 8,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 5,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 10,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "HealAbility"
      ]
    },
    "2_is_oathBreaker": {
      "title": "Oathbreaker (2) [IS]",
      "size": 25,
      "height": 50,
      "value": 110,
      "hp": 200,
      "speed": 35,
      "damage": 14,
      "attackSpeed": 1,
      "element": "poison",
      "armor": 6,
      "fireResistance": 0.2,
      "coldResistance": 0.2,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/oathbreaker/oathbreaker.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 15,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 8,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": -10
              },
              "rotation": {
                "x": 15,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "CurseAbility"
      ]
    },
    "2_is_paladin": {
      "title": "Paladin (2) [IS]",
      "size": 25,
      "height": 50,
      "value": 110,
      "hp": 200,
      "speed": 35,
      "damage": 14,
      "attackSpeed": 1,
      "element": "divine",
      "armor": 6,
      "fireResistance": 0.2,
      "coldResistance": 0.2,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/paladin/paladin.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 8,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 20,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "SmiteAbility"
      ]
    },
    "2_i_enchanter": {
      "title": "Enchanter (2) [I]",
      "size": 25,
      "height": 50,
      "value": 140,
      "hp": 150,
      "speed": 55,
      "damage": 0,
      "attackSpeed": 0,
      "range": 160,
      "armor": 2,
      "fireResistance": 0.4,
      "coldResistance": 0,
      "lightningResistance": 0.2,
      "abilities": [
        "MindControlAbility"
      ],
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/2h_spell_summon.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/evil_sorcerer/evil_sorcerer.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "staff_feathers",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 5,
                "z": -8
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "2_i_elementalist": {
      "title": "Elementalist (2) [I]",
      "size": 25,
      "height": 50,
      "value": 140,
      "hp": 150,
      "speed": 55,
      "damage": 0,
      "attackSpeed": 0,
      "range": 160,
      "armor": 2,
      "fireResistance": 0.4,
      "coldResistance": 0,
      "lightningResistance": 0.2,
      "abilities": [
        "ChainLightningAbility"
      ],
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/2h_spell_summon.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/archmage/archmage.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "staff_feathers",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": -10,
                "y": 15,
                "z": 0
              },
              "rotation": {
                "x": 180,
                "y": 0,
                "z": 180
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "2_i_necromancer": {
      "title": "Necromancer (2) [I]",
      "size": 25,
      "height": 50,
      "value": 250,
      "hp": 180,
      "speed": 35,
      "damage": 12,
      "attackSpeed": 1,
      "element": "poison",
      "armor": 3,
      "fireResistance": 0.1,
      "coldResistance": 0.3,
      "lightningResistance": 0.2,
      "range": 100,
      "projectile": "fireball",
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/2h_spell_summon.glb",
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/necromancer/necromancer.glb",
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 20,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "woodStaff",
            "attachmentData": {
              "bone": "",
              "offset": {
                "x": 0,
                "y": 10,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 160,
                "z": 0
              }
            }
          }
        ]
      },
      "abilities": [
        "RaiseDeadAbility"
      ],
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "2_sd_crossbowman": {
      "title": "Crossbowman (2) [SD]",
      "size": 25,
      "height": 50,
      "value": 380,
      "hp": 450,
      "speed": 40,
      "damage": 32,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 12,
      "fireResistance": 0.6,
      "coldResistance": 0.1,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/shooting_arrow/shooting_arrow.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/hoplite/hoplite.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": -5,
                "y": 5,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": -20
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "range": 200,
      "projectile": "bolt"
    },
    "2_sd_hoplite": {
      "title": "Hoplite (2) [SD]",
      "size": 25,
      "height": 50,
      "value": 380,
      "hp": 450,
      "speed": 40,
      "damage": 32,
      "attackSpeed": 1,
      "element": "fire",
      "armor": 12,
      "fireResistance": 0.6,
      "coldResistance": 0.1,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/hoplite/hoplite.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": -10
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "",
              "offset": {
                "x": 0,
                "y": 0,
                "z": -20
              },
              "rotation": {
                "x": 10,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "PhalanxFormationAbility"
      ]
    },
    "2_sd_knight": {
      "title": "Knight (2) [SD]",
      "size": 35,
      "height": 50,
      "value": 110,
      "hp": 240,
      "speed": 25,
      "damage": 20,
      "attackSpeed": 0.9,
      "element": "physical",
      "armor": 8,
      "fireResistance": 0.15,
      "coldResistance": 0.15,
      "lightningResistance": 0.1,
      "poisonResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "url": "models/knight/knight.glb",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "z": 1,
              "y": 1,
              "x": 1
            }
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 6,
                "y": 16,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": -6
              },
              "rotation": {
                "x": 10,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "ChargeAbility"
      ]
    },
    "2_s_berserker": {
      "title": "Berserker (2) [S]",
      "size": 25,
      "height": 50,
      "value": 160,
      "hp": 180,
      "speed": 55,
      "damage": 24,
      "attackSpeed": 1.5,
      "element": "physical",
      "armor": 3,
      "fireResistance": 0.1,
      "coldResistance": 0.2,
      "lightningResistance": 0.05,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/1h_axe_swing.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/berserker/berserker.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "position": {
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "scale": {
                  "x": 1,
                  "y": 1,
                  "z": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "axe1h",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 5,
                "z": 5
              },
              "rotation": {
                "x": 15,
                "y": 0,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "axe1h",
            "attachmentData": {
              "bone": "",
              "offset": {
                "x": 0,
                "y": 5,
                "z": 5
              },
              "rotation": {
                "x": 180,
                "y": 0,
                "z": 180
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": []
    },
    "2_s_gladiator": {
      "title": "Gladiator (2) [S]",
      "size": 25,
      "height": 50,
      "value": 50,
      "hp": 150,
      "speed": 35,
      "damage": 12,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 4,
      "fireResistance": 0.05,
      "coldResistance": 0.05,
      "lightningResistance": 0.05,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/gladiator/gladiator.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 2,
                "y": 5,
                "z": 2
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 10
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "ArenaPresenceAbility"
      ]
    },
    "2_s_warlord": {
      "title": "Warlord (2) [S]",
      "size": 35,
      "height": 50,
      "value": 110,
      "hp": 240,
      "speed": 25,
      "damage": 20,
      "attackSpeed": 0.9,
      "element": "physical",
      "armor": 8,
      "fireResistance": 0.15,
      "coldResistance": 0.15,
      "lightningResistance": 0.1,
      "poisonResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "metalness": "0",
                "roughness": "1",
                "color": "#FFFFFF",
                "url": "models/berserker/berserker.glb"
              }
            ],
            "scale": {
              "z": 1,
              "y": 1,
              "x": 1
            }
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 6,
                "y": 16,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": -6
              },
              "rotation": {
                "x": 10,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "BattleCryAbility"
      ]
    },
    "4_ancientTreant": {
      "title": "Ancient Treant",
      "size": 25,
      "height": 100,
      "value": 480,
      "hp": 720,
      "speed": 15,
      "damage": 40,
      "attackSpeed": 0.7,
      "element": "physical",
      "armor": 12,
      "fireResistance": -0.2,
      "coldResistance": 0.3,
      "lightningResistance": 0.1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_walk.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_swipe.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/treant/treant.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "4_archmage": {
      "title": "Archmage",
      "size": 25,
      "height": 50,
      "value": 420,
      "hp": 200,
      "speed": 30,
      "damage": 30,
      "attackSpeed": 0.7,
      "range": 200,
      "projectile": "fireball",
      "element": "fire",
      "armor": 4,
      "fireResistance": 0.5,
      "coldResistance": 0.2,
      "lightningResistance": 0.3,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/1h_spell_throw.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/archmage/archmage.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodStaff",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 15,
                "z": 2
              },
              "rotation": {
                "x": 0,
                "y": 180,
                "z": 0
              }
            }
          }
        ]
      },
      "abilities": [
        "ChainLightningAbility"
      ],
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "peasant": {
      "title": "Peasant",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 60,
      "speed": 40,
      "damage": 6,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 8,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/sword_slash/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/peasant/peasant.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "axe1h",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "MineGoldAbility",
        "BuildAbility"
      ],
      "icon": "unit_peasant",
      "actionSet": "peasant_actions",
      "visionRange": 400,
      "supplyCost": 1
    },
    "sentry": {
      "title": "Sentry Tower",
      "info": "Defensive sentry tower",
      "value": 250,
      "range": 4,
      "damage": 10,
      "attackSpeed": 0.5,
      "projectile": "arrow",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "cylinder",
                "size": 20,
                "height": 4,
                "color": "#78909c",
                "x": 0,
                "y": 2,
                "z": 0,
                "name": "base",
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "scaleX": 1,
                "scaleY": 1,
                "scaleZ": 1
              },
              {
                "type": "cylinder",
                "size": 14,
                "height": 26,
                "color": "#78909c",
                "x": 0,
                "y": 17,
                "z": 0,
                "name": "body"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          },
          "rampart": {
            "shapes": [
              {
                "type": "cylinder",
                "size": 12,
                "height": 8,
                "color": "#3e4f57",
                "x": 0,
                "y": 30,
                "z": 0,
                "name": "rampartbase"
              },
              {
                "type": "box",
                "width": 3,
                "height": 5,
                "depth": 3,
                "color": "#3e4f57",
                "x": 4,
                "y": 34,
                "z": 4,
                "name": "rampartblock1"
              },
              {
                "type": "box",
                "width": 3,
                "height": 5,
                "depth": 3,
                "color": "#3e4f57",
                "x": -4,
                "y": 34,
                "z": 4,
                "name": "rampartblock2"
              },
              {
                "type": "box",
                "width": 3,
                "height": 5,
                "depth": 3,
                "color": "#3e4f57",
                "x": 4,
                "y": 34,
                "z": -4,
                "name": "rampartblock3"
              },
              {
                "type": "box",
                "width": 3,
                "height": 5,
                "depth": 3,
                "color": "#3e4f57",
                "x": -4,
                "y": 34,
                "z": -4,
                "name": "rampartblock4"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1.5,
              "y": 1,
              "z": 1.5
            }
          },
          "attacker": {
            "shapes": [],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      }
    },
    "1_s_barbarian": {
      "title": "Barbarian",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 300,
      "speed": 40,
      "damage": 10,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 8,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/sword_slash/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/barbarian/barbarian.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 5,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_s_berserker",
        "2_s_gladiator",
        "2_s_warlord"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [],
      "range": 5,
      "projectile": "arrow",
      "icon": "unit_barbarian",
      "visionRange": 500,
      "supplyCost": 2
    },
    "2_di_goblinBomber": {
      "title": "Goblin Bomber (2) [DI]",
      "size": 25,
      "height": 50,
      "value": 120,
      "hp": 450,
      "speed": 60,
      "damage": 40,
      "attackSpeed": 1.2,
      "element": "fire",
      "armor": 1,
      "fireResistance": 0.75,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.5,
              "y": 0.5,
              "z": 0.5
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/goblin/goblin.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "MeteorStrikeAbility"
      ],
      "range": 100,
      "projectile": "fireball"
    }
  },
  "visuals": {
    "meteor_warning": {
      "title": "Meteor Warning",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "sphere",
                "x": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "size": 20,
                "scale": {
                  "y": 0.1
                },
                "position": {
                  "y": 10
                },
                "color": {
                  "paletteColor": "redDColor"
                }
              }
            ]
          }
        }
      }
    }
  },
  "worldObjects": {
    "rock": {
      "title": "Rock",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "tetrahedron",
                "size": 16,
                "color": {
                  "paletteColor": "greyDColor"
                },
                "x": 3.5,
                "y": 2,
                "z": 2.5,
                "rotationX": 50,
                "rotationY": 140,
                "rotationZ": 10,
                "scaleX": 1
              },
              {
                "type": "tetrahedron",
                "size": 12,
                "color": {
                  "paletteColor": "greyDColor"
                },
                "x": 10.5,
                "y": 2,
                "z": 7.5,
                "rotationX": 50,
                "rotationY": 150,
                "rotationZ": 10
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      }
    },
    "goldVein": {
      "title": "Gold Vein",
      "render": {
        "animations": {
          "idle": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "greenDColor"
                    },
                    "id": 1
                  },
                  {
                    "color": {
                      "paletteColor": "greenDColor"
                    },
                    "id": 2
                  },
                  {
                    "color": {
                      "paletteColor": "greenDColor"
                    },
                    "id": 3
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "size": 2,
                "color": "#ff0000",
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "url": "models/goldvein/goldvein.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        }
      },
      "placementGridWidth": 2,
      "placementGridHeight": 2,
      "snapToGrid": true,
      "height": 100
    },
    "tree": {
      "title": "Tree",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "metalness": 0,
                "roughness": 1,
                "url": "models/new_fir/new_fir.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      },
      "height": 75,
      "size": 25,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    }
  },
  "icons": {
    "building_goldMine": {
      "title": "Building Gold Mine",
      "filePath": "resources/images/icons/building_goldMine.png"
    },
    "building_barracks": {
      "title": "Building Barracks",
      "filePath": "resources/images/icons/building_barracks.png"
    },
    "building_cottage": {
      "title": "Building Cottage",
      "filePath": "resources/images/icons/building_cottage.png"
    },
    "building_fletchersHall": {
      "title": "Building Fletchers Hall",
      "filePath": "resources/images/icons/building_fletchersHall.png"
    },
    "building_mageTower": {
      "title": "Building Mage Tower",
      "filePath": "resources/images/icons/building_mageTower.png"
    },
    "building_townHall": {
      "title": "Building Town Hall",
      "filePath": "resources/images/icons/building_townHall.png"
    },
    "order_hold": {
      "title": "Order Hold",
      "filePath": "resources/images/icons/order_hold.png"
    },
    "order_move": {
      "title": "Order Move",
      "filePath": "resources/images/icons/order_move.png"
    },
    "unit_acolyte": {
      "title": "Unit Acolyte",
      "filePath": "resources/images/icons/unit_acolyte.png"
    },
    "unit_apprentice": {
      "title": "Unit Apprentice",
      "filePath": "resources/images/icons/unit_apprentice.png"
    },
    "unit_archer": {
      "title": "Unit Archer",
      "filePath": "resources/images/icons/unit_archer.png"
    },
    "unit_barbarian": {
      "title": "Unit Barbarian",
      "filePath": "resources/images/icons/unit_barbarian.png"
    },
    "unit_peasant": {
      "title": "Unit Peasant",
      "filePath": "resources/images/icons/unit_peasant.png"
    },
    "unit_rogue": {
      "title": "Unit Rogue",
      "filePath": "resources/images/icons/unit_rogue.png"
    },
    "unit_soldier": {
      "title": "Unit Soldier",
      "filePath": "resources/images/icons/unit_soldier.png"
    },
    "unit_stoneGolem": {
      "title": "Unit Stone Golem",
      "filePath": "resources/images/icons/unit_stoneGolem.png"
    }
  },
  "materials": {
    "greenL": {
      "title": "Green Light",
      "color": "#a3d39c"
    }
  },
  "palettes": {
    "main": {
      "title": "Main",
      "greenLColor": "#a3d39c",
      "greenMColor": "#5a8a4f",
      "greenDColor": "#2f4a29",
      "brownLColor": "#d9b38c",
      "brownMColor": "#8b5e3c",
      "brownDColor": "#4a2f1f",
      "blueLColor": "#b3e5fc",
      "blueMColor": "#4fc3f7",
      "blueDColor": "#0288d1",
      "redLColor": "#ffcc80",
      "redMColor": "#ff8c00",
      "redDColor": "#bf360c",
      "purpleLColor": "#e1bee7",
      "purpleMColor": "#ab47bc",
      "purpleDColor": "#6a1b9a",
      "greyLColor": "#cfd8dc",
      "greyMColor": "#78909c",
      "greyDColor": "#3e4f57"
    }
  },
  "shaders": {
    "grass": {
      "title": "Grass",
      "fragmentScript": "varying vec2 vUv;\nuniform sampler2D map;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform vec3 directionalLightColor; // DirectionalLight color\nuniform float directionalLightIntensity; // DirectionalLight intensity\nuniform vec3 directionalLightDirection; // DirectionalLight direction (world space)\nuniform vec3 ambientLightColor; // AmbientLight color\nuniform float ambientLightIntensity; // AmbientLight intensity\nuniform vec3 skyColor; // HemisphereLight sky color\nuniform vec3 groundColor; // HemisphereLight ground color\nuniform float hemisphereIntensity; // HemisphereLight intensity\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n    vec4 texColor = texture2D(map, vUv);\n    vec3 color = texColor.rgb;\n\n    // Directional light (Lambertian diffuse)\n    vec3 lightDir = normalize(directionalLightDirection); // Ensure direction is normalized\n    float diff = max(dot(vNormal, lightDir), 0.0);\n    vec3 diffuse = directionalLightColor * directionalLightIntensity * diff * color;\n\n    // Ambient light\n    vec3 ambient = ambientLightColor * ambientLightIntensity * color;\n\n    // Hemisphere light\n    vec3 hemiDir = vec3(0.0, 1.0, 0.0); // Up direction for hemisphere\n    float hemiDot = dot(vNormal, hemiDir) * 0.5 + 0.5; // Remap to 0-1\n    vec3 hemi = mix(groundColor, skyColor, hemiDot) * hemisphereIntensity * color;\n\n    // Combine lighting contributions\n    vec3 litColor = diffuse + ambient + hemi;\n\n    // Apply fog\n    float fogDistance = length(vWorldPosition - cameraPosition);\n    float fogFactor = exp2(-fogDensity * fogDensity * fogDistance * fogDistance * 1.442695);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n\n    vec3 finalColor = mix(fogColor, litColor, fogFactor);\n\n    gl_FragColor = vec4(finalColor, texColor.a);\n}",
      "vertexScript": "varying vec2 vUv;\nuniform float time;\nuniform float windSpeed;\nuniform float windStrength;\nuniform vec2 windDirection;\nattribute float instancePhase;\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal; // Add for lighting\n\nvoid main() {\n    vUv = uv;\n    vec2 dir = normalize(windDirection);\n    float wave = sin(time * windSpeed + instancePhase) * windStrength;\n    wave *= uv.y;\n\n    vec3 displacement = vec3(\n        dir.x * wave,\n        0.0,\n        dir.y * wave\n    );\n\n    // Compute world position in world space\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(position + displacement, 1.0);\n    vWorldPosition = worldPosition.xyz; // Store correct world position\n  \n    vec3 normal = normalize(normal); // Assuming grass geometry has normals\n    vNormal = normalize((modelMatrix * instanceMatrix * vec4(normal, 0.0)).xyz);\n\n    // Compute view position for gl_Position\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}",
      "uniforms": "{ \"time\": { \"value\": 0 }, \"windSpeed\": { \"value\": 0.8 }, \"windStrength\": { \"value\": 2 }, \"windDirection\": { \"value\": [0.8, 0.6]} }",
      "vectors": "[\"windDirection\"]"
    },
    "water": {
      "title": "Water",
      "fragmentScript": "uniform float time;\nuniform float waveHeight;\nuniform vec3 liquidColor;\nuniform vec3 foamColor;\nuniform float waveFrequency;\nuniform float fresnelPower;\nuniform vec3 lightDirection;\nuniform float ambientIntensity;\nuniform float specularIntensity;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying float vWaveHeight;\nvarying float vNormalizedWaveHeight; // New varying for normalized height\nvarying vec3 vWorldPosition;\nuniform vec3 fogColor;\nuniform float fogDensity;\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewPosition);\n    vec3 lightDir = normalize(lightDirection);\n\n    // Fresnel effect for edge transparency\n    float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), fresnelPower);\n\n    // Diffuse lighting\n    float diffuse = max(dot(normal, lightDir), 0.0) * 0.25;\n\n    // Specular (Blinn-Phong)\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float specular = pow(max(dot(normal, halfwayDir), 0.0), 32.0) * specularIntensity;\n\n    // Base color with subtle wave height modulation\n    vec3 baseColor = liquidColor * (0.8 + 0.2 * vNormalizedWaveHeight); // Slight tint variation\n\n    // Foam effect based on normalized wave height\n    float foamFactor = smoothstep(0.8, 1.0, vNormalizedWaveHeight); // Tighter range for foam at peaks\n    vec3 color = mix(baseColor, foamColor, foamFactor);\n  \n    float fogDistance = length(vWorldPosition - cameraPosition); // Distance from fragment to camera\n    float fogFactor = exp2(-fogDensity * fogDensity * fogDistance * fogDistance * 1.442695); // 1.442695 = ln(2)\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    // Combine lighting components\n    vec3 lightColor = color * (ambientIntensity + diffuse) + vec3(specular);\n\t\tvec3 finalColor = mix(fogColor, lightColor, fogFactor);\n    // Apply fresnel for transparency at edges\n    float alpha = mix(0.6, 1.0, fresnel);\n\n    gl_FragColor = vec4(finalColor, alpha);\n}",
      "vertexScript": " uniform float time;\nuniform float waveHeight;\nuniform float waveFrequency;\nuniform float waveSpeed;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying float vWaveHeight;\nvarying float vNormalizedWaveHeight; // New varying for normalized height\nvarying vec3 vWorldPosition;\n// Simple noise function for wave variation\nfloat snoise(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vUv = uv;\n\n    // Combine multiple waves for more natural movement\n    float wave1 = sin(uv.x * waveFrequency + time * waveSpeed) * waveHeight;\n    float wave2 = sin(uv.y * waveFrequency * 0.7 + time * waveSpeed * 0.8) * waveHeight * 0.5;\n    float wave3 = cos((uv.x + uv.y) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * waveHeight * 0.3;\n    float displacementY = (wave1 + wave2 + wave3) * 0.5;\n\n    // Store wave height for fragment shader\n    vWaveHeight = displacementY;\n\n    // Normalize wave height based on maximum possible displacement\n    float maxWaveHeight = waveHeight * (1.0 + 0.5 + 0.3) * 0.5; // Sum of wave amplitudes\n    vNormalizedWaveHeight = displacementY / maxWaveHeight;\n\n    // Update position with displacement\n    vec3 newPosition = vec3(position.x, position.y + displacementY, position.z);\n\n    // Compute normal for lighting\n    float offset = 0.01;\n    float waveX = (sin((uv.x + offset) * waveFrequency + time * waveSpeed) +\n                   sin((uv.y + offset) * waveFrequency * 0.7 + time * waveSpeed * 0.8) * 0.5 +\n                   cos((uv.x + uv.y + offset) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * 0.3) * waveHeight * 0.5;\n    float waveZ = (sin((uv.x) * waveFrequency + time * waveSpeed) +\n                   sin((uv.y + offset) * waveFrequency * 0.7 + time * waveSpeed * 0.8) * 0.5 +\n                   cos((uv.x + uv.y + offset) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * 0.3) * waveHeight * 0.5;\n    vec3 tangent = normalize(vec3(1.0, (waveX - displacementY) / offset, 0.0));\n    vec3 bitangent = normalize(vec3(0.0, (waveZ - displacementY) / offset, 1.0));\n    vNormal = normalize(cross(tangent, bitangent));\n\n    // Pass view position for fresnel and lighting\n    vec4 worldPosition = modelMatrix * vec4(newPosition, 1.0);\n    vViewPosition = (cameraPosition - worldPosition.xyz);\n    vWorldPosition = worldPosition.xyz;\n    // Apply projection and model-view transforms\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}",
      "uniforms": "{\"time\":{\"value\":0},\"waveHeight\":{\"value\":3},\"waveFrequency\":{\"value\":5},\"waveSpeed\":{\"value\":0.25},\"liquidColor\":{\"value\":\"\"},\"foamColor\":{\"value\":\"\"},\"fresnelPower\":{\"value\":0},\"lightDirection\":{\"value\":[0.5,0.5,0.5]},\"ambientIntensity\":{\"value\":1},\"specularIntensity\":{\"value\":1}}",
      "vectors": "[\"foamColor\",\"liquidColor\",\"lightDirection\"]"
    }
  },
  "textures": {
    "forest": {
      "title": "Forest",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwOEX1QMH0QuRwQqWXk7NdvLTHSwY3uy3Huz5boua9aEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAs/vWAZcNxDRQAAAABJRU5ErkJggg=="
    },
    "grass": {
      "title": "Grass",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAwCAYAAADuFn/PAAAAAXNSR0IArs4c6QAAFepJREFUeF7dnGusZFlZht+1b3Wvc++Znu6BQTQS/amJ/HAQQXBgMIDGGCBRE6KSiJFI1DhgCNEIxgAaY8IfiJJ4wRguigwzDsMEBjSK/BBNCAkRZprp6du51L323msv83yrqi+nh992zZ7L6TqnTtWqb63v/d7v/d7d7qd//t5QLoLmk0a97UShkTr9TE5SuWxUV0FSULefaTatJZeoWnjlLaduL36v00s1n3p7zMX3sjRRmjr5RioXtZKMV4xXCJKv4x+ck5pG9nrxh/FLXQdbQ6udaLlo5HiinJ74zNM3Xuj6K27uH9wrXn8+eB80Own22Yd7iQWUB4t5UGBHVleXQM9qheDUKlItyxh025ibrvX3ynlQ3nZqd1IdXy7t9QfbucqyseAmCf+TvUZVelW22VLKZgVnP+e5TR3U1E51JXWG0uOfuvC82QT3steeCw0bMJbOvqjQfBXMyXGj2SSo3WFT0uvhJRDjY6+8kHbO5FrOPQfztmsxjac2K5yd8hCCOt1MJ4eV+mzCzKvdTVXXjeRi4MkMruVEcllQ8EH97UyLqVdVBrX77Fi8ni+b4F7+M+dtA7pbmQVlHUw2YD7x2jnIlGScSslXUlYkKheNneTJVadi4FW0k+sbx2m+eqnUYJhpMfHKWs6Cn+bxVPf6mcZHlVzuVJeNgpdanVSVb+QXwaCq1ZYWi2CwRPZMTryy4kamsAGjQ69//fwzG58J7sE332cbMD6utXc2s9Pd7iZazBr7L01cxOjCCajq9lMtZl6Nl53OumrUaqcGQwT/6HJpmxmqIL+CmaaSfBNUtFf7S2Zkqe31+KRWkjgtF14uccpzykwiX8f3yH7olxS++TGDMtvcZ0t7PzbKKRhcbsL6v/S57z7nYXGvfOP5wEdpQtD0uNHBuVzTiVenk2o69mrqRlkr1dGVWtt7qcEJV9ME2xhKhJ3wLMIN0LOcN+oOUgVqtkuVFo0Gu5kSJyvWrSKzjIpFXRofSr1Boqpu1OokBmu8Lq9fVkH9Ad9rtLWX6dLTpTr9xOApzRLltqmbsf4vP3r7Jrgff9W5UPScDi959YdO2/uFDi+XekO/1CNqaXYiFUVibAg46W+ncmmwYuyXTp1uqsmoNsYzOvbKcqeilSjLpXoJbueajSv5Urrn+1oKauy9gP29s4Vmk8qYDgU/cYk9t7uVa3ZS2aHIgLexV6vrFKpESqgLqRZzrySVFqOgTVr/Fx+5lcW5173lvnB4pTb8h/i1u7IAUg/5gONDgpqoaElp4bR3d6Yr362NJXHySX8wnN/hdBdtp7yV6alvLnTX+Uw1BKmRat9YXchbqXoDWUZ1erltANd8FCzgiWODvTqDXHkRNB55BR+zqjNItXNANgJusSZwbdL6T5MH2wCKHGlfL4J27ykUGvoCr/lEVoB3zqTGRMBqgrRmpmRERbFsU1CDev1UtScDoIyNbU6eZ9YHQGZhUHkr0f7ZROXMaTKpdPVCozP3JkZB+1u5xkeNpqNSSZKot01BpgjTR8SAs+nA1s19xyat/zN//e1baoFtAFjsy0RJGmKD5GJj1m47be1nVgvAeIpk03jrA9YnkN/Nc6feMNHhpVrLRdDBPbkxnvFRrazILJMS1xizCXVQu5cohFRbe4kOr5Tqd3Mty1p5kWo6qVUvpEXpNdxJ7X3ZZCWNiiLTgmJ900dY9xysP82D6pLMbDSbNup2kjtu/Q9//Du3bsAr3nA+5Hmik2ve6B8ws72f6uoztdqdzPj4ctZYVgAfaRqMk+/fk+nqxch8ukPFP/c5wVUsyKCDc8aiwCsY1HQUlMipNZCqudTuueu0l2fZ7x+zAY3qJmjrTKbgnSYnwFTQR151pF99Yu96u9zpZUZ/W63EIK3VdrFObaU6ulyr3c2sXt1J6//+d8xu3YAH33RfGB3X6nQj+7gZZuDuvl51Ryt5AIq6lg/iSeTnznqBaknzJXnv1O1majz1I1VZer2mN9QXv31VF0Kq/k6iVgGtzDWbxhrQbmd65sJS3U6mNJGWyzrC0k4qehKYT7WkAUzkVn1hbwAFdUZlyUL6ilvWD3Vedde8B/LG//f6n3zk1t7F3f/AubC1l2sKk7kJZppm3cFKNZKEA+uhocEK7vGL3in31T+2k561EmNDZElVNWq3cutqgav1RQYoZKoWUqvPvnkVeaqqptYEJXnUh7a36fqcsaxWK2ZiZ0s6ueK1dRA7YbJuufR2OICn51p/aGJ2sY47af23FeFXvvFcgOUQBIILzCRJhBlO3XzcxMLrnTVjrR4g4jQbeXmUNhfUG6LlNKYPJVmi2aRWUwYT0cgMXocL1jMZxYLf6jhVy5UE4aGSvK4lk10EjoLLVyjubNIY1BD4tfhHp8yaWf9iZr9wAyaXQZ1Botnozlr/Y5966lYIQoqAuxNAPmwJd+84jQ6Dtg8S02umR41SkxQaTU9o1iJTohlDMe3TdFk753T54lJpklrRRWkrutBZMMNbbJuVEkpydKkBkqolzZpXu5VpPq9WwZcV0HImTawwNwZ2MKvtfeirsQX79/r6obs1tDixdfa377z1P/nIrc2Y+4kHz4V1MUsB3xWqc+rrZaOig/wMuwhWoHkKhe7as157d0cwhq1cuVCpO0hULgm4UwJTShI5RLheojk6T9Ko9kEZek8rNTxfzrw6fbruyhgUdaecNVagwfP5nI43yJdkpdTqcRBkkDcbw8h4/ViMeT4CIG9tcLgMKsi0O2j9X/6XUxsAC1qntK8oonSljTi0v/8bD+l9H36f1QZOLN9HIiZwFFweDLZlgaHr5fv8R1Ysp5zM2MxlbXIhtZM6GcOcbhRgoKjx8fdGx6U63VwvHZ/o8bSjXp9aEnR0tY4U2dODIOjFGQEbgfxxev38jHXeiet/8uFTRfgnX38+wFxodGhoQGKwnqYI+seJbHUyLee1ZieNuluJQp1oNq+0vZebMMcJrav4e3xwmMlbHvxFffrJv1U5r9Xu5RqflDZzaPWd2jbMya0R4/nkXdHNjbGA6eDKdFpp9yAz6kpA6TeoAeg/ZE1VB23twrDiUGdT1v+Ff7p1lnG9EUugnAsUy9ROmm8a9XqRSqLTrIsjDITOlEEJbIhhiTVoAXYUq2iWJfrtt75Lf/ax9xvt8146uVZaFiFbMMihyfvQe/5Kv/v+t1qGTUaV2u1Ui2Uc7pj0kA+Udhaaz5E+aALDSgrPNDmutXNXbPjYnE1Z/xOnN+C1b3phQNgynrykjEoupfGSjq94/eCPtDU5aSyIFGoqIewD1ROe/t6XjvUH/z4wOEKzBzbAc5Orh8wbU5OiwemTw9IYTZqlWi5qMTEDRugLqDHw+8zGmPH9q0WirN1YzWAaxvsNtjLj/UgdbC7zgk1a/xf/+VQGvOrnXhAorqQ1Em+SJppNvVyTqCEQqJYrAW64nxrW0/B0hyikskD42inNZUIcs2MK4louiPpN1IrIHCgjG8UAtMihiV7tfibPDhsBCMbzkSR6W6lCBRzVYm5Nc4dkDWyhVSFpAEmbtP5HP3FKivipnz0fOIlgauKccXZ0eD+XlpVXd5gaHPCh1zzdRLZ2YoE6fLa2Zmqwk14PPpIGbIjNkPNaziKvhxq2isi0OM15h4451YzNb4JtjPULXTrk0qSQqxcr7d5VmEyNzjPYox41xnTopn3dWCZtyvpvY0EMZAg4ciWFjLktKW4nrsfMNna0PEaH96UzfQgWRPtfLpAeGJxL/d0bM9t1MSWgiHNXnqmMwYS6ka+Quxk/Sr/3tnfrfR/+Qyv2dLbUICZdBJTXWIwZh8YaxIZNDpvYsSvOiB1Ff4PW//gnT0HQK15/LljHO41dKUGlCzbJd4QgllvBA1KidSRYd9nposEgAySG0cslSmqc464vpOVOLzZoFGoG8IsJcBWbpE4n0zsHqT5wsdQsiRaU2bi2ZssyhvdnCpfK9KC8RTedaTaqtHN3YTNn1rNJ6//Ko6doKEW4v+109WKUB4x99DKNDisL6HIu03tcLnW7iW0QtBDM50oTRokrSWE1noSOouHs7OfR5uOoLYijQSdXg1pt6kJtcwOTHGhoaZ58HHVSJ5g9U4uAscUMZRNLjFeeRWsMp571UoQ3af1f+PSpDLj/1edDZ+hMjsZqglQAu6Bo0gss5rUmx94G8AQQGGFj6DiBnisv+R090Puq/uvrT1gRf+evvEMf+OifWs9gDZwa5RkKqrPX2b0rs9+nSWMCNzryOjhb6OhKaboRjgs0HCCPbALaTP0081Zi2YhxjP6j3UkM/zdp/Y/+wykt6P4Hzpsjiw9LQNMcR0JjBRl8Ve00L320lAyREBjQ1BZEAkzGcOLpSDnGzI/JjulJHOgXNHHYXQALdJtUxnqgmcgSTdUYNAFTSBy8bn8Y0+vkGrOFOFfg+fQd5cJrMQ3q7URZHHV1k9b/2CdPbUCcCZfm+cFoNTqq7IMyv+UTWrp7eD/yrzTYZYOQI6IsDGT8lo70J822qZyG0SaURdaETMGGAkUEFjgxvYb5bxYhhPFifxgddlgagRZmCjH7GjsIvSFpECnqzU48Y2IbtP7nnAnzgZolKltj7KbVTaSQCD/PYlErz5yKbvSN2uk+CkrTVO1hUG9AwCujjK2OdHwt4vXoKDolOu1UJ8fVdUixeTE1IyhS3JlX0WKWfMMCySYig8QN8wZdvS3qQgz+DU9q9LBu0vpvmwkjxq29mZx4xnfgcKuLpCxtn8k0Poz+HYY03U6qKxcrDXcTkx+ADgI1NXdDdDUAKcgZBI6BPlo+NQVstx6gjIWWggN8mRglBvjRG4QmhI0FecF6c9fYyHP/bPY9vah4Szdh/bdlABtgQZnFLjgpZDQTaRlYAAYQzoAiijCQgo4Dth8+W1pW4PWsytpgxvQjbCbT2uRi6C2Qde8PFLr63Upn7i3sxIba2byWue3/vPiDevHXf/O6RxSpmblEhSvaxpONSRS9rcwcdM91bcr6H/67U50wNeDZp5faOcgNagjiyREMA1roTHuZmSM6uuAYfAMZ5RItHtEs6jO4FWyCZdMs/EIUzqDhdq4ZtpSbZsvTEdOt1GoDhqtogaTRilMx2A6SNu8zulapqqWDszCy293YZO8mrf+2DFjPhCm+fHqaI4YYFEbGkUjAW/vRwQZS3GoJyTUelZH9ZIltApo/np5rl0rtnc3t9P/C3cf6y2/1I1NazXQvfntpj6G8MB2aL1gQQSdz8Bpd+k6l3f1ClY8uvP1zkR1R+NejSpgSM+FNWf9tNYCRpE2XJrXJAQS4aGU6/OE/0l3feJc9ns3rqJLieFjVSmNCDNVxKrSd0U4mY/QRrTzVosRpkenC6AVaPv0NHTzwkIpvfsAasukosp7DK3EewDBG3pmmhLxggp9Heo7vGWluzMD1HBkx0DbDr6ZjG7L+Lz18aiL2stecD4PtTM3K7sZYDx/oM/pR3V3/hwbb8fTDXN79Y8f60NcPNF9iZaQ7DuoUmZ16jFVI0RRmhjdI0DY6HDhd/o5Xkq+G92C4cza2XN8Og77EfQPDvcy67emUvgOlNWhevEA7+YXoimMeUFaqlk7AGIyKYr5J6//s6RrwstecC6Q+NBIpoG68cXG7cQK/z2oixiYQXIxWZAHBQGYGPrIkStjtbrSyR9mU4X4m31Q6uhyVTvg/tNWyilubME5hBKiwpvjYeU9jbcGmYj83nxFTsRX+r3qMyRE2dtzUsYHblPXfDkGvuzcQTD4khXA6dto9Q7da6NfqQ/3bvNDXirbNiuHq+PoJGM81Vwr3ceWplnW0lF83bSXxjpjjy7WUwjijbMxsgW7XHBiLYHT36BJ3zaTWY5TzOPRB4+f3OQg2CLJ7DVBLsbnTpHmbJaCebtL6H/vEKQi6/9XnIO+mtyAEO5gQ94fZwIMUd1aYcbfh66cApkViLgWCv6zqeEMdfUIFg4Eq1kqLoJLblBI2joxBcogdNNx+OeN1pP17gDiaNmwuTg2wM8UdgXUx2kpoxkypNSmCU58aRWU+gNyxSet/5OOnpIh1H8CIsdN3yhwz2zgSRCrAMW0+nFUhno9wIsSKnGVBk7G0tctWcFckJihpaYF3RiWzxClZuaWNufAYw21FB7yaHwA5aESdVJef8rZ5bLR1v9zAV8Us6A9TjQ5rO/Wja7V27o7DGa5NWf8/fuxUH/Dgm18YwOZ2T7r4VKXhVh6bnZWtDzgg5aGJqGnoPVDFziCyoGuXS5OIsRuyDXg8TczLEdNqM0nR3RLI+ZQOOQ5v+AqTMjYTlQnLIoprVTr1B9F/xAVUUXBtqN+OdsbrckQXu+TmrP+Jz5weyLzhfBjuMuuN7gKCiuOBs7l9kOrkKq7pXEeXF+rvtpS4WCyno+hggxZi4KJZYiz5ywcDfeSZkWXCWpHD+IuWvxg3WixltzqZvWQBvXUGRVBhTvf+OepGhBybDRRO42ukI6Je0NZ+GkXAEK5D0yat/z+fvHi7PX3dHLEB1TzaTNgACmGxuh8YLr6cBG2fibIEOhHuBm6mW0zwBUmdLfqBxqADCsk/T3+j0r0vyW2jmHiRFdhWgDv2iBPNhv/Fez6st7/3bWp8o94wj3ddughLNGYTPJ6Yd89wH3Mc/N98rTPiTl//175yaiJGDaDQcQEd3CWJFM1Xs5yXjB9TkxLwh37woT/Xrz/0drUHTuUkqOhj1G3MgogVPW0xzgy69FSkpZ1hYjoOp5uiqgYbfK1lKZ17EYFmvuzVanY116G2d3PN59wxuZqSBawumW06zR4KqhXkYjU6BfY2ZP2fPzUP5nM4RpIMWrgdiRN5fLWyYXzAXLsy3AIFa72e0w42u5BYFviksQAt7MRyp6VT0Yt3tkMVt3dSTad4eJz1Ge1eqsG20//+d6n20EWfUBr1IHQhLjphGrX5rNHbt2f6qO9HDxG9BbI4e7xKZDJkE9Z/ehS5zl734FvuC6Qz0IHvh0ZouF2Y8smpU0gNknA3W3DmDEu4cToztmLzgHFlVBB3M6OXI1RSszhGoy4q5lq3b3dhvdhOahv6A3OAETYXlwS12wSYTre23gRZ5MK3SruvrI8wOPF2SyuTu8/+za2M4hZM2pAH7uWvOx+wh8xp7fHprKyHw/2Iw3anSyOTGkoG9Dif6cISr26XoXtsquiE9+7iPoNVMWd4TlGHydxSduIkDbvhgjkBg6A0ft06uBE1yEB3AJNqbEA/Pq6sT7ArOH3pc8+Pv7TDIIjbPMFw4+VJLHzc+4v0bPIySiVBTyM80CeAu9zMbTaS1V/yAGPhJg0yp2SgYp6doN0zhZbcVwxlj97beJcLN+0F7jGIKur6Z2QZ9kizuecr58Wi0bMXKuukn/wed51vyKG/ZZmOIhx5dvzrZQgGqqjdD4BgRtxTJAIaguhkwFxFsA1esBGuGAnshDOKrdAvmGpSC5LVVCyyGgt86W3qhVuCb0JH7a+zMQ3IaX4S+xDeH3Gwy3waEPRej/z98+Pkr3fh/wAwjitsSv4ZrwAAAABJRU5ErkJggg=="
    },
    "lava": {
      "title": "Lava",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAkUlEQVRoQ+3UQQ6AIAxEUXpnj8GdMW4Jhl0/Jd+1yei8TGP0NlqhJ54WhT53+6lRDeD7o5sQSgLchFAW4BaE0gDbA3vQC39nU4BEpBWCAIkAq7MpgADJDcBx8xlyAckgAiQXPscJIADcABzvAgSAG4DjXYAAcANwvAsQAG4AjncBAsANwPEuQAC4ATjeBRwG8AKHQEgZvHpI7AAAAABJRU5ErkJggg=="
    },
    "path": {
      "title": "Path",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAA+0lEQVRoQ+2UsRWDMAxEcZ8FskAmyIAMmAmyAAukJwlFCj+MfcLikCJqSzrdP5HmxzgPhr50H5MhuVWpyRqA70aeIJgE4AlCM4DndBlu11f1pEoP9tav9fVwCc0AxM5H4eJAKSxqADQSb53lGgQ1ANbN0tKfQxABiHTL8UAAwmi50aVKCED/8dExAJAzQAPg7Xcm3UcFgFQMOYyU8SoAKJtkQ0shOFs4NgFIxEpqzgCMpcHtBbAMRecGANSxz3vkymtvYQC1hoJ9fiWavffo0qyFAWiK+cfeLgFYuiSXAJBLYsPqCoC9DGL8EW9b/OgK4IilvM0IAGSiOYA3/xycGR8hN+EAAAAASUVORK5CYII="
    },
    "rock": {
      "title": "Rock",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAA40lEQVRoQ+3VPQ6DMAwFYHItBqQOzIw9I2PnDpUYeq2iTkgoyAnBvzzmyHn4syEN0/PXOXqW15wcxSWjJm8A/zeKhOASIBKCW4AoCK4ByA+soQNHn00ACCLlELIA/WPsvp/35dG46l4elLHgHgEbwNjsXOkmAExwu1YTQPv1qAAA5RkAAACUO6B8vdgG4IedlxYDUB40s9e7A4i2SSYAojW1Zt2KAe7cpJqG1p4tBqgtbPU81yCdrcsGcDaQVTiuXGwAXIGj1VUBwHZsY0QCWGhWaYbSc5JbRGUiASTD3vGuPcAKi06NGSIOm+IAAAAASUVORK5CYII="
    },
    "scales": {
      "title": "Scales",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAQ0lEQVQYV2OM6vL/z4ADXD1wi4GRoAJ9L83/2g5qGGaAdIPEwSaAOOgApgnFCpguZMXEK4DpRjeFEeRIkJHIDkV2EwCeFirmzbH2AwAAAABJRU5ErkJggg=="
    },
    "start": {
      "title": "Start",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwGEb1QOL0QuQwQqWXk7NdvLTHSwY3uy33VZ0v0HOdeEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAvn4mAZ8YoyRAAAAABJRU5ErkJggg=="
    },
    "water": {
      "title": "Water",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAlUlEQVRoQ+3UwQ2AIBBEUbEh27ME27MhNF4Jhtt+lnzPJqPzMlv26362RE89j5Loc4efWrIBfH+0EkJKgJUQ0gKsgpAaYHhgJ3rh72wKEIjUQxAgEKB3NgUQILgBOK49Qy4gGESA4MLbOAEEgBuA412AAHADcLwLEABuAI53AQLADcDxLkAAuAE43gUIADcAx7uAyQBeDUJgGasSxlsAAAAASUVORK5CYII="
    },
    "end": {
      "title": "End",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAlklEQVRoQ+3UIQ6AMBBEUeo5D56T4zlPPQTblNTt7zYfTTIwL7PlOvZnS/Scdy2JPnf4qSUbwPdHKyGkBFgJIS3AKgipAYYHdqIX/s6mAIFIPQQBAgF6Z1MAAYIbgOPaM+QCgkEECC68jRNAALgBON4FCAA3AMe7AAHgBuB4FyAA3AAc7wIEgBuA412AAHADcLwLmAzgBfVWYBnOEmyVAAAAAElFTkSuQmCC"
    },
    "background": {
      "title": "background",
      "image": ""
    }
  },
  "abilities": {
    "ShieldWallAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ShieldWallAbility.js",
      "fileName": "ShieldWallAbility"
    },
    "ArenaPresenceAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ArenaPresenceAbility.js",
      "fileName": "ArenaPresenceAbility"
    },
    "BlizzardAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BlizzardAbility.js",
      "fileName": "BlizzardAbility"
    },
    "BloodlustAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BloodlustAbility.js",
      "fileName": "BloodlustAbility"
    },
    "BurningAuraAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BurningAuraAbility.js",
      "fileName": "BurningAuraAbility"
    },
    "ChargeAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ChargeAbility.js",
      "fileName": "ChargeAbility"
    },
    "BuildAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BuildAbility.js",
      "fileName": "BuildAbility"
    },
    "ConsecrationAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ConsecrationAbility.js",
      "fileName": "ConsecrationAbility"
    },
    "CorruptingAuraAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/CorruptingAuraAbility.js",
      "fileName": "CorruptingAuraAbility"
    },
    "CurseAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/CurseAbility.js",
      "fileName": "CurseAbility"
    },
    "DisruptionBombAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/DisruptionBombAbility.js",
      "fileName": "DisruptionBombAbility"
    },
    "DrainLifeAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/DrainLifeAbility.js",
      "fileName": "DrainLifeAbility"
    },
    "ExplosiveTrapAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ExplosiveTrapAbility.js",
      "fileName": "ExplosiveTrapAbility"
    },
    "IceShardAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/IceShardAbility.js",
      "fileName": "IceShardAbility"
    },
    "InfernoAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/InfernoAbility.js",
      "fileName": "InfernoAbility"
    },
    "FreezingAuraAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FreezingAuraAbility.js",
      "fileName": "FreezingAuraAbility"
    },
    "LightningBoltAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/LightningBoltAbility.js",
      "fileName": "LightningBoltAbility"
    },
    "ShadowStrikeAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ShadowStrikeAbility.js",
      "fileName": "ShadowStrikeAbility"
    },
    "MindControlAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MindControlAbility.js",
      "fileName": "MindControlAbility"
    },
    "SmiteAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/SmiteAbility.js",
      "fileName": "SmiteAbility"
    },
    "MultiShotAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MultiShotAbility.js",
      "fileName": "MultiShotAbility"
    },
    "MineGoldAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MineGoldAbility.js",
      "fileName": "MineGoldAbility"
    },
    "EnchantWeaponAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/EnchantWeaponAbility.js",
      "fileName": "EnchantWeaponAbility"
    },
    "MirrorImagesAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MirrorImagesAbility.js",
      "fileName": "MirrorImagesAbility"
    },
    "TrackingMark": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/TrackingMark.js",
      "fileName": "TrackingMark"
    },
    "PhalanxFormationAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/PhalanxFormationAbility.js",
      "fileName": "PhalanxFormationAbility"
    },
    "SummonWolfAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/SummonWolfAbility.js",
      "fileName": "SummonWolfAbility"
    },
    "Tornado": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/Tornado.js",
      "fileName": "Tornado"
    },
    "WindShieldAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/WindShieldAbility.js",
      "fileName": "WindShieldAbility"
    },
    "RageAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/RageAbility.js",
      "fileName": "RageAbility"
    },
    "PiercingShotAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/PiercingShotAbility.js",
      "fileName": "PiercingShotAbility"
    },
    "BaseAbility": {
      "fileName": "BaseAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BaseAbility.js"
    },
    "BattleCryAbility": {
      "fileName": "BattleCryAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BattleCryAbility.js"
    },
    "ChainLightningAbility": {
      "fileName": "ChainLightningAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ChainLightningAbility.js"
    },
    "FireBallAbility": {
      "fileName": "FireBallAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FireBallAbility.js"
    },
    "FireStormAbility": {
      "fileName": "FireStormAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FireStormAbility.js"
    },
    "HealAbility": {
      "fileName": "HealAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/HealAbility.js"
    },
    "RaiseDeadAbility": {
      "fileName": "RaiseDeadAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/RaiseDeadAbility.js"
    },
    "MassHealAbility": {
      "fileName": "MassHealAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MassHealAbility.js"
    },
    "MeteorStrikeAbility": {
      "fileName": "MeteorStrikeAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MeteorStrikeAbility.js"
    }
  },
  "functions": {
    "calculateDamage": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/functions/js/calculateDamage.js",
      "fileName": "calculateDamage"
    },
    "calculateStats": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/functions/js/calculateStats.js",
      "fileName": "calculateStats"
    }
  },
  "managers": {
    "AutoBattleMultiplayerManager": {
      "fileName": "AutoBattleMultiplayerManager"
    },
    "ComponentManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ComponentManager.js",
      "fileName": "ComponentManager"
    },
    "GameManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/GameManager.js",
      "fileName": "GameManager"
    },
    "GameModeManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/GameModeManager.js",
      "fileName": "GameModeManager"
    },
    "InputManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/InputManager.js",
      "fileName": "InputManager"
    },
    "KeyboardManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/KeyboardManager.js",
      "fileName": "KeyboardManager"
    },
    "LoadingManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/LoadingManager.js",
      "fileName": "LoadingManager"
    },
    "MultiplayerNetworkManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/MultiplayerNetworkManager.js",
      "fileName": "MultiplayerNetworkManager"
    },
    "ScreenManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ScreenManager.js",
      "fileName": "ScreenManager"
    },
    "SaveManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/SaveManager.js",
      "fileName": "SaveManager"
    },
    "ResultsManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ResultsManager.js",
      "fileName": "ResultsManager"
    },
    "SquadManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/SquadManager.js",
      "fileName": "SquadManager"
    },
    "UnitCreationManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/UnitCreationManager.js",
      "fileName": "UnitCreationManager"
    }
  },
  "systems": {
    "GridSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/GridSystem.js",
      "fileName": "GridSystem"
    },
    "AbilitySystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AbilitySystem.js",
      "fileName": "AbilitySystem"
    },
    "AnimationSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AnimationSystem.js",
      "fileName": "AnimationSystem"
    },
    "AISystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AISystem.js",
      "fileName": "AISystem"
    },
    "ArmyDisplaySystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ArmyDisplaySystem.js",
      "fileName": "ArmyDisplaySystem"
    },
    "CameraControlSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/CameraControlSystem.js",
      "fileName": "CameraControlSystem"
    },
    "CommandQueueSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/CommandQueueSystem.js",
      "fileName": "CommandQueueSystem"
    },
    "CombatAISystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/CombatAISystem.js",
      "fileName": "CombatAISystem"
    },
    "DamageNumberSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DamageNumberSystem.js",
      "fileName": "DamageNumberSystem"
    },
    "DamageSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DamageSystem.js",
      "fileName": "DamageSystem"
    },
    "EquipmentSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/EquipmentSystem.js",
      "fileName": "EquipmentSystem"
    },
    "FogOfWarSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/FogOfWarSystem.js",
      "fileName": "FogOfWarSystem"
    },
    "DeathSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DeathSystem.js",
      "fileName": "DeathSystem"
    },
    "EffectsSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/EffectsSystem.js",
      "fileName": "EffectsSystem"
    },
    "GoldMineSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/GoldMineSystem.js",
      "fileName": "GoldMineSystem"
    },
    "MiniMapSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MiniMapSystem.js",
      "fileName": "MiniMapSystem"
    },
    "MovementSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MovementSystem.js",
      "fileName": "MovementSystem"
    },
    "MultiplayerPlacementSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MultiplayerPlacementSystem.js",
      "fileName": "MultiplayerPlacementSystem"
    },
    "PostProcessingSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/PostProcessingSystem.js",
      "fileName": "PostProcessingSystem"
    },
    "MultiplayerUISystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MultiplayerUISystem.js",
      "fileName": "MultiplayerUISystem"
    },
    "PathfindingSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/PathfindingSystem.js",
      "fileName": "PathfindingSystem"
    },
    "ProjectileSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ProjectileSystem.js",
      "fileName": "ProjectileSystem"
    },
    "RenderSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/RenderSystem.js",
      "fileName": "RenderSystem"
    },
    "SchedulingSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SchedulingSystem.js",
      "fileName": "SchedulingSystem"
    },
    "ServerBattlePhaseSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ServerBattlePhaseSystem.js",
      "fileName": "ServerBattlePhaseSystem"
    },
    "ServerPlacementSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ServerPlacementSystem.js",
      "fileName": "ServerPlacementSystem"
    },
    "SelectedUnitSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SelectedUnitSystem.js",
      "fileName": "SelectedUnitSystem"
    },
    "ShopSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ShopSystem.js",
      "fileName": "ShopSystem"
    },
    "SquadExperienceSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SquadExperienceSystem.js",
      "fileName": "SquadExperienceSystem"
    },
    "SupplySystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SupplySystem.js",
      "fileName": "SupplySystem"
    },
    "StatisticsTrackingSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/StatisticsTrackingSystem.js",
      "fileName": "StatisticsTrackingSystem"
    },
    "TeamHealthSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/TeamHealthSystem.js",
      "fileName": "TeamHealthSystem"
    },
    "UISystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UISystem.js",
      "fileName": "UISystem"
    },
    "UnitOrderSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UnitOrderSystem.js",
      "fileName": "UnitOrderSystem"
    },
    "TerrainSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/TerrainSystem.js",
      "fileName": "TerrainSystem"
    },
    "UnitRadiusSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UnitRadiusSystem.js",
      "fileName": "UnitRadiusSystem"
    },
    "VisionSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/VisionSystem.js",
      "fileName": "VisionSystem"
    },
    "WorldSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/WorldSystem.js",
      "fileName": "WorldSystem"
    },
    "HealthBarSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/HealthBarSystem.js",
      "fileName": "HealthBarSystem"
    },
    "LifetimeSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/LifetimeSystem.js",
      "fileName": "LifetimeSystem"
    },
    "ParticleSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ParticleSystem.js",
      "fileName": "ParticleSystem"
    }
  },
  "configs": {
    "ai": {
      "title": "AI",
      "aiEndPoint": "http://localhost:11434/api/generate",
      "aiModel": "",
      "defaultPrompt": "I am developing a tower defense game featuring a simple 3d art style.  Generate a new object based on the following context.    Please provide ONLY a valid JSON object with keys MATCHING EXACTLY to the context above. It absolutely MUST have an appropriate 'id' field. Ensure all existing key types are maintained. Do not wrap the json object with any other text.",
      "fileName": "ai"
    },
    "codeMirror": {
      "title": "Code Mirror",
      "theme": "codeMirrorTheme",
      "fileName": "codeMirror"
    },
    "editor": {
      "title": "Editor Config",
      "editorCategories": "",
      "theme": "claude2",
      "editorModules": [
        "terrainModule",
        "sceneModule",
        "graphicsModule",
        "scriptModule",
        "aiPromptModule",
        "audioModule",
        "exportScriptModule",
        "textureEditor",
        "compilerModule"
      ],
      "path": "/",
      "fileName": "editor"
    },
    "game": {
      "gridSize": 48,
      "imageSize": 128,
      "title": "Turn Based Warfare",
      "isIsometric": false,
      "libraries": [
        "threejs",
        "BaseECSGame",
        "Rapier",
        "three_MeshBVH",
        "three_SkeletonUtils",
        "SceneManager",
        "ShapeFactory",
        "ImageManager",
        "SpatialGrid",
        "CoordinateTranslator",
        "CanvasUtility",
        "TerrainImageProcessor",
        "TileMap",
        "Entity",
        "Component",
        "GameState",
        "ModelManager",
        "three_OrbitControls",
        "GLTFLoader",
        "ECSGame",
        "three_EffectComposer",
        "three_RenderPixelatedPass",
        "three_OutputPass",
        "GameModeConfigs",
        "UIComponents",
        "NotificationSystem",
        "GameLoader",
        "GameUtils",
        "PlacementPreview",
        "EnemyStrategy",
        "MultiplayerECSGame",
        "ClientNetworkManager",
        "socket.io.min.js",
        "BaseSystem",
        "SeededRandom",
        "DesyncDebugger",
        "FantasyUIEnhancements",
        "MinHeap",
        "PerformanceProfiler"
      ],
      "fileName": "game",
      "interface": "main",
      "appLibrary": "MultiplayerECSGame",
      "canvasWidth": 1600,
      "canvasHeight": 1600,
      "is3D": true,
      "palette": "main",
      "appLoaderLibrary": "GameLoader",
      "initialScene": "client"
    },
    "multiplayer": {
      "title": "Multiplayer",
      "serverUrl": "http://localhost:3000",
      "maxReconnectAttempts": 5,
      "reconnectDelay": 3000,
      "enabled": true
    },
    "server": {
      "title": "Server Game",
      "projectName": "TurnBasedWarfare",
      "tickRate": 20,
      "seed": "auto",
      "appLoaderLibrary": "ServerGameLoader",
      "appLibrary": "ServerECSGame",
      "initialScene": "server",
      "libraries": [
        "BaseSystem",
        "GameRoom",
        "ServerGameRoom",
        "GameState",
        "BaseECSGame",
        "GameUtils",
        "ServerECSGame",
        "ServerEventManager",
        "ServerNetworkManager",
        "ServerSceneManager",
        "SeededRandom",
        "MinHeap",
        "DesyncDebugger"
      ]
    },
    "state": {
      "level": "level1",
      "mousePosition": "{ x: 0, y: 0, isoX: 0, isoY: 0, gridX: 0, gridY: 0 }",
      "isPaused": false,
      "isLevelingUp": false,
      "timeScale": 1,
      "gameOver": false,
      "victory": false,
      "modifierSet": "global",
      "fileName": "state",
      "population": 0,
      "phase": "placement",
      "round": 1,
      "playerGold": 100,
      "playerReady": false,
      "phaseTimeLeft": 30,
      "selectedUnitType": "",
      "teamMaxHealth": 2500,
      "startingGold": 100
    }
  },
  "inputDataTypes": {
    "json": {
      "title": "JSON"
    },
    "string": {
      "title": "String"
    }
  },
  "inputElementTypes": {
    "text": {
      "title": "text",
      "tag": "input"
    },
    "textarea": {
      "title": "Text Area",
      "tag": "textarea"
    }
  },
  "levels": {
    "level2": {
      "title": "Level 2",
      "wavesets": [
        "swarm",
        "swarm",
        "swarm"
      ],
      "tileMap": {
        "size": 32,
        "terrainTypes": [
          {
            "type": "water",
            "color": "#2d85c6",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "rock",
            "color": "#9e9e9e",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEAIf9RHEX0vjVAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2OcN2/efwYqgqSkJEZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAECFSQ0HGbi8AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAgnnz5v2nZTAxjlpAKHhHg4hQCDGMBtFoEBEMAYIKRlPRaBARDAGCCmieigCFBDkNArgMlAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAgnnz5v2nRjAlJSVhDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAOcCUBnjhUZTAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEAIf9RHEX0vjVAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDB0E5FSUlJjDTzAchwUPjRxAKY4TSxANlwkAUAUEhJDYCk3yoAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFAB7VMRQSdQqICRQv0EtQ99CwDb3jkNHe23xQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2OcN2/efwYqgqSkJEZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAC4oUBlpvrH3AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "grass",
            "color": "#4a7c59",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAnCQy6fQdcSIAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2P0qon8z0AlsK1lOSO6UYxDygKQ69F9QVUfwIIH2RKaWIDsE5pZAPPNqAUEc9BoEI0GEcEQIKhgNBWNBhHBECCoYDQVEQwiAA75PFN7PN69AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhRq+ayP8EVVGgYNQCgoE3GkSjQUQwBAgqGE1Fo0FEMAQIKhhNRQSDCAB4BShTjqMEpwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhRq+ayP8EVRFQsK1lOc6gpooFIPtxWUI1C3BZMmoBSvRji4fRIBoNItIKkdFURDC8RoNocAYRADzPTBkQkiUcAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAnCQy6fQdcSIAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgWSra1rKcEWQ7TSyAGU4TC5ANp7oF6IbTxQIARN88U7u38m0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCpgJKiCQgWjFhAMQJoHEQCyWyhTURksDgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P0qon8z0AlsK1lOSO6UYyjFiAHyWgQEUxro0E0GkQEQ4CggtFUNMyDCFsEg7xMlQoHl+FgCwgGLIUKRi0gGIA0DyIAQT9MGVwsaTUAAAAASUVORK5CYII="
            ],
            "buildable": true
          },
          {
            "type": "forest",
            "color": "#1c6438",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgA71YpQQB/w8QAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2OUSbH4z0Al8GTOCUZ0oxiHlAUg16P7gqo+gAUPsiU0sQDZJzSzAOabUQsI5qDRIBoNIoIhQFDBaCoaDSKCIUBQwWgqIhhEAIHMNK76+kj9AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhRpkUi/8EVVGgYNQCgoE3GkSjQUQwBAgqGE1Fo0FEMAQIKhhNRQSDCACNcyCuKmmRrQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhRpkUi/8EVRFQ8GTOCZxBTRULQPbjsoRqFuCyZNQClOjHFg+jQTQaRKQVIqOpiGB4jQbR4AwiAPx6TBmX9XIXAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgA71YpQQB/w8QAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgWSp6MucEI8h2mlgAM5wmFiAbTnUL0A2niwUAO0c0rkd3ClIAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCpgJKiCQgWjFhAMQJoHEQBLXiCu2Bx7HwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OUSbH4z0Al8GTOCUZ0oxhHLUAOktEgIpjWRoNoNIgIhgBBBaOpaJgHEbYIBnmZKhUOLsPBFhAMWAoVjFpAMABpHkQAAPlMGX+pQM0AAAAASUVORK5CYII="
            ],
            "buildable": true
          },
          {
            "type": "path",
            "color": "#f5d69a",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEADJ7UXnV1RQ5AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2P8em3WfwYqAW6tNEZ0oxiHlAUg16P7gqo+gAUPsiU0sQDZJzSzAOabUQsI5qDRIBoNIoIhQFDBaCoaDSKCIUBQwWgqIhhEAJvSVIWbYGLaAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhxq/XZv0nqIoCBaMWEAy80SAaDSKCIUBQwWgqGg0igiFAUMFoKiIYRAACV0CFxNTeCQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhxq/XZv0nqIqAAm6tNJxBTRULQPbjsoRqFuCyZNQClOjHFg+jQTQaRKQVIqOpiGB4jQbR4AwiAFzITBnELKoVAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEADJ7UXnV1RQ5AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFABzVIRt1YaI8h2mlgAM5wmFiAbTnUL0A2niwUAqyRUhRUUb34AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFABI0EVFCoYtYBgANI8iAAWGUCFGtCTSgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P8em3WfwYqAW6tNEZ0oxhHLUAOktEgIpjWRoNoNIgIhgBBBaOpaJgHEbYIBnmZKhUOLsPBFhAMWAoVjFpAMABpHkQAYThMGX3v4DMAAAAASUVORK5CYII="
            ],
            "buildable": false
          },
          {
            "type": "lava",
            "color": "#cc6315",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "end",
            "color": "#ff9999",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "start",
            "color": "#ffff80",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII="
            ],
            "buildable": false
          }
        ],
        "terrainMap": [
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            4,
            2,
            2,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            0,
            3,
            2,
            4,
            2,
            2,
            4,
            2,
            3,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            4,
            2,
            2,
            4,
            2,
            3,
            2,
            2,
            1,
            1,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            0,
            0,
            0,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            0,
            0,
            0,
            2,
            4,
            2,
            3,
            3,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            4,
            2,
            3,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            6,
            2,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            7
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            3,
            3,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            5,
            5,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            5,
            5,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            5,
            5,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ]
        ],
        "terrainBGColor": "#467554",
        "environmentObjects": [],
        "ramps": []
      },
      "world": "shire"
    },
    "level1": {
      "title": "Level 1",
      "tileMap": {
        "size": 64,
        "terrainTypes": [
          {
            "type": "water",
            "texture": "water",
            "color": "#0288d1",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "water",
              "grass",
              "forest"
            ],
            "buildable": false
          },
          {
            "type": "lava",
            "texture": "lava",
            "color": "#ff8c00",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "grass",
            "texture": "grass",
            "color": "#5a8a4f",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "grass",
              "water",
              "forest"
            ],
            "buildable": true
          },
          {
            "type": "forest",
            "texture": "path",
            "color": "#2f4a29",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
            ],
            "buildable": true
          },
          {
            "type": "rock",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": true
          }
        ],
        "terrainMap": [
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            3,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            4,
            3,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            2,
            4,
            2,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            4,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            3,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ]
        ],
        "terrainBGColor": {
          "paletteColor": "greenMColor"
        },
        "environmentObjects": [
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 707,
            "y": 23.21875
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 702,
            "y": 81.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 328.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 56,
            "y": 347.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 73,
            "y": 266.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 54,
            "y": 190.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 205,
            "y": 48.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1095,
            "y": 351.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1234,
            "y": 320.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1094,
            "y": 255.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1258,
            "y": 242.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1442,
            "y": 334.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1504,
            "y": 315.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1193,
            "y": 196.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1313,
            "y": 78.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1519,
            "y": 55.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1518,
            "y": 166.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1431,
            "y": 255.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1136,
            "y": 286.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1056,
            "y": 333.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1233,
            "y": 76.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1423,
            "y": 67.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1469,
            "y": 248.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1551,
            "y": 331.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1182,
            "y": 326.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1229,
            "y": 177.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1538,
            "y": 263.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1490,
            "y": 110.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1351,
            "y": 50.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 714,
            "y": 1547.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 701,
            "y": 1497.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 746,
            "y": 1393.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 926,
            "y": 1424.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1008,
            "y": 1407.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 957,
            "y": 1238.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 691,
            "y": 1200.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 631,
            "y": 1192.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 644,
            "y": 1428.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 617,
            "y": 1538.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 454,
            "y": 1528.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 148,
            "y": 1534.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -15,
            "y": 1535.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -6,
            "y": 1371.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 61,
            "y": 1355.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 33,
            "y": 1470.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 232,
            "y": 1450.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 435,
            "y": 1448.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 576,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 374,
            "y": 1297.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 8,
            "y": 1223.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2,
            "y": 1304.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 70,
            "y": 1226.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 516,
            "y": 1211.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 656,
            "y": 1266.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 504,
            "y": 1332.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 304,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 292,
            "y": 1523.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 125,
            "y": 1398.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 406,
            "y": 1357.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 1324.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1516,
            "y": 1350.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1482,
            "y": 1175.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1493,
            "y": 1242.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 356,
            "y": 1191.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 160,
            "y": 1154.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 6,
            "y": 1150.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 435,
            "y": 1135.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 418,
            "y": 1231.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 646,
            "y": 1126.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1398,
            "y": 1146.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 214,
            "y": 1128.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 511,
            "y": 1499.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 476,
            "y": 1416.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 669,
            "y": 1366.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 352,
            "y": 1487.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 180,
            "y": 1517.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 163,
            "y": 1399.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 72,
            "y": 1528.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 94,
            "y": 264.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 88,
            "y": 358.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 619,
            "y": 136.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 679,
            "y": 141.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 689,
            "y": 223.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 667,
            "y": 335.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 603,
            "y": 386.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 589,
            "y": 482.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 744,
            "y": 385.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 782,
            "y": 226.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 861,
            "y": 58.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 780,
            "y": 1324.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 920,
            "y": 1335.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 862,
            "y": 1408.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 747,
            "y": 1497.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 867,
            "y": 1539.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 843,
            "y": 1293.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 876,
            "y": 1206.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 832,
            "y": 1270.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 945,
            "y": 1317.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 784,
            "y": 1467.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 865,
            "y": 1533.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 686,
            "y": 483.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 711,
            "y": 306.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 727,
            "y": 148.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 727,
            "y": 1250.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 752,
            "y": 1468.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 904,
            "y": 1502.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 673,
            "y": 421.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 744,
            "y": 51.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 744,
            "y": 50.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 369,
            "y": 1110.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 369,
            "y": 1109.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 102,
            "y": 1414.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 521,
            "y": 1466.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 120,
            "y": 1224.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 597,
            "y": 1467.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 345,
            "y": 1532.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 549,
            "y": 1278.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1234,
            "y": 272.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 1409,
            "y": 305.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 501,
            "y": 84.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1227,
            "y": 141.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1175,
            "y": 278.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1176,
            "y": 276.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1391,
            "y": 1537.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1391,
            "y": 1536.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1528,
            "y": 1435.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 173,
            "y": 1351.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 132,
            "y": 1482.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 93,
            "y": 971.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1239,
            "y": 935.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 1194,
            "y": 642.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 1369,
            "y": 486.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 98,
            "y": 534.8125
          },
          {
            "type": "tree",
            "imageIndex": 4,
            "x": 1432,
            "y": 683.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 408,
            "y": 602.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 1298,
            "y": 915.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 347,
            "y": 820.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 1206,
            "y": 514.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 451,
            "y": 1038.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 86,
            "y": 612.8125
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 2976,
            "y": 2976
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 96,
            "y": 96
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 144,
            "y": 2931.800048828125
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 2928,
            "y": 147.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2335,
            "y": 2963.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2314,
            "y": 2644.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2966,
            "y": 2469.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2016,
            "y": 2964.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1831,
            "y": 2647.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1876,
            "y": 2376.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1738,
            "y": 2936.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1831,
            "y": 2850.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2108,
            "y": 2994.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1813,
            "y": 2997.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2030,
            "y": 2757.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2166,
            "y": 2908.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2254,
            "y": 3038.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1877,
            "y": 2932.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1979,
            "y": 2630.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1979,
            "y": 2629.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1924,
            "y": 2801.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2199,
            "y": 2729.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2041,
            "y": 2864.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1667,
            "y": 2724.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1665,
            "y": 2515.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2117,
            "y": 2481.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1624,
            "y": 3000.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1911,
            "y": 3023.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1587,
            "y": 2854.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1903,
            "y": 2461.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2092,
            "y": 2581.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1772,
            "y": 2770.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2001,
            "y": 3068.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1771,
            "y": 3076.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2170,
            "y": 3107.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1830,
            "y": 2105.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1710,
            "y": 2252.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 215,
            "y": 1692.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 737,
            "y": 1688.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 977,
            "y": 1859.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 66,
            "y": 1897.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 302,
            "y": 1597.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 305,
            "y": 1831.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 618,
            "y": 1902.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 210,
            "y": 2183.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 752,
            "y": 2223.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 882,
            "y": 2790.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 305,
            "y": 2473.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1203,
            "y": 2977.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1311,
            "y": 2679.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 103,
            "y": 2328.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 451,
            "y": 2123.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 836,
            "y": 3058.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 835,
            "y": 3058.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 918,
            "y": 2925.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1035,
            "y": 2796.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1034,
            "y": 3034.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1411,
            "y": 3013.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1125,
            "y": 2820.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2298,
            "y": 89.79998779296875
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2549,
            "y": 504.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1955,
            "y": 392.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1743,
            "y": 496.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1872,
            "y": 198.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2264,
            "y": 796.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2934,
            "y": 805.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2508,
            "y": 705.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1844,
            "y": 613.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1595,
            "y": 744.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1775,
            "y": 773.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1982,
            "y": 812.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2162,
            "y": 969.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2494,
            "y": 1029.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1829,
            "y": 1085.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2458,
            "y": 1160.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2268,
            "y": 1135.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2719,
            "y": 1194.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2632,
            "y": 910.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2880,
            "y": 1202.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2537,
            "y": 1323.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2832,
            "y": 1378.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2527,
            "y": 1567.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2363,
            "y": 1502.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2434,
            "y": 1314.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2763,
            "y": 1505.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2529,
            "y": 1404.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2050,
            "y": 1430.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1999,
            "y": 1577.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2288,
            "y": 1593.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2002,
            "y": 1761.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2310,
            "y": 1851.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2537,
            "y": 1727.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2537,
            "y": 1726.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2909,
            "y": 1670.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3010,
            "y": 1357.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2731,
            "y": 1068.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1363,
            "y": 1812.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1272,
            "y": 2365.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1346,
            "y": 2778.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1942,
            "y": 2721.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1890,
            "y": 2595.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1755,
            "y": 2620.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1824,
            "y": 2532.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1884,
            "y": 2764.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1728,
            "y": 2830.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1727,
            "y": 2830.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1978,
            "y": 2369.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1782,
            "y": 2408.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1660,
            "y": 2639.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1629,
            "y": 2885.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1966,
            "y": 2493.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 119,
            "y": 1624.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 63,
            "y": 1719.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 415,
            "y": 1623.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 184,
            "y": 1842.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 83,
            "y": 1993.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 82,
            "y": 2102.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 82,
            "y": 2101.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 189,
            "y": 1943.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 419,
            "y": 1705.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2820,
            "y": 1909.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 651,
            "y": 1600.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1294,
            "y": 1667.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1544,
            "y": 1802.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1166,
            "y": 1792.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2980,
            "y": 601.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2805,
            "y": 582.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2671,
            "y": 590.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2719,
            "y": 679.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2855,
            "y": 642.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2771,
            "y": 742.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2927,
            "y": 729.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3021,
            "y": 668.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3015,
            "y": 856.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2852,
            "y": 793.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2849,
            "y": 717.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2774,
            "y": 652.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2653,
            "y": 715.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2625,
            "y": 652.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2630,
            "y": 765.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2699,
            "y": 776.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2813,
            "y": 855.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2814,
            "y": 855.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3040,
            "y": 746.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2882,
            "y": 657.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2918,
            "y": 842.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2985,
            "y": 889.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2750,
            "y": 804.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2973,
            "y": 686.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2993,
            "y": 791.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3041,
            "y": 601.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2584,
            "y": 688.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 834,
            "y": 1514.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 833,
            "y": 1407.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 721,
            "y": 1299.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 721,
            "y": 1298.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 831,
            "y": 1224.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 832,
            "y": 1224.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 921,
            "y": 1289.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 850,
            "y": 1341.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 981,
            "y": 1344.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 796,
            "y": 1591.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 319,
            "y": 1653.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 524,
            "y": 1645.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 856,
            "y": 1644.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2002,
            "y": 2434.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2060,
            "y": 2964.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1936,
            "y": 2883.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1858,
            "y": 2300.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1859,
            "y": 2300.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1634,
            "y": 2384.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1556,
            "y": 2564.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1860,
            "y": 2667.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1617,
            "y": 2668.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1530,
            "y": 2452.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1753,
            "y": 2316.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1799,
            "y": 2184.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1709,
            "y": 2460.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1901,
            "y": 2261.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1747,
            "y": 2529.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1677,
            "y": 3020.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1668,
            "y": 2798.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1727,
            "y": 2684.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 51,
            "y": 2182.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 184,
            "y": 2076.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 357,
            "y": 2214.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 494,
            "y": 2160.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 90,
            "y": 2288.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 315,
            "y": 2298.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 516,
            "y": 2289.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 327,
            "y": 2077.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 606,
            "y": 2102.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 421,
            "y": 2269.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 207,
            "y": 2199.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 484,
            "y": 1991.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 802,
            "y": 2083.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 2254.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 430,
            "y": 2041.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 307,
            "y": 2161.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 221,
            "y": 2293.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 220,
            "y": 2293.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 119,
            "y": 2235.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 426,
            "y": 2334.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 188,
            "y": 2321.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 446,
            "y": 2187.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 548,
            "y": 2183.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 526,
            "y": 2094.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 544,
            "y": 2023.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 380,
            "y": 1983.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 301,
            "y": 2027.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 220,
            "y": 1984.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 219,
            "y": 1984.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 93,
            "y": 2025.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 38,
            "y": 2073.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 35,
            "y": 2337.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 24,
            "y": 2428.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 44,
            "y": 2276.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 43,
            "y": 2276.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 26,
            "y": 2201.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 176,
            "y": 2171.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 280,
            "y": 2174.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 282,
            "y": 2082.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 518,
            "y": 2110.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 638,
            "y": 2022.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 641,
            "y": 220.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 661,
            "y": 127.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 549,
            "y": 1.8000030517578125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 426,
            "y": -28.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 145,
            "y": -18.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -77,
            "y": -46.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -157,
            "y": 153.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -79,
            "y": 80.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -133,
            "y": 10.800003051757812
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -44,
            "y": 9.800003051757812
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 26,
            "y": -46.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -149,
            "y": 236.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -115,
            "y": 268.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -171,
            "y": 418.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -64,
            "y": 273.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -161,
            "y": 351.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -58,
            "y": 386.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -73,
            "y": 600.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -159,
            "y": 710.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -45,
            "y": 839.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -26,
            "y": 660.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -137,
            "y": 529.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -34,
            "y": 427.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -35,
            "y": 427.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -100,
            "y": 715.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -154,
            "y": 872.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -165,
            "y": 571.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -68,
            "y": 502.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -102,
            "y": 333.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -24,
            "y": 210.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 73,
            "y": -20.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -33,
            "y": 83.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 279,
            "y": -46.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 544,
            "y": 503.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 43,
            "y": 708.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 87,
            "y": 877.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 181,
            "y": 791.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 447,
            "y": 856.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 691,
            "y": 625.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 599,
            "y": 793.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 598,
            "y": 793.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 704,
            "y": -100.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 268,
            "y": -157.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2,
            "y": -115.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -161,
            "y": -173.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 163,
            "y": -88.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 511,
            "y": -142.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1064,
            "y": -46.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1526,
            "y": -111.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1402,
            "y": -43.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1402,
            "y": -44.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1112,
            "y": -138.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 778,
            "y": -57.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 885,
            "y": -42.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1255,
            "y": -98.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1363,
            "y": -150.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1624,
            "y": -72.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -159,
            "y": 1974.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -162,
            "y": 1973.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -79,
            "y": 1753.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -143,
            "y": 1657.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -97,
            "y": 1094.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -104,
            "y": 956.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -143,
            "y": 1314.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -90,
            "y": 2081.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -120,
            "y": 2378.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -162,
            "y": 2182.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -70,
            "y": 2293.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -122,
            "y": 2555.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -40,
            "y": 2480.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -79,
            "y": 2856.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -25,
            "y": 2599.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -132,
            "y": 2675.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -144,
            "y": 3019.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -110,
            "y": 3164.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 73,
            "y": 3180.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 276,
            "y": 3108.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 336,
            "y": 3196.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 8,
            "y": 3100.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -18,
            "y": 3188.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -172,
            "y": 3216.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -162,
            "y": 3068.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -40,
            "y": 2948.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -40,
            "y": 2947.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -150,
            "y": 2857.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -45,
            "y": 2729.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 522,
            "y": 3124.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 861,
            "y": 3183.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 624,
            "y": 3233.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1096,
            "y": 3153.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1825,
            "y": 3234.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1672,
            "y": 3108.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2012,
            "y": 3146.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2038,
            "y": 3253.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2266,
            "y": 3193.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2355,
            "y": 3241.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2317,
            "y": 3113.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1696,
            "y": 3206.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1902,
            "y": 3203.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1943,
            "y": 3254.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1626,
            "y": 3117.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1444,
            "y": 3210.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1660,
            "y": 3230.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3118,
            "y": 3194.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2950,
            "y": 3144.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3134,
            "y": 3065.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3151,
            "y": 2957.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3121,
            "y": 2825.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3108,
            "y": 2653.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3237,
            "y": 3079.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3006,
            "y": 3086.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2925,
            "y": 3216.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2720,
            "y": 3208.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2855,
            "y": 3093.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3020,
            "y": 3231.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3237,
            "y": 3220.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3014,
            "y": 3123.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3227,
            "y": 2929.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3084,
            "y": 2893.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3125,
            "y": 2995.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3228,
            "y": 2764.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3116,
            "y": 2733.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3232,
            "y": 2524.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3112,
            "y": 2569.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3093,
            "y": 2368.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3243,
            "y": 2385.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3214,
            "y": 2653.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2816,
            "y": 3238.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3113,
            "y": 3249.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3200,
            "y": 3144.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2676,
            "y": 3102.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2413,
            "y": 3221.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2595,
            "y": 3240.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2596,
            "y": 3240.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2469,
            "y": 3134.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2598,
            "y": 3107.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2500,
            "y": 3220.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2559,
            "y": 3157.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2675,
            "y": 3269.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2753,
            "y": 3115.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2906,
            "y": 3265.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2906,
            "y": 3264.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2906,
            "y": 3263.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2906,
            "y": 3262.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2651,
            "y": 2306.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2938,
            "y": 2332.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2657,
            "y": 2988.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2412,
            "y": 3004.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3037,
            "y": 2606.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3142,
            "y": 564.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3133,
            "y": 697.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3211,
            "y": 694.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3176,
            "y": 586.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2351,
            "y": -81.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2171,
            "y": -123.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2210,
            "y": -24.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2299,
            "y": -170.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3159,
            "y": 830.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3160,
            "y": 831.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3209,
            "y": 888.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3117,
            "y": 882.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3253,
            "y": 822.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3113,
            "y": 784.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3158,
            "y": 1056.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2940,
            "y": 1004.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3151,
            "y": 1177.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3203,
            "y": 412.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3120,
            "y": 312.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3104,
            "y": 455.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3225,
            "y": 285.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3118,
            "y": 194.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3225,
            "y": 155.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3140,
            "y": 100.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3027,
            "y": 41.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2778,
            "y": -43.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2778,
            "y": -44.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2512,
            "y": 11.800003051757812
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2394,
            "y": -114.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2735,
            "y": -167.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3212,
            "y": -86.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3080,
            "y": -162.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2890,
            "y": -130.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3103,
            "y": -57.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3214,
            "y": 18.800003051757812
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3233,
            "y": -169.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3001,
            "y": -101.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2912,
            "y": -30.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2668,
            "y": -92.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2513,
            "y": -148.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2567,
            "y": -58.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2400,
            "y": -48.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2269,
            "y": -90.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1994,
            "y": -123.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1828,
            "y": -52.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1727,
            "y": -162.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2074,
            "y": -45.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2118,
            "y": 56.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1955,
            "y": 228.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1657,
            "y": 12.800003051757812
          }
        ],
        "extensionTerrainType": 1,
        "ramps": [
          {
            "x": 21,
            "z": 44
          },
          {
            "x": 25,
            "z": 44
          },
          {
            "x": 39,
            "z": 33
          },
          {
            "x": 39,
            "z": 31
          },
          {
            "x": 17,
            "z": 9
          },
          {
            "x": 56,
            "z": 51
          },
          {
            "x": 14,
            "z": 52
          },
          {
            "x": 49,
            "z": 9
          }
        ],
        "heightMap": [
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ]
        ],
        "extensionHeight": 2,
        "startingLocations": [
          {
            "side": "right",
            "gridPosition": {
              "x": 116,
              "z": 116
            }
          },
          {
            "side": "left",
            "gridPosition": {
              "x": 12,
              "z": 12
            }
          }
        ],
        "entityPlacements": []
      },
      "world": "shire",
      "grassShader": "grass",
      "waterShader": "water"
    },
    "level32": {
      "title": "Level 32x32",
      "tileMap": {
        "size": 32,
        "terrainTypes": [
          {
            "type": "water",
            "texture": "water",
            "color": "#0288d1",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "water",
              "grass",
              "forest"
            ],
            "buildable": false
          },
          {
            "type": "lava",
            "texture": "lava",
            "color": "#ff8c00",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "grass",
            "texture": "grass",
            "color": "#5a8a4f",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "grass",
              "water",
              "forest"
            ],
            "buildable": true
          },
          {
            "type": "forest",
            "texture": "forest",
            "color": "#2f4a29",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "forest",
              "grass",
              "water"
            ],
            "buildable": true
          },
          {
            "type": "cliff",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": false
          },
          {
            "type": "cliff",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": false
          },
          {
            "type": "cliff",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": false
          },
          {
            "type": "rock",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "walkableNeighbors": [
              "rock"
            ],
            "buildable": false
          }
        ],
        "terrainMap": [
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            7,
            7,
            7,
            7
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            7,
            7,
            7,
            7,
            7,
            7
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            7,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ]
        ],
        "terrainBGColor": {
          "paletteColor": "greenMColor"
        },
        "environmentObjects": [
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 707,
            "y": 23.21875
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 932,
            "y": 24.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 645,
            "y": 291.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 846,
            "y": 282.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 838,
            "y": 196.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 904,
            "y": 102.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 654,
            "y": 213.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 702,
            "y": 81.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 475,
            "y": 168.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 328.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 585,
            "y": 328.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 387,
            "y": 343.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 387,
            "y": 342.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 162,
            "y": 362.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 56,
            "y": 347.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 55,
            "y": 347.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 14,
            "y": 48.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -7,
            "y": 343.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -7,
            "y": 344.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 350,
            "y": 98.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 549,
            "y": 137.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 468,
            "y": 388.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 511,
            "y": 283.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 73,
            "y": 266.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 375,
            "y": 196.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 533,
            "y": 72.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 126,
            "y": 50.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 8,
            "y": 135.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 399,
            "y": 125.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 601,
            "y": 80.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 577,
            "y": 215.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 432,
            "y": 274.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 54,
            "y": 190.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 416,
            "y": 61.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 205,
            "y": 48.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 996,
            "y": 222.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 884,
            "y": 346.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 992,
            "y": 355.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1095,
            "y": 351.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1234,
            "y": 320.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 941,
            "y": 281.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1020,
            "y": 149.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1094,
            "y": 255.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1258,
            "y": 242.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1442,
            "y": 334.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1504,
            "y": 315.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1504,
            "y": 314.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1193,
            "y": 196.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1020,
            "y": 244.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 919,
            "y": 230.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 963,
            "y": 109.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1043,
            "y": 66.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1313,
            "y": 78.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1519,
            "y": 55.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1518,
            "y": 166.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1517,
            "y": 166.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1431,
            "y": 255.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1074,
            "y": 180.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1074,
            "y": 179.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1136,
            "y": 286.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1056,
            "y": 333.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1127,
            "y": 119.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1114,
            "y": 76.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1233,
            "y": 76.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1423,
            "y": 67.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1469,
            "y": 248.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1551,
            "y": 331.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1182,
            "y": 326.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1229,
            "y": 177.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1134,
            "y": 220.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1168,
            "y": 72.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1538,
            "y": 263.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1490,
            "y": 110.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 940,
            "y": 182.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1351,
            "y": 50.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 714,
            "y": 1547.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 714,
            "y": 1546.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 701,
            "y": 1497.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 700,
            "y": 1497.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 746,
            "y": 1393.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 926,
            "y": 1424.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 926,
            "y": 1423.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 946,
            "y": 1544.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 945,
            "y": 1544.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1008,
            "y": 1407.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 957,
            "y": 1238.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 956,
            "y": 1236.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 903,
            "y": 1145.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 730,
            "y": 1304.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 691,
            "y": 1200.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 631,
            "y": 1192.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 644,
            "y": 1428.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 643,
            "y": 1428.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 617,
            "y": 1538.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 615,
            "y": 1538.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 454,
            "y": 1528.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 453,
            "y": 1528.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 148,
            "y": 1534.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 147,
            "y": 1534.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -15,
            "y": 1535.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -15,
            "y": 1536.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -6,
            "y": 1371.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 61,
            "y": 1355.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 33,
            "y": 1470.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 232,
            "y": 1450.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 435,
            "y": 1448.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 576,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 374,
            "y": 1297.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 8,
            "y": 1223.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2,
            "y": 1304.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 70,
            "y": 1226.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 516,
            "y": 1211.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 516,
            "y": 1210.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 656,
            "y": 1266.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 504,
            "y": 1332.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 304,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 292,
            "y": 1523.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 291,
            "y": 1523.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 125,
            "y": 1398.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 406,
            "y": 1357.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 1324.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1029,
            "y": 1525.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1029,
            "y": 1524.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1338,
            "y": 1524.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1516,
            "y": 1350.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1482,
            "y": 1175.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 998,
            "y": 1147.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1055,
            "y": 1271.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1093,
            "y": 1394.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1145,
            "y": 1498.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1145,
            "y": 1497.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1221,
            "y": 1529.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1179,
            "y": 1321.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1106,
            "y": 1197.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1205,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1493,
            "y": 1242.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1214,
            "y": 1202.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1077,
            "y": 1154.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1076,
            "y": 1154.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 356,
            "y": 1191.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 160,
            "y": 1154.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 6,
            "y": 1150.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 435,
            "y": 1135.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 418,
            "y": 1231.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 646,
            "y": 1126.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1214,
            "y": 1272.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1398,
            "y": 1146.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 214,
            "y": 1128.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 511,
            "y": 1499.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 476,
            "y": 1416.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1201,
            "y": 1447.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1258,
            "y": 1458.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1093,
            "y": 1338.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 669,
            "y": 1366.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 668,
            "y": 1366.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 352,
            "y": 1487.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 180,
            "y": 1517.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 163,
            "y": 1399.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 72,
            "y": 1528.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 94,
            "y": 264.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 341,
            "y": 251.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 88,
            "y": 358.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 494,
            "y": 258.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 619,
            "y": 136.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 679,
            "y": 141.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 689,
            "y": 223.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 667,
            "y": 335.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 603,
            "y": 386.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 589,
            "y": 482.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 717,
            "y": 528.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 744,
            "y": 385.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 782,
            "y": 226.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 861,
            "y": 58.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 818,
            "y": 134.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 652,
            "y": 596.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 641,
            "y": 662.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 681,
            "y": 835.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 752,
            "y": 806.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 752,
            "y": 805.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 799,
            "y": 919.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 752,
            "y": 1122.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 780,
            "y": 1324.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 920,
            "y": 1335.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 862,
            "y": 1408.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 747,
            "y": 1497.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 867,
            "y": 1539.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 843,
            "y": 1293.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 876,
            "y": 1206.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 827,
            "y": 1078.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 714,
            "y": 994.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 797,
            "y": 881.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 739,
            "y": 740.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 726,
            "y": 926.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 799,
            "y": 1066.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 832,
            "y": 1270.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 945,
            "y": 1317.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 784,
            "y": 1467.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 865,
            "y": 1533.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 723,
            "y": 671.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 723,
            "y": 670.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 604,
            "y": 468.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 686,
            "y": 483.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 711,
            "y": 306.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 805,
            "y": 94.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 727,
            "y": 148.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 719,
            "y": 637.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 727,
            "y": 1250.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 752,
            "y": 1468.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 904,
            "y": 1502.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 762,
            "y": 1222.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 786,
            "y": 1009.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 800,
            "y": 853.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 687,
            "y": 791.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 673,
            "y": 421.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 600,
            "y": 575.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 744,
            "y": 51.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 744,
            "y": 50.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 883,
            "y": 67.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 369,
            "y": 1110.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 369,
            "y": 1109.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 102,
            "y": 1414.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 521,
            "y": 1466.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1328,
            "y": 1511.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1049,
            "y": 1315.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1091,
            "y": 1499.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 120,
            "y": 1224.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 597,
            "y": 1467.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 345,
            "y": 1532.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 549,
            "y": 1278.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1234,
            "y": 272.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1117,
            "y": 137.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 944,
            "y": 335.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 1409,
            "y": 305.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 998,
            "y": 301.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 195,
            "y": 323.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 318,
            "y": 98.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 501,
            "y": 84.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1227,
            "y": 141.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1175,
            "y": 278.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1176,
            "y": 276.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1118,
            "y": 1459.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1391,
            "y": 1537.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1391,
            "y": 1536.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1528,
            "y": 1435.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1144,
            "y": 1260.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 173,
            "y": 1351.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 132,
            "y": 1482.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 672,
            "y": 1062.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 711,
            "y": 837.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 682,
            "y": 689.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 757,
            "y": 583.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 758,
            "y": 583.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 758,
            "y": 711.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 855,
            "y": 1084.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 93,
            "y": 971.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 347,
            "y": 685.8125
          },
          {
            "type": "rock",
            "imageIndex": 6,
            "x": 550,
            "y": 925.8125
          },
          {
            "type": "rock",
            "imageIndex": 6,
            "x": 550,
            "y": 924.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1239,
            "y": 935.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 1194,
            "y": 642.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 915,
            "y": 633.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 1369,
            "y": 486.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 98,
            "y": 534.8125
          },
          {
            "type": "tree",
            "imageIndex": 4,
            "x": 1432,
            "y": 683.8125
          },
          {
            "type": "tree",
            "imageIndex": 4,
            "x": 1432,
            "y": 682.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 408,
            "y": 602.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 1298,
            "y": 915.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 347,
            "y": 820.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 1206,
            "y": 514.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 451,
            "y": 1038.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 450,
            "y": 1037.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 86,
            "y": 612.8125
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 1440,
            "y": 1440
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 96,
            "y": 96
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 144,
            "y": 1296
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 1392,
            "y": 144
          }
        ],
        "extensionTerrainType": 3,
        "ramps": []
      },
      "world": "shire",
      "grassShader": "grass",
      "waterShader": "water"
    },
    "level3": {
      "title": "Level 3",
      "tileMap": {
        "size": 128,
        "terrainTypes": [
          {
            "type": "water",
            "texture": "water",
            "color": "#0288d1",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "lava",
            "texture": "lava",
            "color": "#ff8c00",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "grass",
            "texture": "grass",
            "color": "#5a8a4f",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
            ],
            "buildable": true
          },
          {
            "type": "forest",
            "texture": "forest",
            "color": "#2f4a29",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
            ],
            "buildable": true
          },
          {
            "type": "rock",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": false
          }
        ],
        "terrainMap": [
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ]
        ],
        "terrainBGColor": {
          "paletteColor": "greenMColor"
        },
        "environmentObjects": [],
        "extensionTerrainType": 3,
        "ramps": []
      },
      "world": "shire",
      "grassShader": "grass",
      "waterShader": "water"
    }
  }
},
    compiled: true,
    initialized: false
};

// Helper to get collections (replaces core.getCollections() at runtime)
window.COMPILED_GAME.getCollections = function() {
    return window.COMPILED_GAME.collections;
};

// FLAG TO PREVENT DUPLICATE LIBRARY LOADING
window.COMPILED_GAME_LOADED = true;

// ========== LIBRARIES ==========

// Library: BaseSystem (non-module - inline)
// Original path: /global/libraries/js/BaseSystem.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class BaseSystem {
    constructor(game) {
        this.game = game;
        this.engine = game.app;
        this.componentTypes = this.game.componentManager.getComponentTypes();
    }
    postAllInit() {

    }
    
    update(){

    }

    render() {

    }

}

if(typeof BaseSystem != 'undefined'){
    if (typeof window !== 'undefined') {
        window.BaseSystem = BaseSystem;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = BaseSystem;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = BaseSystem;
        exports.BaseSystem = BaseSystem;
    }
}
        
        // Explicitly register classes to window
        var className = "BaseSystem";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing BaseSystem:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "BaseSystem";
    var className = "BaseSystem";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.BaseSystem = foundLibrary;
        window.engine.BaseSystem = foundLibrary;
        
    } else {
        console.warn("Could not find BaseSystem after loading");
    }
})();

// Library: GameRoom (non-module - inline)
// Original path: /global/libraries/js/GameRoom.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class GameRoom {
    constructor(engine, roomId, gameInstance, maxPlayers) {
        this.id = roomId;
        this.engine = engine;
        this.game = gameInstance;
        this.serverNetworkManager = this.engine.serverNetworkManager;
        this.game.room = this;
        this.maxPlayers = maxPlayers;
        this.players = new Map();
        this.isActive = false;
        this.lastStateSnapshot = null;
        this.stateHistory = []; // For lag compensation
        this.inputBuffer = new Map(); // Player inputs awaiting processing
    }

    addPlayer(playerId, playerData) {
        if (this.players.size >= this.maxPlayers) {
            return { success: false, reason: 'Room full' };
        }

        this.players.set(playerId, {
            id: playerId,
            ...playerData,
            lastInputSequence: 0,
            inputBuffer: [],
            latency: 0
        });


        if (this.players.size === this.maxPlayers) {
            this.startGame();
        }

        return { success: true };
    }

    removePlayer(playerId) {
        if (this.players.has(playerId)) {
            // Remove player entity from game
            this.players.delete(playerId);
            
            if (this.players.size === 0) {
                this.isActive = false;
            }
        }
    }

    getPlayer(playerId){
        return this.players.get(playerId);
    }



    startGame() {
        this.isActive = true;
        
        // Initialize game scene
        this.game.sceneManager.load(this.game.getCollections().configs.server.initialScene);

    }

    processPlayerInput(playerId, inputData) {
        const player = this.players.get(playerId);
        if (!player) return;

        // Validate input sequence to prevent replay attacks
        if (inputData.sequence <= player.lastInputSequence) {
            return;
        }

        player.lastInputSequence = inputData.sequence;
        
        // Queue input for processing
        if (!this.inputBuffer.has(playerId)) {
            this.inputBuffer.set(playerId, []);
        }
        
        this.inputBuffer.get(playerId).push({
            ...inputData,
            timestamp: Date.now()
        });
    }

    update(deltaTime) {
        if (!this.isActive) return;

        // Process all queued inputs
        this.processQueuedInputs();
        
        // Update game state
        this.game.update(deltaTime);
        
        // Store state snapshot for lag compensation
        this.storeStateSnapshot();
        
        // Prepare network update
        this.prepareNetworkUpdate();
    }

    processQueuedInputs() {
        for (const [playerId, inputs] of this.inputBuffer) {
            const player = this.players.get(playerId);
            if (!player || !player.entityId) continue;

            for (const input of inputs) {
                this.applyPlayerInput(player.entityId, input);
            }
            
            // Clear processed inputs
            inputs.length = 0;
        }
    }

    applyPlayerInput(entityId, inputData) {
        const transform = this.game.getComponent(entityId, 'Transform');
        if (!transform) return;

        const speed = 200; // pixels per second
        const deltaTime = 1/20; // Server tick rate

        // Apply movement
        if (inputData.keys.left) transform.x -= speed * deltaTime;
        if (inputData.keys.right) transform.x += speed * deltaTime;
        if (inputData.keys.up) transform.y -= speed * deltaTime;
        if (inputData.keys.down) transform.y += speed * deltaTime;

        // Validate movement (bounds checking, collision, etc.)
        this.validateMovement(entityId, transform);
    }

    validateMovement(entityId, transform) {
        // Implement game-specific validation
        // Bounds checking, collision detection, etc.
        const bounds = this.game.getCollections().configs.game.worldBounds;
        
        transform.x = Math.max(0, Math.min(bounds.width, transform.x));
        transform.y = Math.max(0, Math.min(bounds.height, transform.y));
    }

    storeStateSnapshot() {
        const snapshot = {
            timestamp: Date.now(),
            entities: new Map()
        };

        // Store relevant entity states
        for (const [playerId, player] of this.players) {
            if (player.entityId) {
                const transform = this.game.getComponent(player.entityId, 'Transform');
                const playerComp = this.game.getComponent(player.entityId, 'Player');
                
                snapshot.entities.set(player.entityId, {
                    transform: { ...transform },
                    player: { ...playerComp }
                });
            }
        }

        this.stateHistory.push(snapshot);
        
        // Keep only last 1 second of history (20 snapshots at 20 TPS)
        if (this.stateHistory.length > 20) {
            this.stateHistory.shift();
        }
    }

    prepareNetworkUpdate() {
        const gameState = {
            type: 'GAME_STATE',
            timestamp: Date.now(),
            entities: {}
        };

        // Include all network-synced entities
        for (const [playerId, player] of this.players) {
            if (player.entityId) {
                const transform = this.game.getComponent(player.entityId, 'Transform');
                const playerComp = this.game.getComponent(player.entityId, 'Player');
                
                gameState.entities[player.entityId] = {
                    playerId: playerId,
                    transform,
                    player: playerComp
                };
            }
        }

        this.lastStateSnapshot = gameState;
    }

    broadcastToPlayers(type, data) {
            console.log('broadcasting to all players', message);
        this.serverNetworkManager.broadcastToRoom(this.id, type, data);
    }
}

if(typeof GameRoom != 'undefined'){
    if (typeof window !== 'undefined') {
        window.GameRoom = GameRoom;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = GameRoom;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = GameRoom;
        exports.GameRoom = GameRoom;
    }
}
        
        // Explicitly register classes to window
        var className = "GameRoom";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing GameRoom:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "GameRoom";
    var className = "GameRoom";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.GameRoom = foundLibrary;
        window.engine.GameRoom = foundLibrary;
        
    } else {
        console.warn("Could not find GameRoom after loading");
    }
})();

// Library: ServerGameRoom (non-module - inline)
// Original path: /global/libraries/js/ServerGameRoom.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        import GameRoom from './GameRoom.js';

export default class ServerGameRoom extends GameRoom {
    constructor(engine, roomId, gameInstance, maxPlayers = 2, gameConfig = {}) {
        super(engine, roomId, gameInstance, maxPlayers);
        
        // Add multiplayer lobby functionality
        this.game.state.phase = 'waiting'; // 'waiting', 'lobby', 'playing', 'ended'
        this.gameConfig = gameConfig;
        this.createdAt = Date.now();
        this.nextRoomId = 1000;
        this.currentRoomIds = [];
        
        // Subscribe to events from network manager
        this.subscribeToEvents();
        
        console.log(`ServerGameRoom ${roomId} created for ${maxPlayers} players`);
    }

    subscribeToEvents() {
        console.log('game room subscribing to events');
        if (!this.game.serverEventManager) {
            console.error('No event manager found on engine');
            return;
        }

        // Subscribe to room management events
        this.game.serverEventManager.subscribe('QUICK_MATCH', this.handleQuickMatch.bind(this));
        this.game.serverEventManager.subscribe('LEAVE_ROOM', this.handleLeaveRoom.bind(this));
        this.game.serverEventManager.subscribe('PLAYER_DISCONNECT', this.handlePlayerDisconnect.bind(this));
        this.game.serverEventManager.subscribe('TOGGLE_READY', this.handleToggleReady.bind(this));
    }



    handleQuickMatch(eventData) {
        const { playerId, data } = eventData;
        
        try {
            const { playerName } = data;
            
            // Find available room
            let availableRoom = null;
            for (const [roomId, room] of this.engine.gameRooms) {
                if ((this.game.state.phase === 'waiting' || this.game.state.phase === 'lobby') && 
                    room.players.size < room.maxPlayers) {
                    availableRoom = room;
                    break;
                }
            }
            
            if (!availableRoom) {
                // Create new room for quick match
                const roomId = this.generateRoomId();
                availableRoom = this.engine.createGameRoom(roomId, 2);
            }
            
            if (!availableRoom) {
                this.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FAILED', { 
                    error: 'Failed to create or find room' 
                });
                return;
            }

            const result = availableRoom.addPlayer(playerId, {
                name: playerName || `Player ${playerId.substr(-4)}`,
                isHost: availableRoom.players.size === 0
            });

            if (result.success) {
                this.serverNetworkManager.joinRoom(playerId, availableRoom.id);
                
                this.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FOUND', {
                    roomId: availableRoom.id,
                    playerId: playerId,
                    isHost: availableRoom.players.size === 1,
                    gameState: availableRoom.getGameState()
                });
                
                // Notify other players in room
                this.serverNetworkManager.broadcastToRoom(availableRoom.id, 'PLAYER_JOINED', {
                    playerId: playerId,
                    playerName: playerName,
                    gameState: availableRoom.getGameState()
                });
                
                console.log(`Player ${playerName} quick-matched into room ${availableRoom.id}`);
            } else {
                this.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FAILED', { 
                    error: result.error || result.reason || 'Failed to find match' 
                });
            }
        } catch (error) {
            console.error('Error in quick match:', error);
            this.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FAILED', { 
                error: 'Server error during quick match' 
            });
        }
    }

    handleToggleReady(eventData) {
        const { playerId } = eventData;
        try {
            const success = this.togglePlayerReady(playerId);
            if (!success) {
                this.serverNetworkManager.sendToPlayer(playerId, 'ERROR', { 
                    error: 'Cannot toggle ready in current phase' 
                });
            }
        } catch (error) {
            console.error('Error toggling ready:', error);
            this.serverNetworkManager.sendToPlayer(playerId, 'ERROR', { 
                error: 'Server error' 
            });
        }
    }

    handlePlayerDisconnect(eventData) {
        const { playerId } = eventData;
        console.log(`Player ${playerId} disconnected`);
        
        // Get the room the player was in
        const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
        if (roomId) {
            const room = this.engine.gameRooms.get(roomId);
            if (room) {
                // Get player data before removing
                const player = room.players.get(playerId);
                const playerName = player?.name || 'Unknown';
                
                // Notify other players
                this.serverNetworkManager.broadcastToRoom(roomId, 'PLAYER_LEFT', {
                    playerId: playerId,
                    playerName: playerName
                });
                
                // Clean up player state completely
                this.cleanupPlayerState(room, playerId);
                
                // Remove from room
                room.removePlayer(playerId);
                this.serverNetworkManager.leaveRoom(playerId, roomId);

                
                // Clean up empty rooms
                if (room.players.size === 0) {
                    this.cleanupRoom(room);
                    this.engine.gameRooms.delete(roomId);
                    console.log(`Removed empty room ${roomId}`);
                } else {
                    // If room still has players, reset their states for next game
                    this.resetPlayersForNextGame(room);
                }
            }
        }
        
        // Clean up network manager state
        this.serverNetworkManager.playerSockets.delete(playerId);
    }

    handleLeaveRoom(eventData) {
        const { playerId } = eventData;
        
        // Use the same cleanup logic as disconnect
        this.handlePlayerDisconnect(eventData);
    }

    cleanupPlayerState(room, playerId) {
        const player = room.players.get(playerId);
        if (!player) return;
        
        // Clear any placement data
        if (room.game && room.game.placementSystem) {
            room.game.placementSystem.clearPlayerPlacements(playerId);
        }
        
        // Clear any battle data
        if (room.game && room.game.battlePhaseSystem) {
            const battleSystem = room.game.battlePhaseSystem;
            if (battleSystem.createdSquads) {
                battleSystem.createdSquads.delete(playerId);
            }
            if (battleSystem.battleResults) {
                battleSystem.battleResults.delete(playerId);
            }
        }
        
        // Clear any entities owned by this player
        if (room.game && room.game.componentManager) {
            const ComponentTypes = room.game.componentManager.getComponentTypes();
            const playerEntities = room.game.getEntitiesWith(ComponentTypes.PLAYER_OWNED)
                .filter(entityId => {
                    const ownerComp = room.game.getComponent(entityId, ComponentTypes.PLAYER_OWNED);
                    return ownerComp && ownerComp.playerId === playerId;
                });
            
            playerEntities.forEach(entityId => {
                try {
                    room.game.destroyEntity(entityId);
                } catch (error) {
                    console.warn(`Error destroying player entity ${entityId}:`, error);
                }
            });
        }
    }

    // Override parent's auto-start behavior to add lobby phase
    addPlayer(playerId, playerData) {
        const result = super.addPlayer(playerId, playerData);
        
        if (result.success) {
            // Add multiplayer-specific player properties
            const player = this.players.get(playerId);
            player.ready = false;
            player.placementReady = false;
            player.isHost = playerData.isHost || false;
            
            player.stats = {
                health: this.game.state.teamMaxHealth,                
                gold: this.game.state.startingGold,
                side: playerData.isHost ? 'left' : 'right',
                upgrades: []
            };
            // If room is full, enter lobby phase (don't auto-start like parent does)
            if (this.players.size === this.maxPlayers && this.game.state.phase === 'waiting') {
                this.enterLobbyPhase();
            }
        }
        
        return result;
    }

    enterLobbyPhase() {
        this.game.state.phase = 'lobby';
        
        // Broadcast lobby entered to all players in room
        if (this.serverNetworkManager) {
            this.serverNetworkManager.broadcastToRoom(this.id, 'LOBBY_ENTERED', {
                gameState: this.getGameState()
            });
        }
        
        console.log(`Room ${this.id} entered lobby phase`);
    }

    togglePlayerReady(playerId) {
        const player = this.players.get(playerId);
        if (!player || (this.game.state.phase !== 'lobby' && this.game.state.phase !== 'waiting')) {
            console.log("no player or not in lobby/waiting phase", this.game.state.phase);
            return false;
        }
        
        player.ready = !player.ready;
        
        const allReady = Array.from(this.players.values()).every(p => p.ready);
        
        // Broadcast ready state update
        if (this.serverNetworkManager) {
            this.serverNetworkManager.broadcastToRoom(this.id, 'PLAYER_READY_UPDATE', {
                playerId: playerId,
                ready: player.ready,
                allReady: allReady,
                gameState: this.getGameState()
            });
        }
        
        // Auto-start if all ready
        if (allReady) {
            setTimeout(() => this.startGame(), 1000);
        }
        
        return true;
    }

    // Override parent's startGame to add multiplayer lobby logic
    startGame() {
        if (this.game.state.phase !== 'lobby') {
            console.log(`Cannot start game, not in lobby phase. Current phase: ${this.game.state.phase}`);
            return false;
        }
        
        // Check if all players are ready
        const allReady = Array.from(this.players.values()).every(p => p.ready);
        if (!allReady) {
            return false;
        }
        
        this.game.state.phase = 'placement';
        
        // Call parent's startGame (loads scene, spawns entities, etc.)
        super.startGame();
        
        // Broadcast game started
        if (this.serverNetworkManager) {
            let gameState = this.getGameState();
            this.serverNetworkManager.broadcastToRoom(this.id, 'GAME_STARTED', {
                gameState: gameState
            });            
        }
        
        console.log(`Game started in room ${this.id}`);
        return true;
    }

    // Enhanced game state for multiplayer
    getGameState() {
        let players = Array.from(this.players.values());
        let playerData = [];
        players.forEach((p) => {
            let placements = null;
            if(this.game.placementSystem){
                placements = this.game.placementSystem.playerPlacements.get(p.id);
            }

            if(this.game.squadExperienceSystem && placements){                
                placements.forEach((placement) => {
                    placement.experience = this.game.squadExperienceSystem.getSquadInfo(placement.placementId)
                });
            }
            playerData.push({
                id: p.id,
                name: p.name,
                ready: p.ready || false,
                isHost: p.isHost || false,
                stats: p.stats,
                placements: placements || [],
                entityId: p.entityId,
                lastInputSequence: p.lastInputSequence || 0,
                latency: p.latency || 0
            });
        });
        return {
            roomId: this.id,
            phase: this.game.state.phase,
            isActive: this.isActive,
            maxPlayers: this.maxPlayers,
            gameType: this.gameConfig?.type || 'default',
            players: playerData,
            round: this.game.state.round,
            // Let the game instance provide additional state if needed
            gameData: this.game.getGameState ? this.game.getGameState() : null
        };
    }

    generateRoomId() {
        let id;
        do {
            id = this.nextRoomId++;
            if (this.nextRoomId > 9999) {
                this.nextRoomId = 1000;
            }
        } while (this.currentRoomIds.includes(id.toString()));
        
        this.currentRoomIds.push(id.toString());
        return id.toString();
    }


    // NEW METHOD: Reset all remaining players for next game
    resetPlayersForNextGame(room) {
        for (const [playerId, player] of room.players) {
            // Reset player stats to initial values
            player.stats = {
                health: this.game.state.teamMaxHealth,
                gold: this.game.state.startingGold,
                side: player.stats.side // Keep their side assignment
            };
            
            // Reset ready states
            player.ready = false;
            player.placementReady = false;
            
            console.log(`Reset player ${playerId} stats:`, player.stats);
        }
        
        // Broadcast updated game state
        this.serverNetworkManager.broadcastToRoom(room.id, 'GAME_STATE_UPDATE', {
            gameState: room.getGameState()
        });
    }

    // NEW METHOD: Complete room cleanup
    cleanupRoom(room) {
        try {
            // Clear all game systems
            if (room.game) {                
                room.game.triggerEvent('dispose');
            }
            // Remove room ID from tracking
            const roomIndex = this.currentRoomIds.indexOf(room.id);
            if (roomIndex > -1) {
                this.currentRoomIds.splice(roomIndex, 1);
            }
            
        } catch (error) {
            console.error('Error during room cleanup:', error);
        }
    }
}

        
        // Explicitly register classes to window
        var className = "ServerGameRoom";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ServerGameRoom:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ServerGameRoom";
    var className = "ServerGameRoom";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ServerGameRoom = foundLibrary;
        window.engine.ServerGameRoom = foundLibrary;
        
    } else {
        console.warn("Could not find ServerGameRoom after loading");
    }
})();

// Library: GameState (non-module - inline)
// Original path: /global/libraries/js/GameState.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class GameState {
    constructor(gameConfig = {}) {
        this.collections = gameConfig;
        let state = gameConfig.configs?.state;
     
        // Clear all existing properties
        for (let prop in this) {
            if (Object.prototype.hasOwnProperty.call(this, prop)) {
                delete this[prop];
            }
        }

        // Set only the properties from params
        for (let key in state) {
            if (Object.prototype.hasOwnProperty.call(state, key)) {
                this[key] = state[key];
            }
        }
        // If stats is present, create defaultStats as a copy
  
    }
}

if(typeof GameState != 'undefined'){
    if (typeof window !== 'undefined') {
        window.GameState = GameState;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = GameState;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = GameState;
        exports.GameState = GameState;
    }
}
        
        // Explicitly register classes to window
        var className = "GameState";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing GameState:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "GameState";
    var className = "GameState";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.GameState = foundLibrary;
        window.engine.GameState = foundLibrary;
        
    } else {
        console.warn("Could not find GameState after loading");
    }
})();

// Library: BaseECSGame (non-module - inline)
// Original path: /global/libraries/js/BaseECSGame.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class BaseECSGame {
    constructor(app) {
        this.app = app;
        this.state = null; // Will be set by subclasses
        this.sceneManager = null; // Will be set by subclasses
        this.moduleManager = app.moduleManager;
        
        this.entityId = 0;
        this.entitiesToAdd = [];
        this.entities = new Map();
        this.components = new Map();
        this.classes = [];
        this.systems = [];
        
        this.nextEntityId = 1;
        this.lastTime = 0;
        this.currentTime = 0;
        this.deltaTime = 0;

        this.isServer = false;        

        this.componentTypes = null;
    }
    init() {
        if(document){
            document.addEventListener('keydown', (e) => {                
                this.triggerEvent('onKeyDown', e.key);
            });
        }
    }
    getEntityId() {
        return this.nextEntityId++;
    }
    getCollections() {
        return this.app.getCollections();
    }

    async update(deltaTime) {
  
        if (!this.state.isPaused) {
            this.currentTime = this.currentTime + deltaTime;

            // Only update if a reasonable amount of time has passed
            // const timeSinceLastUpdate = this.currentTime - this.lastTime;

            // // Skip update if more than 1 second has passed (tab was inactive)
            // if (timeSinceLastUpdate > 1000) {
            //     this.lastTime = this.currentTime; // Reset timer without updating
            //     return;
            // }
            this.state.now = this.currentTime;
            this.state.deltaTime = deltaTime;
            this.deltaTime = deltaTime;        

            this.systems.forEach(async system => {
                if (system.update) {
                    await system.update();
                }
                if(system.render && !this.isServer){
                    await system.render();
                }
            });
            
            this.postUpdate();
        }     
    }

    postUpdate() {
       // this.desyncDebugger?.displaySync(false); 
       
        this.lastTime = this.currentTime;
    
        this.entitiesToAdd.forEach((entity) => this.addEntity(entity));        
        this.entitiesToAdd = [];
        
    }

    createEntity(setId) {
        const id = setId || this.getEntityId();
        this.entities.set(id, new Set());
        return id;
    }
    
    destroyEntity(entityId) {
        if (this.entities.has(entityId)) {

            this.systems.forEach(system => {
                if (system.entityDestroyed) {
                    system.entityDestroyed(entityId);                    
                }
            });

            const componentTypes = this.entities.get(entityId);
            componentTypes.forEach(type => {
                this.removeComponent(entityId, type);
            });
            this.entities.delete(entityId);
        }
    }
    
    addComponent(entityId, componentId, componentData) {
        if (!this.entities.has(entityId)) {
            throw new Error(`Entity ${entityId} does not exist`);
        }
        
        if (!this.components.has(componentId)) {
            this.components.set(componentId, new Map());
        }
        
        this.components.get(componentId).set(entityId, componentData);
        this.entities.get(entityId).add(componentId);
    }
    
    removeComponent(entityId, componentType) {
        let component = this.getComponent(entityId, componentType);
        if (this.components.has(componentType)) {
            this.components.get(componentType).delete(entityId);
        }
        if (this.entities.has(entityId)) {
            this.entities.get(entityId).delete(componentType);
        }
        return component;
    }
    
    getComponent(entityId, componentType) {
        if (this.components.has(componentType)) {
            return this.components.get(componentType).get(entityId);
        }
        return null;
    }
    
    hasComponent(entityId, componentType) {
        return this.components.has(componentType) && 
                this.components.get(componentType).has(entityId);
    }
    
    getEntitiesWith(...componentTypes) {
        const result = [];
        for (const [entityId, entityComponents] of this.entities) {
            if (componentTypes.every(type => entityComponents.has(type))) {
                result.push(entityId);
            }
        }
        return result.sort((a, b) => String(a).localeCompare(String(b)));
    }
    
    addSystem(system, params) {
        system.game = this;
        this.systems.push(system);
        if (system.init) {
            system.init(params);
        }
    }

    addClass(classId, classRef, params) {
        this.classes[classId] = { classRef: classRef, defaultParams: params };
        this.app.appClasses[classId] = classRef;
    }


    triggerEvent(eventName, data) {
        this.systems.forEach(system => {
            if (system[eventName]) {
                system[eventName](data);
            }
        });
    }

    gameOver() {
        this.state.gameOver = true;
    }

    gameVictory() {
        this.state.victory = true;
    }
    resetCurrentTime() {
        this.state.now = 0;
        this.lastTime = 0;
        this.currentTime = 0;     
    }
}

if(typeof BaseECSGame != 'undefined'){
    if (typeof window !== 'undefined') {
        window.BaseECSGame = BaseECSGame;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = BaseECSGame;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = BaseECSGame;
        exports.BaseECSGame = BaseECSGame;
    }
}
        
        // Explicitly register classes to window
        var className = "BaseECSGame";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing BaseECSGame:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "BaseECSGame";
    var className = "BaseECSGame";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.BaseECSGame = foundLibrary;
        window.engine.BaseECSGame = foundLibrary;
        
    } else {
        console.warn("Could not find BaseECSGame after loading");
    }
})();

// Library: GameUtils (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameUtils.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class GameUtils {
    static DEFAULT_UNIT_RADIUS = 25;
    static MIN_MOVEMENT_THRESHOLD = 0.1;
    
    static getUnitRadius(collision) {
        return collision?.radius ? Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius) : this.DEFAULT_UNIT_RADIUS;
    }
    
    static calculateDistance(pos1, pos2, collision1 = null, collision2 = null) {
        const dx = pos2.x - pos1.x;
        const dz = pos2.z - pos2.z;
        const centerDistance = Math.sqrt(dx * dx + dz * dz);
        
        if (!collision1 || !collision2) return centerDistance;
        
        const radius1 = this.getUnitRadius(collision1);
        const radius2 = this.getUnitRadius(collision2);
        
        return {
            center: centerDistance,
            edge: Math.max(0, centerDistance - radius1 - radius2),
            toTargetEdge: Math.max(0, centerDistance - radius2)
        };
    }
    
    static lerp(a, b, t) {
        return a + (b - a) * t;
    }    
}
        
        // Explicitly register classes to window
        var className = "GameUtils";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing GameUtils:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "GameUtils";
    var className = "GameUtils";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.GameUtils = foundLibrary;
        window.engine.GameUtils = foundLibrary;
        
    } else {
        console.warn("Could not find GameUtils after loading");
    }
})();

// Library: ServerECSGame (non-module - inline)
// Original path: /global/libraries/js/ServerECSGame.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class ServerECSGame extends global.GUTS.BaseECSGame {
    constructor(app) {
        super(app);
        this.state = new global.GUTS.GameState(this.getCollections());
        this.sceneManager = new global.GUTS.ServerSceneManager(this);
        this.moduleManager = app.moduleManager;
        this.desyncDebugger = new global.GUTS.DesyncDebugger(this);        
        this.serverEventManager = new global.GUTS.ServerEventManager(this);
        this.isServer = true;
    }


}
      
if(typeof ServerECSGame != 'undefined'){
    if (typeof window !== 'undefined') {
        window.ServerECSGame = ServerECSGame;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = ServerECSGame;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = ServerECSGame;
        exports.ServerECSGame = ServerECSGame;
    }
}
        
        // Explicitly register classes to window
        var className = "ServerECSGame";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ServerECSGame:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ServerECSGame";
    var className = "ServerECSGame";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ServerECSGame = foundLibrary;
        window.engine.ServerECSGame = foundLibrary;
        
    } else {
        console.warn("Could not find ServerECSGame after loading");
    }
})();

// Library: ServerEventManager (non-module - inline)
// Original path: /global/libraries/js/ServerEventManager.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        export default class ServerEventManager {
    constructor(engine) {
        this.engine = engine;
        this.listeners = new Map(); // eventType -> [callbacks]
    }
    
    subscribe(eventType, callback) {
        console.log("subscribing", eventType);
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, []);
        }
        this.listeners.get(eventType).push(callback);
    }
    
    emit(eventType, data) {
        const callbacks = this.listeners.get(eventType) || [];
        const results = [];
        for (const callback of callbacks) {
            try {
                const result = callback(data);
                if (result) results.push(result);
            } catch (error) {
                console.error(`Event handler error for ${eventType}:`, error);
            }
        }
        return results;
    }
}
        
        // Explicitly register classes to window
        var className = "ServerEventManager";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ServerEventManager:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ServerEventManager";
    var className = "ServerEventManager";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ServerEventManager = foundLibrary;
        window.engine.ServerEventManager = foundLibrary;
        
    } else {
        console.warn("Could not find ServerEventManager after loading");
    }
})();

// Library: ServerNetworkManager (non-module - inline)
// Original path: /global/libraries/js/ServerNetworkManager.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        export default class ServerNetworkManager {
    constructor(engine) {
        this.engine = engine;
        this.io = null;
        this.playerSockets = new Map();
        this.nextRoomId = 1000; // Starting room code
        this.currentRoomIds = [];
        this._initialized = false;
    }

    async init() {
        if (this._initialized) return;

        if (!this.io) {
            const g = (typeof globalThis !== 'undefined' ? globalThis : global);
            if (g && (g.io || g._io)) {
                this.io = g.io || g._io;
            }
        }

        if (!this.io) {
            const { Server } = await import('socket.io');
            this.io = new Server({
                cors: {
                    origin: "*",
                    methods: ["GET", "POST"]
                }
            });
            this.io.listen(3001);
            console.log('Socket.IO fallback listening on port 3001');
        }

        this.setupEventHandlers();
        this._initialized = true;
        console.log('ServerNetworkManager initialized');
    }

    setupEventHandlers() {
        this.io.removeAllListeners('connection');

        this.io.on('connection', (socket) => {

            console.log('Player connected:', socket.id);

            this.playerSockets.set(socket.id, { socket });

            socket.on('CREATE_ROOM', (data) => {
                this.handleCreateRoom(socket, data);
            });
            socket.on('JOIN_ROOM', (data) => {
                this.handleJoinRoom(socket, data);
            });
            // Catch ALL events and route to game systems
            socket.onAny((eventName, data) => {
                // Skip internal socket.io events
                if (eventName.startsWith('__') || eventName === 'disconnect') {
                    return;
                }
                
                this.routeEventToEngine(socket, eventName, data);
            });

            socket.on('disconnect', () => {
                console.log('Player disconnected:', socket.id);
                this.routeEventToEngine(socket, 'PLAYER_DISCONNECT', { playerId: socket.id });
                this.playerSockets.delete(socket.id);
            });

            socket.emit('CONNECTED', { 
                playerId: socket.id,
                serverTime: Date.now() 
            });
        });
    }

    handleCreateRoom(socket, data) {
        try {
            const { playerName, maxPlayers = 2 } = data;
            
            // Generate room code
            const roomId = this.generateRoomId();            
            
            // Create new game room using the engine's method
            const room = this.engine.createGameRoom(roomId, maxPlayers);
            
            const result = room.addPlayer(socket.id, {
                name: playerName || `Player ${socket.id.substr(-4)}`,
                socket: socket,
                isHost: true
            });

            if (result.success) {
                this.currentRoomIds.push(roomId);
                this.playerSockets.set(socket.id, { 
                    socket, 
                    roomId,
                    isHost: true 
                });
                socket.join(roomId);
                
                socket.emit('ROOM_CREATED', {
                    roomId: roomId,
                    playerId: socket.id,
                    isHost: true,
                    gameState: room.getGameState()
                });
                
                console.log(`Player ${playerName} created room ${roomId}`);
            } else {
                socket.emit('CREATE_ROOM_FAILED', { 
                    error: result.error || 'Failed to create room' 
                });
            }
        } catch (error) {
            console.error('Error creating room:', error);
            socket.emit('CREATE_ROOM_FAILED', { 
                error: 'Server error while creating room' 
            });
        }
    }


    handleJoinRoom(socket, data) {
        
        const playerId = socket.id;
        console.log('joinRoom', data)
        try {
            const { roomId, playerName } = data;
            
            if (!roomId) {
                this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { 
                    error: 'Room code required' 
                });
                return;
            }
            
            const room = this.engine.gameRooms.get(roomId);
            if (!room) {
                this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { 
                    error: 'Room not found' 
                });
                return;
            }
            
            // Check if room allows joining
            if (room.game.state.phase !== 'waiting' && room.game.state.phase !== 'lobby') {
                this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { 
                    error: 'Game already in progress' 
                });
                return;
            }

            const result = room.addPlayer(playerId, {
                name: playerName || `Player ${playerId.substr(-4)}`,
                isHost: false
            });

            if (result.success) {
                this.joinRoom(playerId, roomId);
                
                this.sendToPlayer(playerId, 'ROOM_JOINED', {
                    roomId: roomId,
                    playerId: playerId,
                    isHost: false,
                    gameState: room.getGameState()
                });
                
                // Notify other players
                this.broadcastToRoom(roomId, 'PLAYER_JOINED', {
                    playerId: playerId,
                    playerName: playerName,
                    gameState: room.getGameState()
                });
                
                console.log(`Player ${playerName} joined room ${roomId}`);
            } else {
                this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { 
                    error: result.error || result.reason || 'Failed to join room' 
                });
            }
        } catch (error) {
            console.error('Error joining room:', error);
            this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { 
                error: 'Server error while joining room' 
            });
        }
    }

    generateRoomId() {
        let id;
        do {
            id = this.nextRoomId++;
            if (this.nextRoomId > 9999) {
                this.nextRoomId = 1000; // Reset to avoid very long codes
            }
        } while (this.currentRoomIds.includes(id.toString()));
        
        return id.toString();
    }

    // Generic event routing - just forwards to appropriate room's event manager
    routeEventToEngine(socket, eventName, data) {
        const playerId = socket.id;
        const roomId = this.getPlayerRoom(playerId);
        
        try {
            // For player-specific events, route to their room's event manager
            if (roomId) {
                const room = this.engine.gameRooms.get(roomId);
                if (room && room.game.serverEventManager) {
                    room.game.serverEventManager.emit(eventName, {
                        playerId: playerId,
                        eventName: eventName,
                        data: data,
                        socket: socket,
                        networkManager: this
                    });
                    return;
                }
            }
                        
            console.warn(`No room found for event ${eventName} from player ${playerId}`);
            
        } catch (error) {
            console.error(`Error routing event ${eventName}:`, error);
        }
    }


    // Helper methods for systems to use
    sendToPlayer(playerId, eventName, data) {
        const playerData = this.playerSockets.get(playerId);
        if (playerData && playerData.socket) {
            playerData.socket.emit(eventName, data);
        }
    }

    broadcastToRoom(roomId, eventName, data) {
        this.io.to(roomId).emit(eventName, data);
    }

    joinRoom(playerId, roomId) {
        const playerData = this.playerSockets.get(playerId);
        if (playerData && playerData.socket) {
            playerData.socket.join(roomId);
            playerData.roomId = roomId;
        }
    }

    leaveRoom(playerId, roomId) {
        const playerData = this.playerSockets.get(playerId);
        if (playerData && playerData.socket) {
            playerData.socket.leave(roomId);
            delete playerData.roomId;
        }
    }

    getPlayerRoom(playerId) {
        const playerData = this.playerSockets.get(playerId);
        return playerData?.roomId;
    }

    broadcastGameStates() {
        for (const [roomId, room] of this.engine.gameRooms) {
            if (room.isActive && room.lastStateSnapshot) {
                this.io.to(roomId).emit('GAME_STATE_UPDATE', room.lastStateSnapshot);
            }
        }
    }

    getServerStats() {
        return {
            connectedPlayers: this.playerSockets.size
        };
    }

    cleanup() {
        this.playerSockets.clear();
        console.log('ServerNetworkManager cleaned up');
    }
}

        
        // Explicitly register classes to window
        var className = "ServerNetworkManager";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ServerNetworkManager:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ServerNetworkManager";
    var className = "ServerNetworkManager";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ServerNetworkManager = foundLibrary;
        window.engine.ServerNetworkManager = foundLibrary;
        
    } else {
        console.warn("Could not find ServerNetworkManager after loading");
    }
})();

// Library: ServerSceneManager (non-module - inline)
// Original path: /global/libraries/js/ServerSceneManager.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        export default class ServerSceneManager {
    constructor(game) {
        this.game = game;
        this.game.state.currentScene = null;
        this.currentSceneData = null;
        this.currentSceneName = null;
    }

    load(sceneName) {
        console.log("load scene", sceneName);
        this.currentSceneName = sceneName;
        this.currentSceneData = this.game.getCollections().scenes[this.currentSceneName];

        if (this.currentSceneData.type === "ECS") {
            return this.loadECS();
        }

        console.log(`Loaded server scene: ${sceneName}`);
    }

    loadECS() {
        const sceneEntities = this.currentSceneData.sceneData;
        
        sceneEntities.forEach(async (sceneEntity) => {
            // Load classes
            sceneEntity.classes.forEach((sceneClassDef) => {
                const collectionName = sceneClassDef.collection;
                const baseClassId = sceneClassDef.baseClass;
                const classCollection = this.game.getCollections()[collectionName];
                
                if (baseClassId) {
                    const collectionClassDef = classCollection[baseClassId];
                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters };
                    const BaseClassDef = this.game.moduleManager.getCompiledScript(baseClassId, collectionName);
                    this.game.addClass(baseClassId, BaseClassDef, params);
                }
                
                for (const collectionClassId in classCollection) {
                    if (baseClassId && collectionClassId === baseClassId) continue;
                    
                    const collectionClassDef = classCollection[collectionClassId];
                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters };
                    const ClassDef = this.game.moduleManager.getCompiledScript(collectionClassId, collectionName);
                    this.game.addClass(collectionClassId, ClassDef, params);
                }
            });

            // Load managers (no canvas needed)
            sceneEntity.managers.forEach((managerDef) => {
                let params = { ...managerDef.parameters };
                const ManagerClass = this.game.moduleManager.getCompiledScript(managerDef.type, 'managers');
                const managerInst = new ManagerClass(this.game, true);
                if (managerInst.init) {
                    managerInst.init(params);
                }
            });

            // Load systems (server-specific systems only)
            sceneEntity.systems.forEach((systemDef) => {
                let params = { ...systemDef.parameters };
                const SystemClass = this.game.moduleManager.getCompiledScript(systemDef.type, 'systems');
                const systemInst = new SystemClass(this.game, true);
                this.game.addSystem(systemInst, params);
            });
        });
    }
}
        
        // Explicitly register classes to window
        var className = "ServerSceneManager";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ServerSceneManager:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ServerSceneManager";
    var className = "ServerSceneManager";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ServerSceneManager = foundLibrary;
        window.engine.ServerSceneManager = foundLibrary;
        
    } else {
        console.warn("Could not find ServerSceneManager after loading");
    }
})();

// Library: SeededRandom (non-module - inline)
// Original path: /global/libraries/js/SeededRandom.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class SeededRandom {
    constructor(seed) {
        this.seed = seed;
        this.current = seed;
    }
    
    next() {
        this.current = (this.current * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.current / Math.pow(2, 32);
    }
    
    range(min, max) {
        return min + this.next() * (max - min);
    }
    
    int(min, max) {
        return Math.floor(this.range(min, max + 1));
    }
}

if(typeof SeededRandom != 'undefined'){
    if (typeof window !== 'undefined') {
        window.SeededRandom = SeededRandom;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = SeededRandom;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = SeededRandom;
        exports.SeededRandom = SeededRandom;
    }
}
        
        // Explicitly register classes to window
        var className = "SeededRandom";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing SeededRandom:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "SeededRandom";
    var className = "SeededRandom";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.SeededRandom = foundLibrary;
        window.engine.SeededRandom = foundLibrary;
        
    } else {
        console.warn("Could not find SeededRandom after loading");
    }
})();

// Library: MinHeap (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/MinHeap.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(item) {
        this.heap.push(item);
        this.bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown(0);
        return min;
    }
    
    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index].f >= this.heap[parentIndex].f) break;
            
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }
    
    bubbleDown(index) {
        while (true) {
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;
            let smallest = index;
            
            if (leftChild < this.heap.length && this.heap[leftChild].f < this.heap[smallest].f) {
                smallest = leftChild;
            }
            
            if (rightChild < this.heap.length && this.heap[rightChild].f < this.heap[smallest].f) {
                smallest = rightChild;
            }
            
            if (smallest === index) break;
            
            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
            index = smallest;
        }
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
}

if(typeof MinHeap != 'undefined'){
        
    if (typeof window !== 'undefined') {
        window.MinHeap = MinHeap;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = MinHeap;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = MinHeap;
        exports.MinHeap = MinHeap;
    }
}
        
        // Explicitly register classes to window
        var className = "MinHeap";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing MinHeap:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "MinHeap";
    var className = "MinHeap";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.MinHeap = foundLibrary;
        window.engine.MinHeap = foundLibrary;
        
    } else {
        console.warn("Could not find MinHeap after loading");
    }
})();

// Library: DesyncDebugger (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/DesyncDebugger.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class DesyncDebugger {
    constructor(game) {
        this.game = game;
        this.game.desyncDebugger = this;
        this.frameHashes = [];
        this.lastDisplayTime = 0;
        this.logInterval = 0; // Log every 1 sec
        this.detailedLogging = true;
        this.enabled = false;
    }
    displaySync(detailed) {    
        if(this.enabled){
            const entities = this.game.getEntitiesWith(
                this.game.componentManager.getComponentTypes().POSITION,
                this.game.componentManager.getComponentTypes().COMBAT
            );
            // Create deterministic state snapshot
            const stateData = this.createStateSnapshot(entities);
            const hash = this.hash(stateData);
            
            this.frameHashes.push({
                hash: hash,
                entityCount: entities.length,
                stateData: stateData,
                time: this.game.state.now
            });   
            if(this.game.isServer){
                console.log(this.game.state.now, hash);                    
            } else {
                console.log(this.game.state.now, hash, stateData);                    
            }
        }
    }

    createStateSnapshot(entities) {
        const CT = this.game.componentManager.getComponentTypes();
        
        const snapshot = {
            gameTime: parseFloat(this.game.state.now.toFixed(6)), // Round to avoid float precision issues
            entities: []
        };

        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, CT.POSITION);
            const vel = this.game.getComponent(entityId, CT.VELOCITY);
            const combat = this.game.getComponent(entityId, CT.COMBAT);
            const health = this.game.getComponent(entityId, CT.HEALTH);
            const aiState = this.game.getComponent(entityId, CT.AI_STATE);

            const entityData = {
                id: String(entityId),
                pos: `${this.hash(pos ? {
                    x: parseFloat(pos.x.toFixed(3)),
                    y: parseFloat(pos.y.toFixed(3)),
                    z: parseFloat(pos.z.toFixed(3))
                } : null)} ${pos.x}, ${pos.y}, ${pos.z}`,
                vel: `${this.hash(vel ? {
                    vx: parseFloat(vel.vx.toFixed(3)),
                    vy: parseFloat(vel.vy.toFixed(3)),
                    vz: parseFloat(vel.vz.toFixed(3))
                } : null)} ${vel?.vx || 0}, ${vel?.vy || 0}, ${vel?.vz || 0}`,
                healthHash: this.hash(health ? {
                    current: health.current,
                    max: health.max
                } : null),
                combatHash: this.hash(combat ? {
                    lastAttack: parseFloat(combat.lastAttack.toFixed(6)),
                    damage: combat.damage,
                    attackSpeed: combat.attackSpeed
                } : null),
                aiStateHash: this.hash(aiState ? {
                    state: aiState.state,
                    controller: aiState.aiControllerId,
                    targetPosition: aiState.targetPosition || 'null',
                    target: aiState.target || 'null'
                } : null),
                aiState: JSON.stringify(aiState)
            };

            snapshot.entities.push(entityData);
        });

        return snapshot;
    }

    hash(data) {
        // Simple hash function for state comparison
        const str = JSON.stringify(data);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash;
    }

    // Compare with another client's hashes
    compareHashes(otherClientHashes) {
        const mismatches = [];
        
        for (let i = 0; i < Math.min(this.frameHashes.length, otherClientHashes.length); i++) {
            const myFrame = this.frameHashes[i];
            const otherFrame = otherClientHashes[i];
            
            if (myFrame.hash !== otherFrame.hash) {
                mismatches.push({
                    frame: myFrame.frame,
                    myHash: myFrame.hash,
                    otherHash: otherFrame.hash,
                    myTime: myFrame.time,
                    otherTime: otherFrame.time,
                    myEntities: myFrame.entityCount,
                    otherEntities: otherFrame.entityCount
                });
            }
        }
        
        return mismatches;
    }

    enableDetailedLogging() {
        this.detailedLogging = true;
        console.log("Detailed desync logging enabled");
    }

    disableDetailedLogging() {
        this.detailedLogging = false;
        console.log("Detailed desync logging disabled");
    }

    // Get the last N frame hashes for comparison
    getRecentHashes(count = 10) {
        return this.frameHashes.slice(-count);
    }

    // Check for common desync patterns
    analyzeDesyncPatterns() {
        if (this.frameHashes.length < 10) return;

        const recent = this.frameHashes.slice(-10);
        const patterns = {
            stableHashes: new Set(recent.map(f => f.hash)).size === 1,
            increasingEntityCount: recent[recent.length - 1].entityCount > recent[0].entityCount,
            decreasingEntityCount: recent[recent.length - 1].entityCount < recent[0].entityCount,
            timeIncreasingMonotonically: recent.every((frame, i) => i === 0 || frame.time > recent[i-1].time)
        };

        console.log("Desync Analysis:", patterns);
        return patterns;
    }
}

if(typeof DesyncDebugger != 'undefined'){

    if (typeof window !== 'undefined') {
        window.DesyncDebugger = DesyncDebugger;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = DesyncDebugger;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = DesyncDebugger;
        exports.DesyncDebugger = DesyncDebugger;
    }
}
        
        // Explicitly register classes to window
        var className = "DesyncDebugger";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing DesyncDebugger:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "DesyncDebugger";
    var className = "DesyncDebugger";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.DesyncDebugger = foundLibrary;
        window.engine.DesyncDebugger = foundLibrary;
        
    } else {
        console.warn("Could not find DesyncDebugger after loading");
    }
})();

// ========== GAME CLASSES ==========

// ========== Functions ==========

// ========== Managers ==========

// manager: ComponentManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ComponentManager'] = class ComponentManager {
    constructor(game) {
        this.game = game;
        this.game.componentManager = this;
        this.models = this.game.getCollections().models;        
        this.game.componentTypes = this.getComponentTypes();
        //this.models.position == { x: 0, y: 0, z: 0 };
    }

    deepMerge(target, source) {
        const result = { ...target };
        
        for (const key in source) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                result[key] = this.deepMerge(result[key] || {}, source[key]);
            } else {
                result[key] = source[key] == 'null' ? null : source[key];
            }
        }
        
        return result;
    }

    getModels() {
        let components = {};
        Object.keys(this.models).forEach((modelId) => {
            const data = this.models[modelId];
            components[modelId] = (params = {}) => {
                return this.deepMerge(data, params);
            };        
        });
        return components;
    }
    getComponents(){
        return {
            Position: (x = 0, y = 0, z = 0) => ({ x, y, z }),
            Velocity: (vx = 0, vy = 0, vz = 0, maxSpeed = 100, affectedByGravity = true, anchored = false) => ({ vx, vy, vz, maxSpeed, affectedByGravity, anchored}),
            Facing: (angle) => ({ angle: angle || 0 }),
            Renderable: (objectType, spawnType, capacity = 128) => ({ objectType, spawnType, capacity }),
            Collision: (radius = 1, height = 50) => ({ radius, height }),
            Health: (max = 100) => ({ max, current: max }),
            Building: (type) => ( { type }),
            
            // Enhanced Combat component with elemental damage and defenses
            Combat: (
                damage = 0, 
                range = 1, 
                attackSpeed = 1, 
                projectile = null, 
                lastAttack = 0,
                element = 'physical',
                armor = 0,
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                visionRange = 300
            ) => ({
                damage,
                range,
                attackSpeed,
                projectile,
                lastAttack,
                element,
                armor,
                fireResistance,
                coldResistance,
                lightningResistance,
                poisonResistance,
                visionRange
            }),
            Placement: (placement = null) => (placement),
            Team: (team = 'neutral') => ({ team }),
            UnitType: (unitType) => ({ ...unitType }),
            AIState: (state = 'idle', targetPosition = null, target = null, aiControllerId = null, meta = {} ) => 
                ({ state, targetPosition, target, aiControllerId, meta }),
            Animation: (scale = 1, rotation = 0, flash = 0) => ({ scale, rotation, flash }),
            
            // Enhanced Projectile component with element support
            Projectile: (
                damage = 10, 
                speed = 200, 
                range = 100, 
                target = null, 
                source = null, 
                startTime = 0,
                element = 'physical'
            ) => ({
                damage,
                speed,
                range,
                target,
                source,
                startTime,
                element
            }),
            Lifetime: (duration = 5, startTime = 0) => ({ duration, startTime }),
            HomingTarget: (targetId = null, homingStrength = 0.5, lastKnownPosition = null) => 
                ({ targetId, homingStrength, lastKnownPosition }),
            
            // Enhanced Equipment component that can provide resistances
            Equipment: (slots = {}) => ({ 
                slots: {
                    mainHand: null,
                    offHand: null,
                    helmet: null,
                    chest: null,
                    legs: null,
                    feet: null,
                    back: null,
                    ...slots
                }
            }),
            
            EquipmentSlot: (slotType, itemId = null, attachmentPoint = null, offset = { x: 0, y: 0, z: 0 }, rotation = { x: 0, y: 0, z: 0 }) => ({
                slotType,
                itemId,
                attachmentPoint,
                offset,
                rotation
            }),
            
            // Enhanced EquipmentItem with defensive stats
            EquipmentItem: (
                itemType, 
                modelPath, 
                stats = {},
                armor = 0,
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                element = null  // Weapon element
            ) => ({
                itemType,
                modelPath,
                stats: {
                    ...stats,
                    armor,
                    fireResistance,
                    coldResistance,
                    lightningResistance,
                    poisonResistance,
                    element
                },
                attachmentData: {
                    mainHand: {
                        bone: 'Hand_R',
                        offset: { x: 0, y: 0, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    offHand: {
                        bone: 'Hand_L', 
                        offset: { x: 0, y: 0, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 }
                    }
                }
            }),
            
            Corpse: (originalUnitType = null, deathTime = 0, teamAtDeath = 'neutral') => ({ 
                originalUnitType, 
                deathTime, 
                teamAtDeath,
                isCorpse: true 
            }),
            
            DeathState: (isDying = false, deathStartTime = 0, deathAnimationDuration = 2.0) => ({ 
                isDying, 
                deathStartTime, 
                deathAnimationDuration 
            }),

            // Status effect component for tracking temporary effects
            StatusEffect: (
                effectType = 'buff',
                element = null,
                duration = 0,
                startTime = 0,
                sourceId = null,
                stacks = 1,
                maxStacks = 1
            ) => ({
                effectType,  // 'buff', 'debuff', 'dot', 'immunity'
                element,
                duration,
                startTime,
                sourceId,
                stacks,
                maxStacks
            }),

            // Resistance component for temporary resistances/immunities
            ElementalResistance: (
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                physicalResistance = 0,
                divineResistance = 0,
                duration = null,
                permanent = true
            ) => ({
                fireResistance,
                coldResistance,
                lightningResistance,
                poisonResistance,
                physicalResistance,
                divineResistance,
                duration,
                permanent
            }),

            // =============================================
            // TACTICAL ABILITY COMPONENTS (from original)
            // =============================================
            MiningState: (state, targetMine, targetTownHall, hasGold, miningStartTime, depositStartTime, team, entityId) => ({
                state, targetMine, targetTownHall, hasGold, miningStartTime, depositStartTime, team, entityId
            }),
            BuildingState: (state, targetBuildingEntityId, targetBuildingPosition, constructionStartTime) => ({
                state, 
                targetBuildingEntityId, 
                targetBuildingPosition, 
                constructionStartTime                
            }),
            MindControlled: (originalTeam = 'neutral', controller = null, endTime = 0) => ({
                originalTeam,
                controller,
                endTime,
                isControlled: true
            }),
            
            MirrorImage: (originalEntity = null, isIllusion = true, createdTime = 0) => ({
                originalEntity,
                isIllusion,
                createdTime: createdTime || (this.game.state.now || 0)
            }),
            
            Trap: (
                damage = 50, 
                radius = 80, 
                triggerRadius = 30, 
                element = 'physical', 
                caster = null, 
                triggered = false, 
                maxTriggers = 1
            ) => ({
                damage,
                radius,
                triggerRadius,
                element,
                caster,
                triggered,
                triggerCount: 0,
                maxTriggers
            }),
            
            Summoned: (summoner = null, summonType = 'generic', originalStats = null, createdTime = 0) => ({
                summoner,
                summonType,
                originalStats,
                createdTime: createdTime || (this.game.state.now || 0),
                isSummoned: true
            }),
            
            TemporaryEffect: (effectType = 'generic', data = {}, createdTime = 0) => ({
                effectType,
                data,
                createdTime: createdTime || (this.game.state.now || 0)
            }),
            
            Thorns: (reflectionPercent = 0.5, endTime = 0, totalReflected = 0) => ({
                reflectionPercent,
                endTime: endTime || (this.game.state.now || 0) + 20,
                totalReflected,
                isActive: true
            }),
            
            Taunt: (taunter = null, endTime = 0, radius = 0, isTaunted = true) => ({
                taunter,
                endTime: endTime || (this.game.state.now || 0) + 5,
                radius,
                isTaunted
            }),
            
            ShieldWall: (damageReduction = 0.75, endTime = 0, tauntRadius = 200, originalArmor = 0) => ({
                damageReduction,
                endTime: endTime || (this.game.state.now || 0) + 10,
                tauntRadius,
                originalArmor,
                isActive: true
            }),
            
            // =============================================
            // ENHANCED BUFF SYSTEM FOR NEW SPELLS
            // =============================================
            
            Buff: (
                buffType = 'generic', 
                modifiers = {}, 
                endTime = 0, 
                stackable = false, 
                stacks = 1, 
                appliedTime = 0
            ) => ({
                buffType,
                modifiers,
                endTime: endTime || (this.game.state.now || 0) + 30,
                stackable,
                stacks,
                appliedTime: appliedTime || (this.game.state.now || 0),
                isActive: true,
                
                // Specific buff properties based on type
                ...(buffType === 'rallied' && {
                    damageMultiplier: modifiers.damageMultiplier || 1.3,
                    moralBoost: true,
                    fearImmunity: true
                }),
                
                ...(buffType === 'intimidated' && {
                    damageReduction: modifiers.damageReduction || 0.25,
                    accuracyReduction: modifiers.accuracyReduction || 0.2
                }),
                
                ...(buffType === 'phalanx' && {
                    armorMultiplier: modifiers.armorMultiplier || 1.0,
                    counterAttackChance: modifiers.counterAttackChance || 0.2,
                    formationSize: modifiers.formationSize || 1
                }),
                
                ...(buffType === 'marked' && {
                    damageTakenMultiplier: modifiers.damageTakenMultiplier || 1.25,
                    revealed: true,
                    markedBy: modifiers.markedBy || null
                }),
                
                ...(buffType === 'poison_weapon' && {
                    poisonDamage: modifiers.poisonDamage || 25,
                    poisonDuration: modifiers.poisonDuration || 6,
                    attacksRemaining: modifiers.attacksRemaining || 5
                }),
                
                ...(buffType === 'disrupted' && {
                    abilitiesDisabled: true,
                    accuracyReduction: modifiers.accuracyReduction || 0.4,
                    movementSlowed: modifiers.movementSlowed || 0.6
                }),
                
                ...(buffType === 'magic_weapon' && {
                    weaponElement: modifiers.weaponElement || 'fire',
                    elementalDamage: modifiers.elementalDamage || 15,
                    glowing: true
                }),
                
                ...(buffType === 'dark_empowerment' && {
                    damageMultiplier: modifiers.damageMultiplier,
                    attackSpeedMultiplier: modifiers.attackSpeedMultiplier
                }),
                
                ...(buffType === 'ice_armor' && {
                    armorMultiplier: modifiers.armorMultiplier,
                }),
                
                ...(buffType === 'rage' && {
                    damageMultiplier: modifiers.damageMultiplier || 1.5,
                    attackSpeedMultiplier: modifiers.attackSpeedMultiplier || 1.3
                }),
                
                ...(buffType === 'bloodlust' && {
                    lifeSteal: modifiers.lifeSteal || 0.3,
                    damagePerKill: modifiers.damagePerKill || 5,
                    maxStacks: modifiers.maxStacks || 10
                }),
                
                ...(buffType === 'stunned' && {
                    movementDisabled: true,
                    attackDisabled: true
                })
            }),
            
            Whirlwind: (
                damage = 30, 
                radius = 80, 
                endTime = 0, 
                hitInterval = 0.3, 
                lastHitTime = 0, 
                totalHits = 0
            ) => ({
                damage,
                radius,
                endTime: endTime || (this.game.state.now || 0) + 2,
                hitInterval,
                lastHitTime,
                totalHits,
                isActive: true
            }),

            // =============================================
            // FORMATION AND SQUAD COMPONENTS
            // =============================================
            
            Formation: (
                formationType = 'none',
                formationSize = 1,
                formationLeader = null,
                formationMembers = [],
                formationBonuses = {},
                isActive = false
            ) => ({
                formationType, // 'phalanx', 'wedge', 'line', 'circle', etc.
                formationSize,
                formationLeader,
                formationMembers,
                formationBonuses,
                isActive,
                createdTime: (this.game.state.now || 0)
            }),
            
            SquadMember: (
                squadId = null,
                squadRole = 'member', // 'leader', 'member', 'specialist'
                squadPosition = { x: 0, z: 0 },
                squadBonuses = {}
            ) => ({
                squadId,
                squadRole,
                squadPosition,
                squadBonuses,
                joinedTime: (this.game.state.now || 0)
            }),

            // =============================================
            // ABILITY COOLDOWN AND RESOURCE COMPONENTS
            // =============================================
            
            AbilityCooldowns: (cooldowns = {}) => ({
                cooldowns, // Map of abilityId -> cooldownEndTime
                lastAbilityUsed: null,
                lastAbilityTime: 0
            }),
            
            ResourcePool: (
                mana = 100,
                maxMana = 100,
                manaRegen = 5,
                stamina = 100,
                maxStamina = 100,
                staminaRegen = 10,
                focus = 100,
                maxFocus = 100
            ) => ({
                mana,
                maxMana,
                manaRegen,
                stamina,
                maxStamina, 
                staminaRegen,
                focus,
                maxFocus,
                lastRegenTick: (this.game.state.now || 0)
            }),

            // =============================================
            // VISUAL EFFECT COMPONENTS
            // =============================================
            
            VisualEffect: (
                effectType = 'particle',
                effectData = {},
                duration = 1.0,
                startTime = 0,
                attachedTo = null
            ) => ({
                effectType,
                effectData,
                duration,
                startTime: startTime || (this.game.state.now || 0),
                attachedTo,
                isActive: true
            }),
            
            Aura: (
                auraType = 'generic',
                radius = 50,
                effects = {},
                visualEffect = null,
                persistent = true,
                pulseInterval = 1.0,
                lastPulse = 0
            ) => ({
                auraType,
                radius,
                effects,
                visualEffect,
                persistent,
                pulseInterval,
                lastPulse,
                createdTime: (this.game.state.now || 0)
            }),

            // =============================================
            // TARGETING AND AI COMPONENTS
            // =============================================
            
            TargetingPreference: (
                preferredTargets = [],
                avoidedTargets = [],
                targetPriority = 'nearest',
                maxTargetRange = 200,
                requiresLineOfSight = false
            ) => ({
                preferredTargets,
                avoidedTargets,
                targetPriority, // 'nearest', 'weakest', 'strongest', 'marked', 'leader'
                maxTargetRange,
                requiresLineOfSight,
                currentTarget: null,
                targetLockTime: 0
            }),
            
            Threat: (
                threatLevel = 0,
                maxThreat = 100,
                threatDecay = 1,
                lastThreatUpdate = 0,
                threatSources = new Map()
            ) => ({
                threatLevel,
                maxThreat,
                threatDecay,
                lastThreatUpdate,
                threatSources
            }),

            // =============================================
            // SPECIAL ABILITY STATE COMPONENTS
            // =============================================
            
            Charging: (
                target = null,
                chargeSpeed = 100,
                chargeDamage = 50,
                chargeStartTime = 0,
                chargeDistance = 0,
                maxChargeDistance = 150
            ) => ({
                target,
                chargeSpeed,
                chargeDamage,
                chargeStartTime,
                chargeDistance,
                maxChargeDistance,
                isCharging: true
            }),
            
            Channeling: (
                abilityId = null,
                channelDuration = 3.0,
                channelStartTime = 0,
                canBeInterrupted = true,
                interruptThreshold = 10
            ) => ({
                abilityId,
                channelDuration,
                channelStartTime,
                canBeInterrupted,
                interruptThreshold,
                isChanneling: true
            }),
            
            Stealthed: (
                stealthLevel = 1.0, // 0.0 = invisible, 1.0 = fully visible
                detectionRadius = 30,
                stealthStartTime = 0,
                canAttackWhileStealth = false,
                breaksOnAttack = true
            ) => ({
                stealthLevel,
                detectionRadius,
                stealthStartTime,
                canAttackWhileStealth,
                breaksOnAttack,
                isStealth: true
            }),

            // =============================================
            // ENVIRONMENTAL INTERACTION COMPONENTS  
            // =============================================
            
            EnvironmentalHazard: (
                hazardType = 'generic',
                damagePerTick = 10,
                tickInterval = 1.0,
                element = 'physical',
                affectsTeams = ['all'],
                lastTickTime = 0
            ) => ({
                hazardType, // 'fire', 'poison_cloud', 'ice_field', 'lightning_storm', etc.
                damagePerTick,
                tickInterval,
                element,
                affectsTeams,
                lastTickTime,
                createdTime: (this.game.state.now || 0)
            }),
            
            Consecrated: (
                consecrationLevel = 1.0,
                healPerTick = 5,
                damageToUndead = 10,
                tickInterval = 2.0,
                caster = null,
                lastTickTime = 0
            ) => ({
                consecrationLevel,
                healPerTick,
                damageToUndead,
                tickInterval,
                caster,
                lastTickTime,
                isConsecrated: true
            }),

            // =============================================
            // COMMAND QUEUE SYSTEM
            // =============================================

            CommandQueue: (
                commands = [],
                currentCommand = null,
                commandHistory = []
            ) => ({
                commands,           // Array of pending commands
                currentCommand,     // Currently executing command
                commandHistory      // History of completed commands (for debugging)
            }),

            Command: (
                type = 'move',
                controllerId = null,
                targetPosition = null,
                target = null,
                meta = {},
                priority = 0,
                interruptible = true,
                createdTime = 0
            ) => ({
                type,               // 'move', 'build', 'mine', 'attack', etc.
                controllerId,       // Which AI controller to activate
                targetPosition,     // Target position for movement
                target,            // Target entity ID
                meta,              // Controller-specific metadata
                priority,          // Higher priority interrupts lower priority
                interruptible,     // Can this command be interrupted?
                createdTime: createdTime || (this.game.state.now || 0),
                id: Math.random().toString(36).substr(2, 9) // Unique command ID
            })
        };
    }

    getComponentTypes() {
        return {
            // Basic Components
            TRANSFORM: 'transform',
            POSITION: 'position',
            FACING: 'facing',
            VELOCITY: 'velocity',
            SCALE: 'scale',
            RENDERABLE: 'renderable',
            MAP_RENDERER: 'mapRenderer',
            SPRITE: 'sprite',
            MAP_MANAGER: 'mapManager',
            WORLD_OBJECT: 'worldObject',
            ENVIRONMENT_OBJECT: 'environmentObject',
            
            // Unit Components
            PLACEMENT: 'placement',
            TEAM: 'team',
            UNIT_TYPE: 'unitType',
            AI_STATE: 'aiState',
            ANIMATION: 'animation',
            HEALTH: 'health',
            COMBAT: 'combat',
            COLLISION: 'collision',
            BUILDING: 'building',
            
            // Projectile System
            PROJECTILE: 'projectile',
            LIFETIME: 'lifetime',
            HOMING_TARGET: 'homingTarget',
            
            // Entity System
            ENTITY_TYPE: 'entityType',
            LEVEL_DATA: 'levelData',
            
            // Equipment System
            EQUIPMENT: 'equipment',
            EQUIPMENT_SLOT: 'equipmentSlot',
            EQUIPMENT_ITEM: 'equipmentItem',
            
            // Death System
            CORPSE: 'corpse',
            DEATH_STATE: 'deathState',
            
            // Status Effects
            STATUS_EFFECT: 'statusEffect',
            ELEMENTAL_RESISTANCE: 'elementalResistance',

            // =============================================
            // TACTICAL ABILITY COMPONENT TYPES
            // =============================================
            MIND_CONTROLLED: 'mindControlled',
            MIRROR_IMAGE: 'mirrorImage',
            TRAP: 'trap',
            SUMMONED: 'summoned',
            TEMPORARY_EFFECT: 'temporaryEffect',
            THORNS: 'thorns',
            TAUNT: 'taunt',
            SHIELD_WALL: 'shieldWall',
            BUFF: 'buff',
            WHIRLWIND: 'whirlwind',

            // =============================================
            // NEW SPELL SUPPORT COMPONENT TYPES
            // =============================================
            
            // Formation and Squad
            FORMATION: 'formation',
            SQUAD_MEMBER: 'squadMember',
            
            // Ability Resources
            ABILITY_COOLDOWNS: 'abilityCooldowns',
            RESOURCE_POOL: 'resourcePool',
            
            // Visual Effects
            VISUAL_EFFECT: 'visualEffect',
            AURA: 'aura',
            MINING_STATE: 'miningState',
            BUILDING_STATE: 'buildingState',
            // AI and Targeting
            TARGETING_PREFERENCE: 'targetingPreference',
            THREAT: 'threat',
            
            // Special States
            CHARGING: 'charging',
            CHANNELING: 'channeling',
            STEALTHED: 'stealthed',
            
            // Environmental
            ENVIRONMENTAL_HAZARD: 'environmentalHazard',
            CONSECRATED: 'consecrated',

            // Command Queue
            COMMAND_QUEUE: 'commandQueue'
        };
    }
};

// manager: GameManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['GameManager'] = class GameManager {
    constructor(game) {
        this.game = game;
        this.game.gameManager = this;
        this.services = new Map();
    }

    initializeGame(){
        if (!this.game.screenManager.selectedGameMode) {
            alert('Please select a game mode first!');
            return;
        }

        this.game.screenManager.showLoadingScreen();
        
        // Update loading content based on selected mode
        const mode = this.game.gameModeManager.getSelectedMode();
        if (mode) {
            const loadingTip = document.querySelector('.loading-tip');
            if (loadingTip) {
                loadingTip.textContent = `Mode: ${mode.title} - ${mode.description}`;
            }
        }

        this.game.triggerEvent('onGameStarted');

        setTimeout(() => {   
            this.game.state.isPaused = false;
            this.game.uiSystem.start();
            this.game.screenManager.showGameScreen();  
        }, 2000);
        
    }

    pauseGame() {
        this.game.screenManager.pause();
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'flex';
        }
    }

    resumeGame() {
        this.game.screenManager.resume();
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'none';
        }
    }

    restartGame() {
        const confirmRestart = this.game.screenManager.currentScreen === 'gameScreen' 
            ? confirm('Are you sure you want to restart? Your current progress will be lost.')
            : true;

        if (confirmRestart) {
            this.initializeGame();
        }
        
        // Hide pause menu if open
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'none';
        }
    }

    exitToMenu() {
        if (confirm('Are you sure you want to exit to the main menu? Your progress will be lost.')) {
            this.game.phaseSystem.reset();
            this.game.screenManager.showMainMenu();
        }
    }

    continueGame() {
        // Continue to next round/level
        this.game.screenManager.stats.round++;
        this.initializeGame();
    }

    // Systems call this in constructor or init()
    register(key, method) {
        if (this.services.has(key)) {
            debugger;
            console.warn(`Service ${key} already registered! Overwriting.`);
        }
        this.services.set(key, method);
    }

    has(key){
        return this.services.has(key);
    }

    // Public API
    call(key, ...args) {
        const method = this.services.get(key);
        if (!method) {
            return undefined;
        }
        return method(...args);
    }

    // Optional: async version
    async callAsync(key, ...args) {
        return this.call(key, ...args);
    }

    // Debug
    listServices() {
        return Array.from(this.services.keys());
    }

}
;

// manager: UnitCreationManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['UnitCreationManager'] = class UnitCreationManager {
    constructor(game) {
        this.game = game;
        this.game.unitCreationManager = this;
        this.SPEED_MODIFIER = 20;
        // Default component values for missing unit data
        this.defaults = {
            hp: 100,
            damage: 10,
            range: 30,
            speed: 40,
            attackSpeed: 1.0,
            size: 5,
            height: 50,
            armor: 0,
            fireResistance: 0,
            coldResistance: 0,
            lightningResistance: 0,
            element: 'physical',
            projectile: null,
            value: 50
        };
        
        // Equipment slot priorities for auto-equipping
        this.equipmentPriority = [
            'weapon',
            'armor',
            'helmet',
            'boots',
            'gloves',
            'accessory'
        ];
        
        // Team-specific configurations
        this.teamConfigs = {
            left: {
                initialFacing: 0,
                aiState: 'idle',
                colorTint: null
            },
            right: {
                initialFacing: Math.PI,
                aiState: 'idle',
                colorTint: 0xff4444
            }
        };
        
        // Component creation cache for performance
        this.componentCache = new Map();
        
        // Unit creation statistics
        this.stats = {
            totalCreated: 0,
            createdByTeam: new Map(),
            createdByType: new Map(),
            equipmentFailures: 0,
            abilityFailures: 0,
            squadsCreated: 0
        };
    }
    
    /**
     * Create a new unit entity with all required components
     * @param {number} worldX - World X coordinate
     * @param {number} worldY - World Y coordinate
     * @param {number} worldZ - World Z coordinate
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier ('left' or 'right')
     * @returns {number} Entity ID
     */
    create(worldX, worldY, worldZ, targetPosition, placement, team) {
        const unitType = placement.unitType;
        try {
            // Round world coordinates to ensure deterministic entity IDs across client and server
            const roundedX = Math.round(worldX * 100) / 100;
            const roundedZ = Math.round(worldZ * 100) / 100;
            const entity = this.game.createEntity(`${unitType.id}_${roundedX}_${roundedZ}_${team}_${this.game.state.round}`);
            console.log('created unit', unitType.id, team, entity);
            const teamConfig = this.teamConfigs[team];
            // Add core components
            this.addCoreComponents(entity, worldX, worldY, worldZ, placement, team, teamConfig);
            
            // Add combat components
            this.addCombatComponents(entity, unitType);
            
            // Add AI and behavior components
            this.addBehaviorComponents(entity, targetPosition, unitType);
            
            // Add visual and interaction components
            this.addVisualComponents(entity, unitType, teamConfig);
            
            // Schedule equipment and abilities (async to avoid blocking)
            this.schedulePostCreationSetup(entity, unitType);
            
            // Update statistics
            this.updateCreationStats(unitType, team);
            return entity;
        } catch (error) {
            console.error('Failed to create unit:', error);
            throw new Error(`Unit creation failed: ${error.message}`);
        }
    }


    /**
     * Create multiple squads efficiently from placement data
     * @param {Array} placements - Array of placement data from client
     * @param {string} team - Team identifier
     * @param {string|null} playerId - Optional player ID
     * @returns {Array} Array of created squad placement data
     */
    createSquadFromPlacement(placement, team, playerId = null) {

        const gridPosition = placement.gridPosition;
        const targetPosition = placement.targetPosition;
        const unitType = placement.unitType;

        try {
            // Get squad configuration
            const squadData = this.game.squadManager.getSquadData(unitType);
            const validation = this.game.squadManager.validateSquadConfig(squadData);
            
            if (!validation.valid) {
                console.log("invalid squad config");
                return false;
            }

            // Calculate unit positions within the squad
            const unitPositions = this.game.squadManager.calculateUnitPositions(
                gridPosition,
                unitType
            );

            // Calculate cells occupied by the squad
            const cells = this.game.squadManager.getSquadCells(gridPosition, squadData);

            // Generate unique placement ID
            const placementId = `squad_${team}_${gridPosition.x}_${gridPosition.z}`;
            const squadUnits = [];

            
            // Create individual units for the squad
            for (const pos of unitPositions) {
                const terrainHeight = this.getTerrainHeight(pos.x, pos.z);
                const unitY = terrainHeight !== null ? terrainHeight : 0;

                const entityId = this.create(pos.x, unitY, pos.z, targetPosition, placement, team);

                // Add playerId to the team component if provided
                if (playerId && this.game.componentManager) {
                    const ComponentTypes = this.game.componentManager.getComponentTypes();
                    const teamComponent = this.game.getComponent(entityId, ComponentTypes.TEAM);
                    if (teamComponent) {
                        teamComponent.playerId = playerId;
                    }
                }
                if(unitType.collection == 'buildings'){
                    this.game.placementSystem.saveBuilding(entityId, team, gridPosition, unitType)
                }
                squadUnits.push(entityId);
                this.game.gameManager.call('reserveGridCells', cells, entityId);
            }

            // Occupy grid cells
            // Update squad creation statistics
            this.stats.squadsCreated++;

            // Initialize squad in experience system if available
            if (this.game.squadExperienceSystem) {
                this.game.squadExperienceSystem.initializeSquad(placementId, unitType, squadUnits, team);
            }

            // const squadInfo = this.game.squadManager.getSquadInfo(unitType);
         
            return {
                placementId: placementId,
                gridPosition: gridPosition,
                unitType: unitType,
                squadUnits: squadUnits,
                cells: cells,
                isSquad: squadUnits.length > 1,
                team: team,
                playerId: playerId,
                timestamp: Date.now()
            };

        } catch (error) {
            console.error('Squad creation failed:', error);
            throw new Error(`Squad creation failed: ${error.message}`);
        }
    
    }

    /**
     * Clean up squads by destroying their units and freeing grid cells
     * @param {Array} squads - Array of squad placement data
     */
    cleanupSquads(squads) {
        for (const squad of squads) {
            try {
                // Destroy squad units
                for (const unit of squad.squadUnits || []) {
                    if (this.game.destroyEntity && unit) {
                        this.game.destroyEntity(unit);
                    }
                }

                // Free grid cells
                if (this.game.gridSystem && squad.placementId) {
                    this.game.gridSystem.freeCells(squad.placementId);
                }

                // Remove from experience system
                if (this.game.squadExperienceSystem && squad.placementId) {
                    this.game.squadExperienceSystem.removeSquad(squad.placementId);
                }

            } catch (error) {
                console.warn(`Failed to cleanup squad ${squad.placementId}:`, error);
            }
        }
    }

    /**
     * Get squad information for a unit type
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Squad information
     */
    getSquadInfo(unitType) {
        if (this.game.squadManager) {
            return this.game.squadManager.getSquadInfo(unitType);
        }
        
        // Fallback squad info
        return {
            unitName: unitType.title || unitType.id || 'Unknown',
            squadSize: 1,
            formationType: 'single',
            spacing: 1
        };
    }

    /**
     * Validate if a squad can be placed at the given position
     * @param {Object} gridPosition - Grid position {x, z}
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     * @returns {boolean} True if placement is valid
     */
    canPlaceSquad(gridPosition, unitType, team) {
        if (!this.game.squadManager || !this.game.gridSystem) {
            return this.game.gridSystem ? 
                this.game.gridSystem.isValidPosition(gridPosition) : true;
        }

        try {
            const squadData = this.game.squadManager.getSquadData(unitType);
            const validation = this.game.squadManager.validateSquadConfig(squadData);
            
            if (!validation.valid) {
                return false;
            }

            const cells = this.game.squadManager.getSquadCells(gridPosition, squadData);
            return this.game.gridSystem.isValidPlacement(cells, team);
            
        } catch (error) {
            console.warn('Squad placement validation failed:', error);
            return false;
        }
    }
    
    /**
     * Add core position and identity components
     * @param {number} entity - Entity ID
     * @param {number} worldX - World X coordinate
     * @param {number} worldY - World Y coordinate
     * @param {number} worldZ - World Z coordinate
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     * @param {Object} teamConfig - Team configuration
     */
    addCoreComponents(entity, worldX, worldY, worldZ, placement, team, teamConfig) {
        const unitType = placement.unitType;
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        
        // Position component
        this.game.addComponent(entity, ComponentTypes.POSITION, 
            Components.Position(worldX, worldY, worldZ));
        
        // Velocity component with movement capabilities
        const maxSpeed = (unitType.speed) * this.SPEED_MODIFIER;
        this.game.addComponent(entity, ComponentTypes.VELOCITY, 
            Components.Velocity(0, 0, 0, maxSpeed, true, unitType.collection == 'buildings' ? true : false));
        
        // Team identification
        this.game.addComponent(entity, ComponentTypes.TEAM, 
            Components.Team(team));
        
        this.game.addComponent(entity, ComponentTypes.PLACEMENT, 
            Components.Placement(placement));
        
        // Unit type information
        this.game.addComponent(entity, ComponentTypes.UNIT_TYPE, 
            Components.UnitType(
                unitType
            ));
        
        // Facing direction
        this.game.addComponent(entity, ComponentTypes.FACING, 
            Components.Facing(teamConfig.initialFacing));
    }
    
    /**
     * Add combat-related components
     * @param {number} entity - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    addCombatComponents(entity, unitType) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        // Health component
        const maxHP = unitType.hp || this.defaults.hp;
        this.game.addComponent(entity, ComponentTypes.HEALTH, 
            Components.Health(maxHP));
        
        // Combat component with all combat stats
        this.game.addComponent(entity, ComponentTypes.COMBAT, 
            Components.Combat(
                unitType.damage,
                unitType.range,
                unitType.attackSpeed,
                unitType.projectile,
                0, // Initial attack cooldown
                unitType.element,
                unitType.armor,
                unitType.fireResistance,
                unitType.coldResistance,
                unitType.lightningResistance, 
                0,
                unitType.visionRange
            ));
        
        // Collision component for physical interactions
        this.game.addComponent(entity, ComponentTypes.COLLISION, 
            Components.Collision(unitType.size || this.defaults.size, unitType.height));
    }
    
    /**
     * Add AI and behavior components
     * @param {number} entity - Entity ID
     */
    addBehaviorComponents(entity, targetPosition, unitType) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        // AI state for behavior control
        this.game.addComponent(entity, ComponentTypes.AI_STATE, 
            Components.AIState('idle', targetPosition));
        
        // Animation state
        this.game.addComponent(entity, ComponentTypes.ANIMATION, 
            Components.Animation());
        
        // Equipment container
        this.game.addComponent(entity, ComponentTypes.EQUIPMENT, 
            Components.Equipment());
    }
    
    /**
     * Add visual and rendering components
     * @param {number} entity - Entity ID
     * @param {Object} unitType - Unit type definition
     * @param {Object} teamConfig - Team configuration
     */
    addVisualComponents(entity, unitType, teamConfig) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        
        // Renderable component for visual representation
        this.game.addComponent(entity, ComponentTypes.RENDERABLE, 
            Components.Renderable(unitType.collection, unitType.id || 'default'));
        
        // Add team-specific visual modifications
        if (teamConfig.colorTint && this.game.addComponent) {
            // Optional: Add color tint component if available
            try {
                if (ComponentTypes.COLOR_TINT) {
                    this.game.addComponent(entity, ComponentTypes.COLOR_TINT,
                        Components.ColorTint(teamConfig.colorTint));
                }
            } catch (error) {
                // Color tint not available, continue without it
            }
        }
    }
    
    /**
     * Schedule post-creation setup (equipment and abilities)
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    schedulePostCreationSetup(entityId, unitType) {

        this.setupEquipment(entityId, unitType);
        this.setupAbilities(entityId, unitType);
    }
    
    /**
     * Equip unit with items from unit definition
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    async setupEquipment(entityId, unitType) {

        if (!this.game.equipmentSystem || !unitType?.render?.equipment) {
            return;
        }
        
        try {
            // Sort equipment by priority for better equipping order
            const equipmentList = [...unitType.render.equipment].sort((a, b) => {
                const priorityA = this.equipmentPriority.indexOf(a.slot) || 999;
                const priorityB = this.equipmentPriority.indexOf(b.slot) || 999;
                return priorityA - priorityB;
            });
            
            // Equip each item
            for (const equippedItem of equipmentList) {
                const itemData = this.getItemFromCollection(equippedItem.item);
                if (itemData) {
                    try {
                        await this.game.equipmentSystem.equipItem(
                            entityId, 
                            equippedItem, 
                            itemData, 
                            equippedItem.item
                        );
                    } catch (equipError) {
                        console.warn(`Failed to equip ${equippedItem.item} on slot ${equippedItem.slot}:`, equipError);
                        this.stats.equipmentFailures++;
                    }
                } else {
                    console.warn(`Item ${equippedItem.item} not found in collections`);
                    this.stats.equipmentFailures++;
                }
            }
        } catch (error) {
            console.error(`Equipment setup failed for entity ${entityId}:`, error);
            this.stats.equipmentFailures++;
        }
    }
    
    /**
     * Add abilities to unit from unit definition
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    setupAbilities(entityId, unitType) {
        if (!this.game.abilitySystem || !unitType?.abilities) {
            return;
        }
        
        try {
            // Validate abilities exist before adding
            const validAbilities = unitType.abilities.filter(abilityId => {
                const abilityData = this.getAbilityFromCollection(abilityId);
                if (!abilityData) {
                    console.warn(`Ability ${abilityId} not found in collections`);
                    this.stats.abilityFailures++;
                    return false;
                }
                return true;
            });
            
            if (validAbilities.length > 0) {
                this.game.abilitySystem.addAbilitiesToUnit(entityId, validAbilities);
            }
        } catch (error) {
            console.error(`Ability setup failed for entity ${entityId}:`, error);
            this.stats.abilityFailures++;
        }
    }
    
    /**
     * Get item data from game collections
     * @param {string} itemId - Item identifier
     * @returns {Object|null} Item data or null if not found
     */
    getItemFromCollection(itemId) {
        try {
            const collections = this.game.getCollections();
            if (!collections?.items?.[itemId]) {
                return null;
            }
            return collections.items[itemId];
        } catch (error) {
            console.warn(`Error accessing item collection for ${itemId}:`, error);
            return null;
        }
    }
    
    /**
     * Get ability data from game collections
     * @param {string} abilityId - Ability identifier
     * @returns {Object|null} Ability data or null if not found
     */
    getAbilityFromCollection(abilityId) {
        try {
            const collections = this.game.getCollections();
            if (!collections?.abilities?.[abilityId]) {
                return null;
            }
            return collections.abilities[abilityId];
        } catch (error) {
            console.warn(`Error accessing ability collection for ${abilityId}:`, error);
            return null;
        }
    }
    
    /**
     * Get terrain height at world position
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Terrain height
     */
    getTerrainHeight(worldX, worldZ) {
        try {
            if (this.game.terrainSystem?.getTerrainHeightAtPosition) {
                return this.game.terrainSystem.getTerrainHeightAtPosition(worldX, worldZ);
            }
        } catch (error) {
            console.warn(`Error getting terrain height at (${worldX}, ${worldZ}):`, error);
        }
        return 0; // Default to ground level
    }
    
    
    /**
     * Update creation statistics
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     */
    updateCreationStats(unitType, team) {
        this.stats.totalCreated++;
        
        // Track by team
        const teamCount = this.stats.createdByTeam.get(team) || 0;
        this.stats.createdByTeam.set(team, teamCount + 1);
        
        // Track by unit type
        const unitTypeId = unitType.id || 'unknown';
        const typeCount = this.stats.createdByType.get(unitTypeId) || 0;
        this.stats.createdByType.set(unitTypeId, typeCount + 1);
    }
    
    /**
     * Get creation statistics
     * @returns {Object} Statistics summary
     */
    getStats() {
        return {
            totalCreated: this.stats.totalCreated,
            createdByTeam: Object.fromEntries(this.stats.createdByTeam),
            createdByType: Object.fromEntries(this.stats.createdByType),
            equipmentFailures: this.stats.equipmentFailures,
            abilityFailures: this.stats.abilityFailures,
            squadsCreated: this.stats.squadsCreated,
            successRate: {
                equipment: 1 - (this.stats.equipmentFailures / Math.max(1, this.stats.totalCreated)),
                abilities: 1 - (this.stats.abilityFailures / Math.max(1, this.stats.totalCreated))
            }
        };
    }
    
    /**
     * Reset creation statistics
     */
    resetStats() {
        this.stats = {
            totalCreated: 0,
            createdByTeam: new Map(),
            createdByType: new Map(),
            equipmentFailures: 0,
            abilityFailures: 0,
            squadsCreated: 0
        };
    }
    
    /**
     * Validate unit type definition
     * @param {Object} unitType - Unit type to validate
     * @returns {Object} Validation result
     */
    validateUnitType(unitType) {
        const errors = [];
        const warnings = [];
        
        if (!unitType) {
            errors.push('Unit type is required');
            return { valid: false, errors, warnings };
        }
        
        // Check required fields
        if (!unitType.id) warnings.push('Unit ID missing, using default');
        if (!unitType.title) warnings.push('Unit title missing, using ID or default');
        
        // Validate numeric stats
        const numericFields = ['hp', 'damage', 'range', 'speed', 'armor', 'value'];
        numericFields.forEach(field => {
            if (unitType[field] !== undefined && (isNaN(unitType[field]) || unitType[field] < 0)) {
                errors.push(`${field} must be a non-negative number`);
            }
        });
        
        // Check equipment references
        if (unitType.render?.equipment) {
            unitType.render.equipment.forEach((item, index) => {
                if (!item.item) {
                    warnings.push(`Equipment item ${index} missing item ID`);
                }
                if (!item.slot) {
                    warnings.push(`Equipment item ${index} missing slot`);
                }
            });
        }
        
        // Check ability references
        if (unitType.abilities && !Array.isArray(unitType.abilities)) {
            errors.push('Abilities must be an array');
        }
        
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    
    /**
     * Clean up resources and cache
     */
    dispose() {
        this.componentCache.clear();
        this.resetStats();
    }
};

// manager: SquadManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SquadManager'] = class SquadManager {
    constructor(app) {
        this.game = app;
        this.game.squadManager = this;
        this.ELEMENT_TYPES = {
            PHYSICAL: 'physical',
            FIRE: 'fire',
            COLD: 'cold',
            LIGHTNING: 'lightning',
            POISON: 'poison',
            DIVINE: 'divine'
        };
        
        this.DEFAULT_SQUAD_CONFIG = {
            squadWidth: 1,
            squadHeight: 1,
            placementGridWidth: 1,
            placementGridHeight: 1
        };
    }
    
    /**
     * Extract squad configuration from unit type definition
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Squad configuration with dimensions
     */
    getSquadData(unitType) {
        return {
            squadWidth: unitType.squadWidth || this.DEFAULT_SQUAD_CONFIG.squadWidth,
            squadHeight: unitType.squadHeight || this.DEFAULT_SQUAD_CONFIG.squadHeight,
            placementGridWidth: unitType.placementGridWidth || this.DEFAULT_SQUAD_CONFIG.placementGridWidth,
            placementGridHeight: unitType.placementGridHeight || this.DEFAULT_SQUAD_CONFIG.placementGridHeight
        };
    }
    
    /**
     * Calculate which grid cells a squad would occupy
     * @param {Object} gridPos - Center grid position {x, z}
     * @param {Object} squadData - Squad configuration
     * @returns {Array} Array of cell positions {x, z}
     */
    getSquadCells(gridPos, squadData) {
        const cells = [];
        const { placementGridWidth, placementGridHeight } = squadData;
        
        if(squadData.collection == "buildings"){
            return this.calculateFootprintCells(gridPos, squadData);
        }
        // Calculate starting position to center the formation
        const startX = gridPos.x - Math.floor(placementGridWidth / 2);
        const startZ = gridPos.z - Math.floor(placementGridHeight / 2);
        
        for (let x = 0; x < placementGridWidth; x++) {
            for (let z = 0; z < placementGridHeight; z++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }
        
        return cells;
    }
      
    calculateFootprintCells(gridPos, building) {
        const cells = [];
        // Footprint is in terrain grid units - use directly for preview
        const footprintWidth = building.footprintWidth || building.placementGridWidth || 1;
        const footprintHeight = building.footprintHeight || building.placementGridHeight || 1;

        const startX = gridPos.x - Math.floor(footprintWidth * 2 / 2);
        const startZ = gridPos.z - Math.floor(footprintHeight * 2 / 2);

        // Calculate center position for each footprint cell in placement grid coordinates
        for (let z = 0; z < footprintHeight; z++) {
            for (let x = 0; x < footprintWidth; x++) {
                // Each footprint cell is centered in its 2x2 placement grid area
                cells.push({
                    x: startX + x * 2 + 1,  // Center of 2-cell width
                    z: startZ + z * 2 + 1   // Center of 2-cell height
                });
            }
        }

        return cells;
    }  
    /**
     * Calculate world positions for individual units within a squad formation
     * @param {Object} gridPos - Center grid position {x, z}
     * @param {Object} squadData - Squad configuration
     * @param {Object} gridSystem - GridSystem instance for coordinate conversion
     * @returns {Array} Array of world positions {x, z}
     */
    calculateUnitPositions(gridPos, unitType) {
        const squadData = this.getSquadData(unitType);
        const { squadWidth, squadHeight, placementGridWidth, placementGridHeight } = squadData;
        const positions = [];
        const cellSize = this.game.gridSystem.dimensions.cellSize;

        // Compute the top-left (min) cell of the formation footprint
        const startCellX = gridPos.x - Math.floor(placementGridWidth / 2);
        const startCellZ = gridPos.z - Math.floor(placementGridHeight / 2);

        // Compute the true geometric center of the whole footprint, even for even sizes
        // Example: width=2 -> center at (start + 0.5); width=3 -> center at (start + 1)
        const centerCellX = startCellX + (placementGridWidth - 1) / 2;
        const centerCellZ = startCellZ + (placementGridHeight - 1) / 2;
        const centerWorldPos = this.game.gridSystem.gridToWorld(centerCellX, centerCellZ);

        // If squad footprint matches placement footprint, snap each unit to its cell center.
        if (squadWidth === placementGridWidth && squadHeight === placementGridHeight) {
            for (let row = 0; row < squadHeight; row++) {
                for (let col = 0; col < squadWidth; col++) {
                    const cellX = startCellX + col;
                    const cellZ = startCellZ + row;
                    const wp = this.game.gridSystem.gridToWorld(cellX, cellZ);
                    positions.push({ x: wp.x, z: wp.z });
                }
            }
            return positions;
        }

        // General case: distribute units evenly across the footprint bounds
        const formationWorldWidth  = placementGridWidth  * cellSize;
        const formationWorldHeight = placementGridHeight * cellSize;

        // Single unit: drop on the geometric center of the footprint
        if (squadWidth === 1 && squadHeight === 1) {
            positions.push({ x: centerWorldPos.x, z: centerWorldPos.z });
            return positions;
        }

        // Start from the top-left point of the unit grid *inside* the formation bounds
        const stepX = formationWorldWidth  / Math.max(1, squadWidth);
        const stepZ = formationWorldHeight / Math.max(1, squadHeight);

        const startX = centerWorldPos.x - (formationWorldWidth / 2) + (stepX / 2);
        const startZ = centerWorldPos.z - (formationWorldHeight / 2) + (stepZ / 2);

        console.log(stepX, formationWorldWidth, squadWidth, centerWorldPos, formationWorldWidth, stepX);

        for (let row = 0; row < squadHeight; row++) {
            for (let col = 0; col < squadWidth; col++) {
                const x = startX + col * stepX;
                const z = startZ + row * stepZ;
                positions.push({ x, z });
            }
        }

        return positions;
    }

    /**
     * Check if a squad can fit within given zone bounds
     * @param {Object} squadData - Squad configuration
     * @param {Object} bounds - Zone boundaries {minX, maxX, minZ, maxZ}
     * @returns {boolean} True if squad can fit
     */
    canFitInZone(squadData, bounds) {
        const zoneWidth = bounds.maxX - bounds.minX + 1;
        const zoneHeight = bounds.maxZ - bounds.minZ + 1;
        
        return squadData.placementGridWidth <= zoneWidth && 
               squadData.placementGridHeight <= zoneHeight;
    }
    
    /**
     * Calculate the total number of units in a squad
     * @param {Object} squadData - Squad configuration
     * @returns {number} Total unit count
     */
    getSquadSize(squadData) {
        return squadData.squadWidth * squadData.squadHeight;
    }
    
    /**
     * Get formation type based on squad dimensions
     * @param {Object} squadData - Squad configuration
     * @returns {string} Formation type description
     */
    getFormationType(squadData) {
        const { squadWidth, squadHeight } = squadData;
        
        if (squadWidth === 1 && squadHeight === 1) {
            return 'single';
        } else if (squadWidth === 1) {
            return 'column';
        } else if (squadHeight === 1) {
            return 'line';
        } else if (squadWidth === squadHeight) {
            return 'square';
        } else {
            return 'rectangle';
        }
    }
    
    /**
     * Calculate formation density (units per grid cell)
     * @param {Object} squadData - Squad configuration
     * @returns {number} Units per grid cell ratio
     */
    getFormationDensity(squadData) {
        const totalUnits = this.getSquadSize(squadData);
        const gridCells = squadData.placementGridWidth * squadData.placementGridHeight;
        return totalUnits / gridCells;
    }
    
    /**
     * Get optimal spacing between units in world coordinates
     * @param {Object} squadData - Squad configuration
     * @param {Object} gridSystem - GridSystem instance
     * @returns {Object} Spacing values {x, z}
     */
    getUnitSpacing(squadData, gridSystem) {
        const { squadWidth, squadHeight, placementGridWidth, placementGridHeight } = squadData;
        
        const formationWorldWidth = placementGridWidth * gridSystem.dimensions.cellSize;
        const formationWorldHeight = placementGridHeight * gridSystem.dimensions.cellSize;
        
        return {
            x: squadWidth > 1 ? formationWorldWidth / squadWidth : 0,
            z: squadHeight > 1 ? formationWorldHeight / squadHeight : 0
        };
    }
    
    /**
     * Validate squad configuration
     * @param {Object} squadData - Squad configuration to validate
     * @returns {Object} Validation result {valid, errors}
     */
    validateSquadConfig(squadData) {
        const errors = [];
        
        if (!squadData) {
            errors.push('Squad data is required');
            return { valid: false, errors };
        }
        
        const requiredFields = ['squadWidth', 'squadHeight', 'placementGridWidth', 'placementGridHeight'];
        for (const field of requiredFields) {
            if (typeof squadData[field] !== 'number' || squadData[field] < 1) {
                errors.push(`${field} must be a positive number`);
            }
        }
        
        // Logical validations
        if (squadData.squadWidth > squadData.placementGridWidth * 10) {
            errors.push('Squad width seems unreasonably large for grid size');
        }
        
        if (squadData.squadHeight > squadData.placementGridHeight * 10) {
            errors.push('Squad height seems unreasonably large for grid size');
        }
        
        // Check if formation makes sense
        const totalUnits = squadData.squadWidth * squadData.squadHeight;
        const gridCells = squadData.placementGridWidth * squadData.placementGridHeight;
        
        if (totalUnits > gridCells * 4) {
            errors.push('Too many units for the allocated grid space');
        }
        
        return {
            valid: errors.length === 0,
            errors
        };
    }
    
    /**
     * Generate squad info for display purposes
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Formatted squad information
     */
    getSquadInfo(unitType) {
        const squadData = this.getSquadData(unitType);
        const validation = this.validateSquadConfig(squadData);
        
        return {
            unitName: unitType.title || unitType.id || 'Unknown Unit',
            squadSize: this.getSquadSize(squadData),
            formationType: this.getFormationType(squadData),
            density: this.getFormationDensity(squadData),
            gridFootprint: `${squadData.placementGridWidth}x${squadData.placementGridHeight}`,
            unitFormation: `${squadData.squadWidth}x${squadData.squadHeight}`,
            isValid: validation.valid,
            errors: validation.errors,
            cost: unitType.value || 0,
            totalValue: (unitType.value || 0) * this.getSquadSize(squadData)
        };
    }
    
    /**
     * Check if two squads would overlap
     * @param {Object} pos1 - First squad position
     * @param {Object} squad1 - First squad data
     * @param {Object} pos2 - Second squad position  
     * @param {Object} squad2 - Second squad data
     * @returns {boolean} True if squads overlap
     */
    wouldSquadsOverlap(pos1, squad1, pos2, squad2) {
        const cells1 = this.getSquadCells(pos1, squad1);
        const cells2 = this.getSquadCells(pos2, squad2);
        
        for (const cell1 of cells1) {
            for (const cell2 of cells2) {
                if (cell1.x === cell2.x && cell1.z === cell2.z) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Find all valid positions for a squad within bounds
     * @param {Object} squadData - Squad configuration
     * @param {Object} bounds - Zone boundaries
     * @param {Set} occupiedCells - Set of occupied cell keys "x,z"
     * @returns {Array} Array of valid grid positions
     */
    findValidPositions(squadData, bounds, occupiedCells = new Set()) {
        const validPositions = [];
        
        // Check each possible center position
        for (let x = bounds.minX; x <= bounds.maxX; x++) {
            for (let z = bounds.minZ; z <= bounds.maxZ; z++) {
                const gridPos = { x, z };
                const cells = this.getSquadCells(gridPos, squadData);
                
                // Check if all cells are within bounds and unoccupied
                const isValid = cells.every(cell => {
                    if (cell.x < bounds.minX || cell.x > bounds.maxX ||
                        cell.z < bounds.minZ || cell.z > bounds.maxZ) {
                        return false;
                    }
                    
                    const key = `${cell.x},${cell.z}`;
                    return !occupiedCells.has(key);
                });
                
                if (isValid) {
                    validPositions.push(gridPos);
                }
            }
        }
        
        return validPositions;
    }
};

// ========== Systems ==========

// system: TerrainSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['TerrainSystem'] = class TerrainSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.terrainSystem = this;
        
        this.initialized = false;
        
        // Core terrain data
        this.level = null;
        this.world = null;
        this.tileMap = null;
        this.heightMapData = null;
        
        // Settings from collections
        this.heightMapSettings = null;
        
        // Terrain dimensions
        this.terrainSize = 0;
        this.extensionSize = 0;
        this.extendedSize = 0;
        this.heightStep = 0;
        
        // Height map canvas for processing (lightweight)
        this.heightMapCanvas = null;
        this.heightMapCtx = null;
    }

    init() {
        if (this.initialized) return;

        this.game.gameManager.register('getTerrainHeightAtPosition', this.getTerrainHeightAtPosition.bind(this));
        this.game.gameManager.register('getTerrainSize', () => this.terrainSize);
        this.game.gameManager.register('getTerrainTypeAtPosition', this.getTerrainTypeAtPosition.bind(this));
        this.game.gameManager.register('getTileMapTerrainType', this.getTileMapTerrainType.bind(this));
        this.game.gameManager.register('getTerrainTypeAtGridPosition', this.getTerrainTypeAtGridPosition.bind(this));

        // Load world data
        this.loadWorldData();

        // Initialize height map processing
        this.initializeHeightMapProcessing();

        this.initialized = true;
    }

    loadWorldData() {
        const collections = this.game.getCollections();
        if (!collections) {
            console.error('TerrainSystem: No collections found');
            return;
        }

        const currentLevel = this.game.state?.level || 'level1';
        this.level = collections.levels?.[currentLevel];
        
        if (!this.level) {
            console.error(`TerrainSystem: Level '${currentLevel}' not found`);
            return;
        }

        this.world = collections.worlds?.[this.level.world];
        if (!this.world) {
            console.error(`TerrainSystem: World '${this.level.world}' not found`);
            return;
        }

        this.heightMapSettings = collections.heightMaps?.[this.world.heightMap];
        this.heightStep = this.heightMapSettings?.heightStep || 10;
        this.tileMap = this.level.tileMap;

        // Calculate world dimensions
        this.terrainSize = this.tileMap.size * collections.configs.game.gridSize;
        this.extensionSize = this.world.extensionSize || 0;
        this.extendedSize = this.terrainSize + 2 * this.extensionSize;
    }

    initializeHeightMapProcessing() {
        if (!this.heightMapSettings?.enabled) {
            console.log('TerrainSystem: Height map disabled, using flat terrain');
            return;
        }

        // Check if we're running in a browser environment
        const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
        
        if (isBrowser) {
            // Create a small canvas for height map processing
            this.heightMapCanvas = document.createElement('canvas');
            this.heightMapCanvas.width = this.terrainSize;
            this.heightMapCanvas.height = this.terrainSize;
            this.heightMapCtx = this.heightMapCanvas.getContext('2d');
            this.processHeightMapFromCanvas();
        } else {
            // For server-side, we'll work directly with the terrain data
            console.log('TerrainSystem: Running in server mode, using data-only height processing');
            this.processHeightMapFromData();
        }
    }

    processHeightMapFromData() {
        if (!this.tileMap?.terrainMap) {
            console.warn('TerrainSystem: No terrain map data available');
            return;
        }

        // Initialize height map data array
        this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);

        // Check if we have a separate heightMap in the tileMap
        const hasHeightMap = this.tileMap.heightMap && this.tileMap.heightMap.length > 0;

        // Set extension area height
        let extensionHeight;
        if (hasHeightMap) {
            // Use extension height from tileMap if available
            extensionHeight = (this.tileMap.extensionHeight || 0) * this.heightStep;
        } else {
            // Fall back to old behavior: derive from terrain type
            const extensionTerrainType = this.tileMap.extensionTerrainType || 0;
            extensionHeight = extensionTerrainType * this.heightStep;
        }

        // Initialize all points with extension height
        for (let z = 0; z < this.extendedSize; z++) {
            for (let x = 0; x < this.extendedSize; x++) {
                this.heightMapData[z * this.extendedSize + x] = extensionHeight;
            }
        }

        const gridSize = this.game.getCollections().configs.game.gridSize;

        if (hasHeightMap) {
            // NEW: Use separate heightMap data from tileMap
            const heightData = this.tileMap.heightMap;

            for (let z = 0; z < heightData.length; z++) {
                for (let x = 0; x < heightData[z].length; x++) {
                    const heightLevel = heightData[z][x];
                    const height = heightLevel * this.heightStep;

                    // Map terrain coordinates to extended coordinates
                    const extX = x * gridSize + this.extensionSize;
                    const extZ = z * gridSize + this.extensionSize;

                    // Apply height to a region around this tile
                    const halfGrid = Math.floor(gridSize / 2);
                    for (let dz = -halfGrid; dz <= halfGrid; dz++) {
                        for (let dx = -halfGrid; dx <= halfGrid; dx++) {
                            const finalX = extX + dx;
                            const finalZ = extZ + dz;

                            if (finalX >= 0 && finalX < this.extendedSize &&
                                finalZ >= 0 && finalZ < this.extendedSize) {

                                const heightIndex = finalZ * this.extendedSize + finalX;
                                this.heightMapData[heightIndex] = height;
                            }
                        }
                    }
                }
            }

            console.log(`TerrainSystem: Processed height map from separate heightMap data - ${this.extendedSize}x${this.extendedSize}`);
        } else {
            // OLD: Derive heights from terrain types (backwards compatibility)
            const terrainMap = this.tileMap.terrainMap;

            for (let z = 0; z < terrainMap.length; z++) {
                for (let x = 0; x < terrainMap[z].length; x++) {
                    const terrainType = terrainMap[z][x];
                    const height = terrainType * this.heightStep;

                    // Map terrain coordinates to extended coordinates
                    const extX = x * gridSize + this.extensionSize;
                    const extZ = z * gridSize + this.extensionSize;

                    // Apply height to a region around this tile
                    const halfGrid = Math.floor(gridSize / 2);
                    for (let dz = -halfGrid; dz <= halfGrid; dz++) {
                        for (let dx = -halfGrid; dx <= halfGrid; dx++) {
                            const finalX = extX + dx;
                            const finalZ = extZ + dz;

                            if (finalX >= 0 && finalX < this.extendedSize &&
                                finalZ >= 0 && finalZ < this.extendedSize) {

                                const heightIndex = finalZ * this.extendedSize + finalX;
                                this.heightMapData[heightIndex] = height;
                            }
                        }
                    }
                }
            }

            console.log(`TerrainSystem: Processed height map from terrain type data (legacy) - ${this.extendedSize}x${this.extendedSize}`);
        }
    }

    processHeightMapFromCanvas() {
        // This method would be used if running client-side with canvas support
        // For now, fall back to data processing
        this.processHeightMapFromData();
    }

    getTileMapTerrainType(terrainTypeId){
        if(this.tileMap.terrainTypes.length > terrainTypeId && terrainTypeId >= 0){
            return this.tileMap.terrainTypes[terrainTypeId];
        }
        return null;
    }
    /**
     * Get terrain height at world position
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Terrain height
     */
    getTerrainHeightAtPosition(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates
        // The ground is centered at origin, so we need to offset by half the extended size
        const heightMapX = Math.floor(worldX + this.extendedSize / 2);
        const heightMapZ = Math.floor(worldZ + this.extendedSize / 2);
        
        // Ensure coordinates are within bounds
        if (heightMapX < 0 || heightMapX >= this.extendedSize || 
            heightMapZ < 0 || heightMapZ >= this.extendedSize) {
            // Outside terrain bounds, use extension terrain height
            const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
            return extensionTerrainType * this.heightStep;
        }
        
        // Get height from height map
        const heightIndex = heightMapZ * this.extendedSize + heightMapX;
        return this.heightMapData[heightIndex] || 0;
    }

    /**
     * Get terrain height with bilinear interpolation for smoother transitions
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Smoothly interpolated terrain height
     */
    getTerrainHeightAtPositionSmooth(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates (with decimal precision)
        const heightMapX = worldX + this.extendedSize / 2;
        const heightMapZ = worldZ + this.extendedSize / 2;
        
        // Get the four surrounding grid points
        const x0 = Math.floor(heightMapX);
        const x1 = x0 + 1;
        const z0 = Math.floor(heightMapZ);
        const z1 = z0 + 1;
        
        // Get fractional parts for interpolation
        const fx = heightMapX - x0;
        const fz = heightMapZ - z0;
        
        // Helper function to get height at specific grid point
        const getHeightAt = (x, z) => {
            if (x < 0 || x >= this.extendedSize || z < 0 || z >= this.extendedSize) {
                const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
                return extensionTerrainType * this.heightStep;
            }
            const heightIndex = z * this.extendedSize + x;
            return this.heightMapData[heightIndex] || 0;
        };
        
        // Get heights at the four corners
        const h00 = getHeightAt(x0, z0);
        const h10 = getHeightAt(x1, z0);
        const h01 = getHeightAt(x0, z1);
        const h11 = getHeightAt(x1, z1);
        
        // Bilinear interpolation
        const h0 = h00 * (1 - fx) + h10 * fx;
        const h1 = h01 * (1 - fx) + h11 * fx;
        return h0 * (1 - fz) + h1 * fz;
    }

    /**
     * Get terrain type at world position
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate  
     * @returns {number|null} Terrain type index, or null if outside bounds
     */
    getTerrainTypeAtPosition(worldX, worldZ) {
        if (!this.tileMap?.terrainMap) {
            return null;
        }

        const gridSize = this.game.getCollections().configs.game.gridSize;
        const terrainMap = this.tileMap.terrainMap;
        
        // Convert world coordinates to terrain grid coordinates
        const terrainX = Math.floor((worldX + this.terrainSize / 2) / gridSize);
        const terrainZ = Math.floor((worldZ + this.terrainSize / 2) / gridSize);
        
        // Check bounds
        if (terrainX < 0 || terrainX >= terrainMap[0]?.length || 
            terrainZ < 0 || terrainZ >= terrainMap.length) {
            // Outside terrain bounds, return extension terrain type
            return this.tileMap.extensionTerrainType || 0;
        }
        
        return terrainMap[terrainZ][terrainX];
    }

    getTerrainTypeAtGridPosition(gridX, gridZ) {
        if (!this.tileMap?.terrainMap) {
            return null;
        }

        const terrainMap = this.tileMap.terrainMap;

        if(terrainMap.length <= gridZ || gridZ < 0) {
            return null;
        }
        if(terrainMap[gridZ].length <= gridX || gridX < 0) {
            return null;
        }

        return terrainMap[gridZ][gridX];
    }

    /**
     * Get height level at grid position (not the actual height, but the level index)
     * @param {number} gridX - Grid X coordinate
     * @param {number} gridZ - Grid Z coordinate
     * @returns {number|null} Height level (0, 1, 2, etc.), or null if outside bounds
     */
    getHeightLevelAtGridPosition(gridX, gridZ) {
        // If we have a separate heightMap in tileMap, use it
        if (this.tileMap?.heightMap && this.tileMap.heightMap.length > 0) {
            const heightData = this.tileMap.heightMap;

            if (heightData.length <= gridZ || gridZ < 0) {
                return this.tileMap.extensionHeight || 0;
            }
            if (heightData[gridZ].length <= gridX || gridX < 0) {
                return this.tileMap.extensionHeight || 0;
            }

            return heightData[gridZ][gridX];
        }

        // Fall back to old behavior: derive from terrain type
        const terrainType = this.getTerrainTypeAtGridPosition(gridX, gridZ);
        return terrainType !== null ? terrainType : 0;
    }

    /**
     * Check if a position is within terrain bounds
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {boolean} True if within terrain bounds
     */
    isWithinTerrainBounds(worldX, worldZ) {
        const halfTerrain = this.terrainSize / 2;
        return worldX >= -halfTerrain && worldX <= halfTerrain &&
               worldZ >= -halfTerrain && worldZ <= halfTerrain;
    }

    /**
     * Check if a position is within extended terrain bounds (including extension)
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {boolean} True if within extended terrain bounds
     */
    isWithinExtendedBounds(worldX, worldZ) {
        const halfExtended = this.extendedSize / 2;
        return worldX >= -halfExtended && worldX <= halfExtended &&
               worldZ >= -halfExtended && worldZ <= halfExtended;
    }

    /**
     * Get terrain information at position including height, type, and bounds checking
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {Object} Terrain info object
     */
    getTerrainInfoAtPosition(worldX, worldZ) {
        return {
            height: this.getTerrainHeightAtPosition(worldX, worldZ),
            heightSmooth: this.getTerrainHeightAtPositionSmooth(worldX, worldZ),
            terrainType: this.getTerrainTypeAtPosition(worldX, worldZ),
            withinBounds: this.isWithinTerrainBounds(worldX, worldZ),
            withinExtendedBounds: this.isWithinExtendedBounds(worldX, worldZ)
        };
    }

    /**
     * Enforce terrain boundaries for movement
     * @param {Object} pos - Position object with x, z properties
     * @param {number} unitRadius - Unit radius for boundary checking
     */
    enforceBoundaries(pos, unitRadius = 25) {
        const halfTerrain = this.terrainSize / 2;
        
        pos.x = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.x));
        pos.z = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.z));
    }

    /**
     * Get safe spawn position within terrain bounds
     * @param {number} preferredX - Preferred X coordinate
     * @param {number} preferredZ - Preferred Z coordinate
     * @param {number} unitRadius - Unit radius for boundary checking
     * @returns {Object} Safe position with x, y, z coordinates
     */
    getSafeSpawnPosition(preferredX, preferredZ, unitRadius = 25) {
        const halfTerrain = this.terrainSize / 2;
        
        // Clamp to safe bounds
        const safeX = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, preferredX));
        const safeZ = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, preferredZ));
        
        // Get terrain height at safe position
        const height = this.getTerrainHeightAtPosition(safeX, safeZ);
        
        return {
            x: safeX,
            y: height,
            z: safeZ
        };
    }

    update() {
        // TerrainSystem is mostly static, minimal update needed
        if (!this.initialized) {
            this.init();
        }
    }

    destroy() {
        // Clean up resources
        this.heightMapData = null;
        this.heightMapCanvas = null;
        this.heightMapCtx = null;
        
        this.initialized = false;
    }
};

// system: AISystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['AISystem'] = class AISystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.aiSystem = this;
        this.entityAIControllers = new Map();
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('getAIControllerData', this.getAIControllerData.bind(this));
        this.game.gameManager.register('setAIControllerData', this.setAIControllerData.bind(this));
        this.game.gameManager.register('setCurrentAIController', this.setCurrentAIController.bind(this));
        this.game.gameManager.register('getCurrentAIController', this.getCurrentAIController.bind(this));
        this.game.gameManager.register('getCurrentAIControllerId', this.getCurrentAIControllerId.bind(this));
        this.game.gameManager.register('removeAIController', this.removeAIController.bind(this));
        this.game.gameManager.register('removeCurrentAIController', this.removeCurrentAIController.bind(this));
        this.game.gameManager.register('hasAIControllerData', this.hasAIControllerData.bind(this));
    }

    setAIControllerData(entityId, aiControllerId, data, overwriteControllerId = true) {
        let entityControllersMap = this.getEntityAIControllers(entityId);
        if(overwriteControllerId) {
            data.aiControllerId = aiControllerId;
        }
        entityControllersMap.set(aiControllerId, data);
    }

    hasAIControllerData(entityId, aiControllerId){
        let entityControllersMap = this.getEntityAIControllers(entityId);
        const CT = this.game.componentManager.getComponents();        
        return entityControllersMap.has(aiControllerId);
    }

    getAIControllerData(entityId, aiControllerId) {
        let entityControllersMap = this.getEntityAIControllers(entityId);
        const CT = this.game.componentManager.getComponents();        
        return entityControllersMap.get(aiControllerId) || CT.AIState('idle');
    }

    setCurrentAIController(entityId, aiControllerId, data) {
        this.setAIControllerData(entityId, aiControllerId, data);
        this.setAIControllerData(entityId, "AISystem", data, false);

        let aiState = this.game.getComponent(entityId, this.game.componentTypes.AI_STATE);
        aiState.targetPosition = data.targetPosition;
        aiState.target = data.target;
        aiState.meta = data.meta;
        aiState.aiControllerId = aiControllerId;

        // CRITICAL: Always clear path when switching controllers
        // This prevents units from continuing old paths before executing new commands
        aiState.path = [];
        aiState.pathIndex = 0;
        aiState.useDirectMovement = false;
        console.log('setCurrentAIController:', entityId, data.targetPosition, aiState.targetPosition);

        // Update state based on new target
        if (data.targetPosition || data.target) {
            aiState.state = data.state || 'chasing';
        } else {
            aiState.state = data.state || 'idle';
        }
    }

    getCurrentAIController(entityId) {
        return this.getAIControllerData(entityId, "AISystem");
    }

    getCurrentAIControllerId(entityId) {
        return this.getAIControllerData(entityId, "AISystem").aiControllerId;
    }

    removeAIController(entityId, aiControllerId){
        let entityControllersMap = this.getEntityAIControllers(entityId);
        entityControllersMap.delete(aiControllerId);
    }

    removeCurrentAIController(entityId){    
        const currentAiControllerId = this.getCurrentAIControllerId();
        this.removeAIController(entityId, currentAiControllerId);
        const CT = this.game.componentManager.getComponents();        
        this.setAIControllerData(entityId, "AISystem", CT.AIState('idle'), false);
    }

    getEntityAIControllers(entityId) {
        let entityControllersMap = this.entityAIControllers.get(entityId);
        if(!entityControllersMap){
            entityControllersMap = new Map();
            this.entityAIControllers.set(entityId, entityControllersMap);
        }
        return entityControllersMap;
    }

    entityDestroyed(entityId) {
        this.entityAIControllers.delete(entityId);
    }

};

// system: CommandQueueSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CommandQueueSystem'] = class CommandQueueSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.commandQueueSystem = this;

        // Command priority levels
        this.PRIORITY = {
            IDLE: 0,           // Default/automatic behavior (mining, patrolling)
            MOVE: 10,          // Player move commands
            BUILD: 20,         // Building construction
            ATTACK: 30,        // Attack commands
            ABILITY: 40,       // Special abilities
            FORCED: 100        // Force commands (cannot be interrupted)
        };
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('queueCommand', this.queueCommand.bind(this));
        this.game.gameManager.register('executeCommand', this.executeCommand.bind(this));
        this.game.gameManager.register('clearCommands', this.clearCommands.bind(this));
        this.game.gameManager.register('getCurrentCommand', this.getCurrentCommand.bind(this));
        this.game.gameManager.register('canInterruptCommand', this.canInterruptCommand.bind(this));
    }

    /**
     * Queue a command for a unit
     * @param {string} entityId - The unit entity ID
     * @param {object} commandData - Command data (type, controllerId, targetPosition, etc.)
     * @param {boolean} interrupt - Whether to interrupt current command if priority is higher
     * @returns {boolean} - Whether the command was queued/executed
     */
    queueCommand(entityId, commandData, interrupt = true) {
        const ComponentTypes = this.game.componentTypes;
        const Components = this.game.componentManager.getComponents();
;
        // Ensure unit has a command queue
        let commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);
        if (!commandQueue) {
            commandQueue = Components.CommandQueue();
            this.game.addComponent(entityId, ComponentTypes.COMMAND_QUEUE, commandQueue);
        }

        // Create the command
        const command = Components.Command(
            commandData.type,
            commandData.controllerId,
            commandData.targetPosition,
            commandData.target,
            commandData.meta || {},
            commandData.priority || this.PRIORITY.MOVE,
            commandData.interruptible !== false, // Default to true
            this.game.state.now
        );

        // Check if we should interrupt current command
        if (interrupt && commandQueue.currentCommand) {
            if (this.canInterruptCommand(entityId, command.priority)) {
                // Store current command as cancelled in history
                commandQueue.commandHistory.push({
                    ...commandQueue.currentCommand,
                    cancelled: true,
                    cancelTime: this.game.state.now
                });

                // Execute new command immediately
                this.executeCommand(entityId, command);
                return true;
            } else {
                // Queue it for later
                commandQueue.commands.push(command);
                // Sort by priority (highest first)
                commandQueue.commands.sort((a, b) => b.priority - a.priority);
                return true;
            }
        } else if (!commandQueue.currentCommand) {
            // No current command, execute immediately
            this.executeCommand(entityId, command);
            return true;
        } else {
            // Queue it for later
            commandQueue.commands.push(command);
            commandQueue.commands.sort((a, b) => b.priority - a.priority);
            return true;
        }
    }

    /**
     * Execute a command for a unit
     * @param {string} entityId - The unit entity ID
     * @param {object} command - The command to execute
     */
    executeCommand(entityId, command) {
        const ComponentTypes = this.game.componentTypes;
        const Components = this.game.componentManager.getComponents();

        // Get command queue
        let commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);
        if (!commandQueue) {
            commandQueue = Components.CommandQueue();
            this.game.addComponent(entityId, ComponentTypes.COMMAND_QUEUE, commandQueue);
        }

        // Set as current command
        commandQueue.currentCommand = command;

        // Get AI state
        const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
        if (!aiState) return;

        // CRITICAL: Always clear the path when executing a new command
        aiState.path = [];
        aiState.pathIndex = 0;
        aiState.useDirectMovement = false;

        // Get controller data for this command
        let controllerData = this.game.aiSystem.getAIControllerData(entityId, command.controllerId);

        // Update controller data with command parameters
        controllerData.targetPosition = command.targetPosition;
        controllerData.target = command.target;
        controllerData.meta = command.meta;
        controllerData.state = command.targetPosition || command.target ? 'chasing' : 'idle';

        // Switch to the command's controller
        this.game.aiSystem.setCurrentAIController(entityId, command.controllerId, controllerData);

        // Debug logging
        if (this.game.debug) {
            console.log(`[CommandQueue] Executing ${command.type} command for ${entityId}`, {
                controllerId: command.controllerId,
                targetPosition: command.targetPosition,
                priority: command.priority
            });
        }
    }

    /**
     * Clear all commands for a unit
     * @param {string} entityId - The unit entity ID
     */
    clearCommands(entityId) {
        const ComponentTypes = this.game.componentTypes;
        const commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);

        if (commandQueue) {
            commandQueue.commands = [];
            if (commandQueue.currentCommand) {
                commandQueue.commandHistory.push({
                    ...commandQueue.currentCommand,
                    cancelled: true,
                    cancelTime: this.game.state.now
                });
                commandQueue.currentCommand = null;
            }
        }
    }

    /**
     * Get current command for a unit
     * @param {string} entityId - The unit entity ID
     * @returns {object|null} - The current command or null
     */
    getCurrentCommand(entityId) {
        const ComponentTypes = this.game.componentTypes;
        const commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);
        return commandQueue?.currentCommand || null;
    }

    /**
     * Check if a command can be interrupted by a higher priority command
     * @param {string} entityId - The unit entity ID
     * @param {number} newPriority - Priority of the new command
     * @returns {boolean} - Whether the current command can be interrupted
     */
    canInterruptCommand(entityId, newPriority) {
        const currentCommand = this.getCurrentCommand(entityId);

        if (!currentCommand) return true;
        if (!currentCommand.interruptible) return false;

        return newPriority > currentCommand.priority;
    }

    /**
     * Complete the current command and move to next in queue
     * @param {string} entityId - The unit entity ID
     */
    completeCurrentCommand(entityId) {
        const ComponentTypes = this.game.componentTypes;
        const commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);

        if (!commandQueue) return;

        // Move current command to history
        if (commandQueue.currentCommand) {
            commandQueue.commandHistory.push({
                ...commandQueue.currentCommand,
                completedTime: this.game.state.now
            });
            commandQueue.currentCommand = null;
        }

        // Execute next command in queue if available
        if (commandQueue.commands.length > 0) {
            const nextCommand = commandQueue.commands.shift();
            this.executeCommand(entityId, nextCommand);
        } else {
            // No more commands, return to idle
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
            if (aiState) {
                aiState.state = 'idle';
                aiState.targetPosition = null;
                aiState.target = null;
                aiState.path = [];
                aiState.pathIndex = 0;
                aiState.meta = {};
                aiState.aiControllerId = "";
            }
        }
    }

    /**
     * Update command queue system
     * Called every frame to check if commands need to be processed
     */
    onPlacementPhaseStart() {
        const ComponentTypes = this.game.componentTypes;
        const entities = this.game.getEntitiesWith(ComponentTypes.COMMAND_QUEUE, ComponentTypes.AI_STATE);

        for (let i = 0; i < entities.length; i++) {
            const entityId = entities[i];
            const commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);

            // Check if current command is complete
            if (commandQueue.currentCommand) {
                // Command completion is handled by individual systems (BuildAbility, MineGoldAbility, etc.)
                // They should call completeCurrentCommand when done

                // However, we can check for some automatic completions:
                // - If target position is reached and no special state
                if (aiState.state === 'idle' && commandQueue.currentCommand.type === 'move') {
                    // Move command completed
                    this.completeCurrentCommand(entityId);
                }
            }
        }
    }

    /**
     * Clean up command queue when entity is destroyed
     */
    entityDestroyed(entityId) {
        // Nothing to clean up - component will be removed automatically
    }
}
;

// system: MovementSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MovementSystem'] = class MovementSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.movementSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.DEFAULT_UNIT_RADIUS = 25;
        this.MIN_MOVEMENT_THRESHOLD = 0.1;
        
        this.AI_SPEED_MULTIPLIER = 0.1;
        this.DEFAULT_AI_SPEED = 50;
        this.POSITION_UPDATE_MULTIPLIER = 1;
        this.DEFAULT_TERRAIN_SIZE = 768 * 2;
        
        this.GRAVITY = 200;
        this.GROUND_LEVEL = 0;
        this.GROUND_IMPACT_THRESHOLD = 5;
        this.TERRAIN_FOLLOW_SPEED = 8;
        
        this.SEPARATION_FORCE = 80;
        this.SEPARATION_RADIUS_MULTIPLIER = 0.1;
        this.MAX_SEPARATION_CHECKS = 8;
        this.AVOIDANCE_SMOOTHING = 0.15;
        
        this.PATHFINDING_LOOKAHEAD = 100;
        this.OBSTACLE_AVOIDANCE_FORCE = 70;
        this.AVOIDANCE_ANGLE = Math.PI / 3;
        this.STUCK_THRESHOLD = 5;
        this.STUCK_TIME_LIMIT = 2000;
        this.REPATH_DISTANCE = 50;
        
        this.PATH_REACHED_DISTANCE = 3;
        this.PATH_REREQUEST_INTERVAL = 0.5;
        
        this.SPATIAL_GRID_SIZE = 80;
        this.MAX_PATHFINDING_CHECKS = 6;
        this.PATHFINDING_CHECK_POINTS = 3;
        this.PATHFINDING_UPDATE_INTERVAL = 3;
        this.NEAR_UNIT_RADIUS = 150;
        
        this.VELOCITY_SMOOTHING = 0.9;
        this.DIRECTION_SMOOTHING = 0.9;
        this.FORCE_DAMPING = 0.85;
        this.MIN_DIRECTION_CHANGE = 0.1;
        this.OSCILLATION_DETECTION_FRAMES = 5;
        this.OSCILLATION_THRESHOLD = Math.PI / 6;
        
        this.unitStates = new Map();
        this.frameCounter = 0;
        this.pathfindingQueue = [];
        this.pathfindingQueueIndex = 0;
        
        this.movementHistory = new Map();
    }
    
    update() {
        if (this.game.state.phase !== 'battle') return;
        
        this.frameCounter++;
        const entities = this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.VELOCITY);        
        
        const unitData = new Map();
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(entityId, this.componentTypes.VELOCITY);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);
            const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            
            if (!projectile) {
                const unitRadius = this.getUnitRadius(collision);

                const isAnchored = vel.anchored ||
                    (!!aiState &&
                    (aiState.state === 'attacking' || aiState.state === 'waiting') &&
                    aiState.aiBehavior &&
                    !!aiState.target);

                unitData.set(entityId, {
                    pos, vel, unitType, collision, aiState, projectile,
                    unitRadius,
                    isAnchored,
                    desiredVelocity: { vx: 0, vy: 0, vz: 0 },
                    separationForce: { x: 0, y: 0, z: 0 },
                    avoidanceForce: { x: 0, y: 0, z: 0 }
                });
                
                this.updateUnitState(entityId, pos, vel);
                this.updateMovementHistory(entityId, vel);
            }
        });
        
        const sortedEntityIds = Array.from(unitData.keys());

        sortedEntityIds.forEach((entityId) => {
            this.calculateDesiredVelocity(entityId, unitData.get(entityId));
        });
        
        sortedEntityIds.forEach((entityId) => {
            this.calculateSeparationForceOptimized(entityId, unitData.get(entityId));
        });
        
        this.updatePathfindingStaggered(unitData);
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(entityId, this.componentTypes.VELOCITY);
            const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            
            const isAffectedByGravity = vel.affectedByGravity;
            
            if (!projectile && unitData.has(entityId)) {
                let entityData = unitData.get(entityId);
                if(vel.vx != 0 || vel.vz != 0 || entityData.desiredVelocity.vx != 0 || entityData.desiredVelocity.vz != 0){
                    this.applyUnitMovementWithSmoothing(entityId, unitData.get(entityId));
                }
            }
            
            if (isAffectedByGravity) {
                vel.vy -= this.GRAVITY * this.game.state.deltaTime;
            }
            
            pos.x += vel.vx * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
            pos.y += vel.vy * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
            pos.z += vel.vz * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
      
            if(!projectile){
                this.handleGroundInteraction(pos, vel);
                if(!vel.anchored){
                    this.enforceBoundaries(pos, collision);
                }
                 
                this.game.triggerEvent("onEntityPositionUpdated", entityId);
            }
        });
    }
    
    updateMovementHistory(entityId, vel) {
        if (!this.movementHistory.has(entityId)) {
            this.movementHistory.set(entityId, {
                velocityHistory: [],
                smoothedDirection: { x: 0, z: 0 },
                dampedForces: { separation: { x: 0, z: 0 }, avoidance: { x: 0, z: 0 } }
            });
        }
        
        const history = this.movementHistory.get(entityId);
        
        history.velocityHistory.push({ 
            vx: vel.vx, 
            vz: vel.vz, 
            frame: this.frameCounter 
        });
        
        if (history.velocityHistory.length > this.OSCILLATION_DETECTION_FRAMES) {
            history.velocityHistory.shift();
        }
    }
    
    isUnitOscillating(entityId) {
        const history = this.movementHistory.get(entityId);
        if (!history || history.velocityHistory.length < this.OSCILLATION_DETECTION_FRAMES) {
            return false;
        }
        
        let directionChanges = 0;
        let lastDirection = null;
        
        for (const vel of history.velocityHistory) {
            const speed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
            if (speed < 0.1) continue;
            
            const direction = Math.atan2(vel.vz, vel.vx);
            if (lastDirection !== null) {
                let angleDiff = Math.abs(direction - lastDirection);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                if (angleDiff > this.OSCILLATION_THRESHOLD) {
                    directionChanges++;
                }
            }
            lastDirection = direction;
        }
        
        return directionChanges >= 2;
    }
    
    updatePathfindingStaggered(unitData) {
        if (this.pathfindingQueue.length === 0) {
            const sortedEntityIds = Array.from(unitData.keys()).sort((a, b) => String(a).localeCompare(String(b)));
            sortedEntityIds.forEach(entityId => {
                const data = unitData.get(entityId);
                if (data.aiState?.state === 'chasing') {
                    this.pathfindingQueue.push(entityId);
                }
            });
        }
        
        const unitsPerFrame = Math.max(1, Math.ceil(this.pathfindingQueue.length / this.PATHFINDING_UPDATE_INTERVAL));
        
        for (let i = 0; i < unitsPerFrame && this.pathfindingQueueIndex < this.pathfindingQueue.length; i++) {
            const entityId = this.pathfindingQueue[this.pathfindingQueueIndex];
            if (unitData.has(entityId)) {
                this.calculatePathfindingAvoidanceOptimized(entityId, unitData.get(entityId), unitData);
            }
            this.pathfindingQueueIndex++;
        }
        
        if (this.pathfindingQueueIndex >= this.pathfindingQueue.length) {
            this.pathfindingQueueIndex = 0;
            this.pathfindingQueue = [];
        }
    }
    
    updateUnitState(entityId, pos, vel) {
        const currentTime = this.game.state.now;
        
        if (!this.unitStates.has(entityId)) {
            this.unitStates.set(entityId, {
                lastPosition: { x: pos.x, z: pos.z },
                lastMovementTime: currentTime,
                stuckTime: 0,
                lastPathTime: 0,
                avoidanceDirection: 0
            });
            return;
        }
        
        const state = this.unitStates.get(entityId);
        const speed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
        const distanceMoved = Math.sqrt(
            Math.pow(pos.x - state.lastPosition.x, 2) + 
            Math.pow(pos.z - state.lastPosition.z, 2)
        );
        
        if (speed < this.STUCK_THRESHOLD && distanceMoved < 1) {
            state.stuckTime += this.game.state.deltaTime;
        } else {
            state.stuckTime = 0;
            state.lastPosition.x = pos.x;
            state.lastPosition.z = pos.z;
        }
        
        if (distanceMoved > this.REPATH_DISTANCE) {
            state.avoidanceDirection = 0;
            state.lastPathTime = currentTime;
        }
    }
    
    calculateSeparationForceOptimized(entityId, data) {
        const { pos, unitRadius, isAnchored } = data;

        if (isAnchored) {
            data.separationForce.x = 0;
            data.separationForce.y = 0;
            data.separationForce.z = 0;
            return;
        }
        
        const separationRadius = unitRadius * this.SEPARATION_RADIUS_MULTIPLIER;
        const nearbyUnits = this.game.gameManager.call('getNearbyUnits', pos, separationRadius, entityId);
        
        let separationForceX = 0;
        let separationForceZ = 0;
        let neighborCount = 0;
        let checksPerformed = 0;
        
        for (const otherEntityId of nearbyUnits) {
            if (checksPerformed >= this.MAX_SEPARATION_CHECKS) break;
            
            checksPerformed++;
            
            const otherPos = this.game.getComponent(otherEntityId, this.componentTypes.POSITION);
            const otherCollision = this.game.getComponent(otherEntityId, this.componentTypes.COLLISION);
            
            if (!otherPos) continue;
            
            const otherRadius = this.getUnitRadius(otherCollision);
            
            const dx = pos.x - otherPos.x;
            const dz = pos.z - otherPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            const minDistance = unitRadius + otherRadius;
            const influenceDistance = Math.max(minDistance, separationRadius);
            
            if (distance < influenceDistance && distance > 0.1) {
                const force = this.SEPARATION_FORCE * (influenceDistance - distance) / influenceDistance;
                
                const dirX = dx / distance;
                const dirZ = dz / distance;
                
                separationForceX += dirX * force;
                separationForceZ += dirZ * force;
                neighborCount++;
            }
        }
        
        if (neighborCount > 0) {
            const history = this.movementHistory.get(entityId);
            if (history) {
                const dampedSeparation = history.dampedForces.separation;
                dampedSeparation.x *= this.FORCE_DAMPING;
                dampedSeparation.z *= this.FORCE_DAMPING;
                
                separationForceX = (separationForceX / neighborCount) * 0.7 + dampedSeparation.x * 0.3;
                separationForceZ = (separationForceZ / neighborCount) * 0.7 + dampedSeparation.z * 0.3;
                
                dampedSeparation.x = separationForceX;
                dampedSeparation.z = separationForceZ;
            } else {
                separationForceX /= neighborCount;
                separationForceZ /= neighborCount;
            }
        }
        
        data.separationForce.x = separationForceX;
        data.separationForce.z = separationForceZ;
    }
    
    calculatePathfindingAvoidanceOptimized(entityId, data, allUnitData) {
        const { pos, vel, aiState, unitRadius, isAnchored } = data;

        if (isAnchored || !aiState || aiState.state !== 'chasing') {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        let targetPos = aiState.targetPosition;
        const targetEntityId = aiState.target;

        if(targetEntityId){
            targetPos = this.game.getComponent(targetEntityId, this.componentTypes.POSITION);
        }
        
        if (!targetPos) {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        const desiredDirection = {
            x: targetPos.x - pos.x,
            z: targetPos.z - pos.z
        };
        
        const desiredDistance = Math.sqrt(desiredDirection.x * desiredDirection.x + desiredDirection.z * desiredDirection.z);
        
        if (desiredDistance < 0.1) {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        desiredDirection.x /= desiredDistance;
        desiredDirection.z /= desiredDistance;
        
        const obstacleInfo = this.findObstaclesInPathOptimized(pos, desiredDirection, unitRadius, entityId, targetEntityId);
        
        if (obstacleInfo.hasObstacle) {
            const unitState = this.unitStates.get(entityId);
            const avoidanceForce = this.calculateAvoidanceVector(
                pos, desiredDirection, obstacleInfo, unitState, unitRadius
            );
            
            const history = this.movementHistory.get(entityId);
            if (history) {
                const dampedAvoidance = history.dampedForces.avoidance;
                dampedAvoidance.x *= this.FORCE_DAMPING;
                dampedAvoidance.z *= this.FORCE_DAMPING;
                
                const blendedX = avoidanceForce.x * 0.6 + dampedAvoidance.x * 0.4;
                const blendedZ = avoidanceForce.z * 0.6 + dampedAvoidance.z * 0.4;
                
                dampedAvoidance.x = blendedX;
                dampedAvoidance.z = blendedZ;
                
                data.avoidanceForce.x = blendedX;
                data.avoidanceForce.z = blendedZ;
            } else {
                data.avoidanceForce.x = avoidanceForce.x;
                data.avoidanceForce.z = avoidanceForce.z;
            }
        } else {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
        }
    }
    
    findObstaclesInPathOptimized(pos, direction, unitRadius, entityId, targetEntityId = null) {
        const lookaheadDistance = this.PATHFINDING_LOOKAHEAD;
        const checkRadius = unitRadius * 1.5;
        
        const nearbyUnits = this.game.gameManager.call('getNearbyUnits', pos, lookaheadDistance + checkRadius, entityId);
        
        let closestObstacle = null;
        let closestDistance = Infinity;
        let checksPerformed = 0;
        
        for (let i = 1; i <= this.PATHFINDING_CHECK_POINTS; i++) {
            const checkDistance = (lookaheadDistance / this.PATHFINDING_CHECK_POINTS) * i;
            const checkPos = {
                x: pos.x + direction.x * checkDistance,
                z: pos.z + direction.z * checkDistance
            };
            
            for (const otherEntityId of nearbyUnits) {
                if (targetEntityId && otherEntityId === targetEntityId) continue;
                if (checksPerformed >= this.MAX_PATHFINDING_CHECKS) break;
                
                checksPerformed++;
                
                const otherPos = this.game.getComponent(otherEntityId, this.componentTypes.POSITION);
                const otherCollision = this.game.getComponent(otherEntityId, this.componentTypes.COLLISION);
                
                if (!otherPos) continue;
                
                const otherRadius = this.getUnitRadius(otherCollision);
                
                const dx = checkPos.x - otherPos.x;
                const dz = checkPos.z - otherPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const minDistance = checkRadius + otherRadius;
                
                if (distance < minDistance && distance < closestDistance) {
                    closestDistance = distance;
                    closestObstacle = {
                        pos: otherPos,
                        radius: otherRadius,
                        distance: distance,
                        entityId: otherEntityId
                    };
                }
            }
            
            if (checksPerformed >= this.MAX_PATHFINDING_CHECKS) break;
        }
        
        return {
            hasObstacle: closestObstacle !== null,
            obstacle: closestObstacle
        };
    }
    
    calculateAvoidanceVector(pos, desiredDirection, obstacleInfo, unitState, unitRadius) {
        if (!obstacleInfo.hasObstacle) {
            return { x: 0, z: 0 };
        }
        
        const obstacle = obstacleInfo.obstacle;
        const toObstacle = {
            x: obstacle.pos.x - pos.x,
            z: obstacle.pos.z - pos.z
        };
        
        const obstacleDistance = Math.sqrt(toObstacle.x * toObstacle.x + toObstacle.z * toObstacle.z);
        
        if (obstacleDistance < 0.1) {
            return { x: 0, z: 0 };
        }
        
        toObstacle.x /= obstacleDistance;
        toObstacle.z /= obstacleDistance;
        
        let avoidanceDirection = unitState?.avoidanceDirection || 0;
        
        if (avoidanceDirection === 0) {
            const perpLeft = { x: -toObstacle.z, z: toObstacle.x };
            const perpRight = { x: toObstacle.z, z: -toObstacle.x };
            
            const leftAlignment = perpLeft.x * desiredDirection.x + perpLeft.z * desiredDirection.z;
            const rightAlignment = perpRight.x * desiredDirection.x + perpRight.z * desiredDirection.z;
            
            avoidanceDirection = leftAlignment > rightAlignment ? 1 : -1;
            
            if (unitState) {
                unitState.avoidanceDirection = avoidanceDirection;
            }
        }
        
        const avoidanceVector = {
            x: -toObstacle.z * avoidanceDirection,
            z: toObstacle.x * avoidanceDirection
        };
        
        const minDistance = unitRadius + obstacle.radius + 10;
        const avoidanceStrength = Math.max(0, (minDistance - obstacleDistance) / minDistance);
        const force = this.OBSTACLE_AVOIDANCE_FORCE * avoidanceStrength;
        
        return {
            x: avoidanceVector.x * force,
            z: avoidanceVector.z * force
        };
    }
    
    calculateDesiredVelocity(entityId, data) {
        const { pos, vel, aiState, isAnchored } = data;

        if (isAnchored || !aiState) {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
            return;
        }
        
        if (aiState.state === 'waiting' || aiState.state === 'idle') {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
            return;
        }
        
        if (aiState.state === 'chasing' && aiState.aiBehavior && (aiState.targetPosition || aiState.target)) {
            // Check if we should use direct movement (line of sight to target)
            if (aiState.useDirectMovement) {
                // Move directly toward target using steering behaviors
                this.moveDirectlyToTarget(entityId, data);
            } else {
                // Use pathfinding for navigation
                this.requestPathIfNeeded(entityId, data);

                if (aiState.path && aiState.path.length > 0) {
                    this.followPath(entityId, data);
                } else {
                    data.desiredVelocity.vx = 0;
                    data.desiredVelocity.vy = 0;
                    data.desiredVelocity.vz = 0;
                }
            }
        } else if (aiState.state === 'attacking') {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
        } else {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
        }
    }
    
    moveDirectlyToTarget(entityId, data) {
        const { pos, vel, aiState } = data;

        let targetPos = aiState.targetPosition;
        if (aiState.target) {
            const currentTargetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);
            if (currentTargetPos) {
                targetPos = currentTargetPos;
            }
        }

        if (!targetPos) {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vz = 0;
            data.desiredVelocity.vy = 0;
            return;
        }

        const dx = targetPos.x - pos.x;
        const dz = targetPos.z - pos.z;
        const distToTarget = Math.sqrt(dx * dx + dz * dz);

        if (distToTarget < 0.1) {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vz = 0;
            data.desiredVelocity.vy = 0;
            return;
        }

        const moveSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED);
        data.desiredVelocity.vx = (dx / distToTarget) * moveSpeed;
        data.desiredVelocity.vz = (dz / distToTarget) * moveSpeed;
        data.desiredVelocity.vy = 0;
    }

    requestPathIfNeeded(entityId, data) {
        const { pos, aiState } = data;
        const now = this.game.state.now;
        if(!aiState.aiBehavior){
            aiState.aiBehavior = {};
        }
        if (!aiState.aiBehavior.lastPathRequest || (now - aiState.aiBehavior.lastPathRequest) > this.PATH_REREQUEST_INTERVAL) {
            aiState.aiBehavior.lastPathRequest = now;

            let targetPos = aiState.targetPosition;
            if (aiState.target) {
                targetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);
            }

            if ((!aiState.path || aiState.path.length == 0) && targetPos) {
                aiState.path = this.game.gameManager.call('requestPath',
                    entityId,
                    pos.x,
                    pos.z,
                    targetPos.x,
                    targetPos.z,
                    1
                );
            }
        }
    }
    
    followPath(entityId, data) {
        const { pos, vel, aiState } = data;
        
        if (aiState.pathIndex === undefined) {
            aiState.pathIndex = 0;
        }
        
        if (aiState.pathIndex >= aiState.path.length) {
            aiState.path = null;
            aiState.pathIndex = 0;
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vz = 0;
            data.desiredVelocity.vy = 0;
            return;
        }
        const waypoint = aiState.path[aiState.pathIndex];
        const dx = waypoint.x - pos.x;
        const dz = waypoint.z - pos.z;
        const distToWaypoint = Math.sqrt(dx * dx + dz * dz);
        
        if (distToWaypoint < this.PATH_REACHED_DISTANCE) {
            aiState.pathIndex++;
            if (aiState.pathIndex >= aiState.path.length) {
                aiState.path = null;
                aiState.pathIndex = 0;
            }
            return;
        }
        
        const moveSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED);
        data.desiredVelocity.vx = (dx / distToWaypoint) * moveSpeed;
        data.desiredVelocity.vz = (dz / distToWaypoint) * moveSpeed;
        data.desiredVelocity.vy = 0;
    }
    
    applyUnitMovementWithSmoothing(entityId, data) {
        const { vel, desiredVelocity, separationForce, avoidanceForce, isAnchored } = data;

        if (isAnchored) {
            vel.vx = 0;
            vel.vz = 0;
            vel.vy = desiredVelocity.vy || vel.vy || 0;
            return;
        }
        
        const history = this.movementHistory.get(entityId);
        const isOscillating = this.isUnitOscillating(entityId);
        
        let targetVx = desiredVelocity.vx + separationForce.x + avoidanceForce.x;
        let targetVz = desiredVelocity.vz + separationForce.z + avoidanceForce.z;
        
        if (isOscillating) {
            targetVx = desiredVelocity.vx + (separationForce.x + avoidanceForce.x) * 0.3;
            targetVz = desiredVelocity.vz + (separationForce.z + avoidanceForce.z) * 0.3;
        }
        
        const velocitySmoothing = isOscillating ? this.VELOCITY_SMOOTHING * 0.5 : this.VELOCITY_SMOOTHING;
        const directionSmoothing = isOscillating ? this.DIRECTION_SMOOTHING * 0.3 : this.DIRECTION_SMOOTHING;
        
        const newVx = this.lerp(vel.vx, targetVx, velocitySmoothing);
        const newVz = this.lerp(vel.vz, targetVz, velocitySmoothing);

        // Only apply direction smoothing if there's actual desired movement
        // If targetVx and targetVz are both near zero, skip smoothing to preserve current facing
        const targetSpeedSqrd = targetVx * targetVx + targetVz * targetVz;
        const hasTargetMovement = targetSpeedSqrd > 0.01;

        if (history && history.smoothedDirection && hasTargetMovement) {
            const targetDirection = Math.atan2(targetVz, targetVx);

            let currentDirection;
            const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);

            if (currentSpeed < this.MIN_MOVEMENT_THRESHOLD) {
                const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
                currentDirection = facing ? facing.angle : 0;
            } else {
                currentDirection = Math.atan2(vel.vz, vel.vx);
            }

            let directionDiff = targetDirection - currentDirection;
            if (directionDiff > Math.PI) directionDiff -= 2 * Math.PI;
            if (directionDiff < -Math.PI) directionDiff += 2 * Math.PI;

            if (Math.abs(directionDiff) > this.MIN_DIRECTION_CHANGE) {
                const smoothedDirection = currentDirection + directionDiff * directionSmoothing;
                const speed = Math.sqrt(newVx * newVx + newVz * newVz);

                if (speed > 0.1) {
                    vel.vx = Math.cos(smoothedDirection) * speed;
                    vel.vz = Math.sin(smoothedDirection) * speed;

                    const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
                    if (facing) {
                        facing.angle = smoothedDirection;
                    }
                } else {
                    vel.vx = newVx;
                    vel.vz = newVz;
                }
            } else {
                vel.vx = newVx;
                vel.vz = newVz;
            }
        } else {
            vel.vx = newVx;
            vel.vz = newVz;
        }
        
        vel.vy = desiredVelocity.vy;

        const speedSqrd = vel.vx * vel.vx + vel.vz * vel.vz;
        if (speedSqrd < this.MIN_MOVEMENT_THRESHOLD * this.MIN_MOVEMENT_THRESHOLD) {
            // Preserve facing direction before zeroing velocity
            if (speedSqrd > 0.001) {
                const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
                if (facing) {
                    facing.angle = Math.atan2(vel.vz, vel.vx);
                }
            }
            vel.vx = 0;
            vel.vz = 0;
        }
        
        const maxSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED) * 1.4;
        const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
        if (currentSpeed > maxSpeed) {
            const speedRatio = maxSpeed / currentSpeed;
            vel.vx *= speedRatio;
            vel.vz *= speedRatio;
        }
    }
    
    lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    shouldApplyGravity(entityId, projectile, unitType) {
        if (projectile) {
            return true;
        }
        
        if (unitType) {
            const collections = this.game.getCollections && this.game.getCollections();
            if (collections && collections.units) {
                const unitDef = collections.units[unitType.id];
                if (unitDef && unitDef.flying) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    handleGroundInteraction(pos, vel) {
        const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z);
        
        if (terrainHeight !== null) {
            const targetHeight = terrainHeight;   
            pos.y = targetHeight;
            
            if (pos.y <= targetHeight + 0.1) {
                vel.vy = Math.max(0, vel.vy);
            }
        } else {
            if (pos.y < this.GROUND_LEVEL) {
                pos.y = this.GROUND_LEVEL;
                vel.vy = Math.max(0, vel.vy);
            }
        }
    }
    
    
    enforceBoundaries(pos, collision) {
        const collections = this.game.getCollections();
        const currentLevel = this.game.state.level;
        const level = collections.levels[currentLevel];        
        const tileMap = level.tileMap;

        const terrainSize = tileMap.size * collections.configs.game.gridSize;
        const halfTerrain = terrainSize / 2;
        const unitRadius = this.getUnitRadius(collision);
        

        pos.x = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.x));
        pos.z = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.z));
    }
    
    getUnitRadius(collision) {
        if (collision && collision.radius) {
            return Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius);
        }
        return this.DEFAULT_UNIT_RADIUS;
    }
    
    entityDestroyed(entityId) {
        
        if (this.unitStates) {
            this.unitStates.delete(entityId);
        }
        
        if (this.movementTracking) {
            this.movementTracking.delete(entityId);
        }
        
        if (this.movementHistory) {
            this.movementHistory.delete(entityId);
        }
    }

    ping() {
        console.log('pong');
    }
};

// system: CombatAISystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CombatAISystem'] = class CombatAISystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.combatAISystems = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.DEFAULT_UNIT_RADIUS = 25;
        this.ATTACK_RANGE_BUFFER = 10;
        this.ALLY_SPACING_DISTANCE = 10;
        this.ENEMY_SPACING_DISTANCE = 5;
        this.AVOIDANCE_RADIUS_MULTIPLIER = 1;
        this.STRONG_AVOIDANCE_FORCE = 50;
        this.GENTLE_AVOIDANCE_FORCE = 10;

        this.TARGET_SWITCH_COOLDOWN = 0.3;
        this.MOVEMENT_DECISION_INTERVAL = 0.05;

        this.MIN_ATTACK_ANIMATION_TIME = 0.4;
        this.STATE_CHANGE_COOLDOWN = 0.1;

        this.DAMAGE_TIMING_RATIO = 0.5;

        // Use placement grid size (half of terrain grid) for position threshold
        this.TARGET_POSITION_THRESHOLD = this.game.getCollections().configs.game.gridSize / 2 * 0.5;
        // Debug logging
        this.DEBUG_ENEMY_DETECTION = true; // Set to false to disable debug

    }

    init() {
        this.game.gameManager.register('setRetaliatoryTarget', this.setRetaliatoryTarget.bind(this));
        this.game.gameManager.register('startDeathProcess', this.startDeathProcess.bind(this));
        this.game.gameManager.register('calculateAnimationSpeed', this.calculateAnimationSpeed.bind(this));
    }

    update() {
        const CT = this.componentTypes;
        if (this.game.state.phase !== 'battle'){
            const combatUnits = this.game.getEntitiesWith(
               CT.AI_STATE
            );
            for (let i = 0; i < combatUnits.length; i++) {
                const entityId = combatUnits[i];
                const aiState = this.game.getComponent(entityId, CT.AI_STATE);
                if (aiState.state !== 'idle') {
                    this.changeAIState(aiState, 'idle');
                }
                aiState.target = null;
            }
            return;
        }

        const combatUnits = this.game.getEntitiesWith(
            CT.POSITION, CT.COMBAT, CT.TEAM, CT.AI_STATE
        );
        for (let i = 0; i < combatUnits.length; i++) {
            const entityId = combatUnits[i];
            const pos = this.game.getComponent(entityId, CT.POSITION);
            const combat = this.game.getComponent(entityId, CT.COMBAT);
            const team = this.game.getComponent(entityId, CT.TEAM);
            const aiState = this.game.getComponent(entityId, CT.AI_STATE);
            const vel = this.game.getComponent(entityId, CT.VELOCITY);
            const collision = this.game.getComponent(entityId, CT.COLLISION);
            const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);

            if (!pos || !vel || !combat || !team || !aiState){
                 continue;
            }
            
            // DEBUG: Log combat range and position
            const preventEnemiesInRangeCheck = aiState.meta ? aiState.meta.preventEnemiesInRangeCheck : false; 
            if (!aiState.meta.initialized) {
                aiState.meta = {
                    lastDecisionTime: 0,
                    targetLockTime: 0,
                    lastStateChange: 0,
                    lastAttackStart: 0,
                    initialized: true
                };
            }
            const aiMeta = aiState.meta;

            const enemiesInVisionRange = preventEnemiesInRangeCheck ? [] : (this.getAllEnemiesInVision(entityId, pos, unitType, team, combat) || []);
            
            // DEBUG: Log enemies found
            if (aiState.target) {
                const targetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
                const targetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
                if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
                    aiState.target = null;                                    
                    this.onLostTarget(entityId);  
                }
            }
            if(aiState.targetPosition){
                const distance = Math.sqrt(
                    Math.pow( aiState.targetPosition.x - pos.x, 2) + 
                    Math.pow( aiState.targetPosition.z - pos.z, 2)
                );
                aiState.targetDistance = distance;
            } else {
                aiState.targetDistance = 0;
            }
            if (enemiesInVisionRange.length === 0) {
                if(aiState.targetPosition){
                    if(aiState.targetDistance > this.TARGET_POSITION_THRESHOLD && !vel.anchored){
                        if(aiState.state !== 'chasing'){
                            this.changeAIState(aiState, 'chasing');
                        }
                    } else {
                        if (aiState.state !== 'idle') {
                            
                            let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);
                            if(currentAI == "CombatAISystem"){
                                this.onLostTarget(entityId);
                            }
                            this.changeAIState(aiState, 'idle');
                        }
                    }
                }   
            }

            if (aiMeta.nextMoveTime == null) aiMeta.nextMoveTime = 0;
    
            if (aiState.state !== 'waiting') {
                aiMeta.nextMoveTime = this.game.state.now + this.MOVEMENT_DECISION_INTERVAL;
                this.makeAIDecision(entityId, pos, combat, team, aiState, enemiesInVisionRange, collision);
                aiMeta.lastDecisionTime = this.game.state.now;
            }

            this.handleCombat(entityId, pos, combat, aiState, collision);
        }
    }

    getAllEnemiesInVision(entityId, pos, unitType, team, combat) {
        const allUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.TEAM,
            this.componentTypes.HEALTH
        );
        
        const visionRange = combat.visionRange;
        
        return allUnits.filter(otherId => {
            if (otherId === entityId) return false;
            
            const otherTeam = this.game.getComponent(otherId, this.componentTypes.TEAM);
            const otherHealth = this.game.getComponent(otherId, this.componentTypes.HEALTH);
            const otherDeathState = this.game.getComponent(otherId, this.componentTypes.DEATH_STATE);
            const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);
            
            if (!otherTeam || otherTeam.team === team.team) return false;
            if (!otherHealth || otherHealth.current <= 0) return false;
            if (otherDeathState && otherDeathState.isDying) return false;
            if (!otherPos) return false;
            
            return this.isInVisionRange(entityId, otherId, visionRange) && this.game.gameManager.call('hasLineOfSight', pos, otherPos, unitType, entityId);                   
        });
    }


    changeAIState(aiState, newState) {

        const aiMeta = aiState.meta;
        if (this.game.state.now - aiMeta.lastStateChange < this.STATE_CHANGE_COOLDOWN) return false;
        if (aiState.state === 'attacking') {
            const attackDuration = this.game.state.now - aiMeta.lastAttackStart;
            if (attackDuration < this.MIN_ATTACK_ANIMATION_TIME) return false;
        }
        if (aiState.state !== newState) {
            aiState.state = newState;
            aiMeta.lastStateChange = this.game.state.now;
            if (newState === 'attacking') aiMeta.lastAttackStart = this.game.state.now;
            return true;
        }
        return false;
    }

    makeAIDecision(entityId, pos, combat, team, aiState, enemiesInVisionRange, collision) {
        // CHANGED: Always try to find the best target from ALL enemies
        let targetEnemy = this.findBestTarget(entityId, pos, combat.range, enemiesInVisionRange, aiState);
        
        if (!targetEnemy) {
            aiState.target = null;
            this.onLostTarget(entityId);
            return;
        }
        
        const targetHealth = this.game.getComponent(targetEnemy, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetEnemy, this.componentTypes.DEATH_STATE);
        if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
            aiState.target = null;
            return;
        }
        
        const enemyPos = this.game.getComponent(targetEnemy, this.componentTypes.POSITION);
        if (!enemyPos) return;

        let currentCombatAi = this.game.gameManager.call('getAIControllerData', entityId, "CombatAISystem");
        let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);

        // Set the target
        currentCombatAi.target = targetEnemy;
        aiState.target = targetEnemy;

        // Check if we have direct line of sight to the target
        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        const hasLOS = this.game.gameManager.call('hasLineOfSight', pos, enemyPos, unitType, entityId);
        const hasDirectPath = this.game.gameManager.call('hasDirectWalkablePath', pos, enemyPos, entityId);

        if (hasLOS && hasDirectPath) {
            // Can see AND walk directly - use steering only
            aiState.path = null;
            aiState.useDirectMovement = true;
        } 

        if(currentAI != "CombatAISystem"){
            // Check if we can interrupt current command with combat AI
            // Only take control if current command is interruptible or has lower priority
            const ComponentTypes = this.game.componentTypes;

            if (this.game.commandQueueSystem) {
                // Use command queue - combat has lower priority than player commands
                const canTakeControl = this.game.gameManager.call('canInterruptCommand', entityId, this.game.commandQueueSystem.PRIORITY.IDLE);

                if (canTakeControl || !aiState.meta?.preventEnemiesInRangeCheck) {
                    // Queue combat command with IDLE priority (won't interrupt player commands)
                    this.game.gameManager.call('queueCommand', entityId, {
                        type: 'combat',
                        controllerId: "CombatAISystem",
                        targetPosition: null,
                        target: targetEnemy,
                        meta: {},
                        priority: this.game.commandQueueSystem.PRIORITY.IDLE,
                        interruptible: true
                    }, false); // false = don't force interrupt
                }
            } else {
                // Fallback to old method - only switch if no preventEnemiesInRangeCheck
                if (!aiState.meta?.preventEnemiesInRangeCheck) {
                    this.game.gameManager.call('setCurrentAIController', entityId, "CombatAISystem", currentCombatAi);
                }
            }
        }
        if (this.isInAttackRange(entityId, targetEnemy, combat)) {
            // Check if this is a spell caster and if abilities are available
   
            this.changeAIState(aiState, 'attacking');
        } else {
            if(aiState.state !== 'chasing'){
                this.changeAIState(aiState, 'chasing');
            }
        }
    }

    findBestTarget(entityId, pos, range, enemiesInVisionRange, aiState) {
        const aiMeta = aiState.meta;
        let bestTarget = null;
        let bestScore = -Infinity;
        
        // If unit is currently attacking, stick with current target unless switching would be much better
        if (aiState.target && enemiesInVisionRange.includes(aiState.target)) {
            const currentTargetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
            const currentTargetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
            const currentTargetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);

            const isCurrentTargetValid = currentTargetHealth && 
                                       currentTargetHealth.current > 0 && 
                                       (!currentTargetDeathState || !currentTargetDeathState.isDying) &&
                                       currentTargetPos;
            
            if (isCurrentTargetValid) {
                // Calculate current target score
                const currentDistance = Math.sqrt(
                    Math.pow(currentTargetPos.x - pos.x, 2) + 
                    Math.pow(currentTargetPos.z - pos.z, 2)
                );
                const currentHealthRatio = currentTargetHealth.current / (currentTargetHealth.max || currentTargetHealth.current);
                const currentScore = this.calculateTargetScore(currentDistance, currentHealthRatio, true);
                
                // Only switch if we find a significantly better target
                bestScore = currentScore * 1.2; // 20% bonus for current target (sticky targeting)
                bestTarget = aiState.target;
            }
        }
        
        // Evaluate all enemies to find the best target
        enemiesInVisionRange.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            const enemyDeathState = this.game.getComponent(enemyId, this.componentTypes.DEATH_STATE);
            
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            if (enemyDeathState && enemyDeathState.isDying) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - pos.x, 2) + 
                Math.pow(enemyPos.z - pos.z, 2)
            );

            const healthRatio = enemyHealth.current / (enemyHealth.max || enemyHealth.current);
            const isCurrentTarget = (enemyId === aiState.target);
            
            const score = this.calculateTargetScore(distance, healthRatio, isCurrentTarget);
            
            if (score > bestScore) {
                bestScore = score;
                bestTarget = enemyId;
            }
            
        });
        
        if (bestTarget !== aiState.target) {
            aiMeta.targetLockTime = this.game.state.now;
        }
        
        return bestTarget;
    }

    calculateTargetScore(distance, healthRatio, isCurrentTarget) {
        let score = 0;
        
        // Distance factor - closer is better, but not overwhelmingly so
        // Use logarithmic scaling so very far enemies are still viable
        const maxDistance = 20000; // Assume max battlefield size
        const distanceFactor = Math.max(0, (maxDistance - distance) / maxDistance);
        score += distanceFactor * 100;    

        
        // Current target bonus for stability
        if (isCurrentTarget) {
            score += 50000;
        }
        
        
        return score;
    }

    onLostTarget(entityId) {
        let aiState = this.game.getComponent(entityId, this.game.componentTypes.AI_STATE);
        aiState.useDirectMovement = false;
        let currentCombatAI = this.game.gameManager.call('getAIControllerData', entityId, "CombatAISystem");
        currentCombatAI.target = null;
        if(this.game.gameManager.call('hasAIControllerData', entityId, "UnitOrderSystem")){
            let currentOrderAI = this.game.gameManager.call('getAIControllerData', entityId, "UnitOrderSystem");
            let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);
            if(currentAI == "CombatAISystem"){
                this.game.gameManager.call('setCurrentAIController', entityId, "UnitOrderSystem", currentOrderAI);
            }
        }
    }

    handleCombat(entityId, pos, combat, aiState, collision) {
        const aiMeta = aiState.meta;
        if (!aiState.target || aiState.state !== 'attacking'){
           // console.log('no target or not attacking', aiState); 
            return;
        }
        
        const targetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);
        const targetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
        
        if (!targetPos || !targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
            aiState.target = null;
            this.onLostTarget(entityId);       
            return;
        }
        
        if (!this.isInAttackRange(entityId, aiState.target, combat, 5)) {
            this.changeAIState(aiState, 'chasing');
            console.log('not in attack range');
            return;
        }
        
        // Handle melee units with damage > 0
        if (combat.damage > 0) {
            const effectiveAttackSpeed = this.getEffectiveAttackSpeed(entityId, combat.attackSpeed);
            if ((this.game.state.now - combat.lastAttack) >= 1 / effectiveAttackSpeed) {
                this.initiateAttack(entityId, aiState.target, combat);
                combat.lastAttack = this.game.state.now;
                aiMeta.lastAttackStart = this.game.state.now;
            }
        }           
    }

    log(){
        if(arguments[0].indexOf("barbarian") >= 0){
            console.log(...arguments)
        }
    }
    
    initiateAttack(attackerId, targetId, combat) {
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetId, this.componentTypes.DEATH_STATE);
        if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) return;

        // Make the attacker face the target
        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const facing = this.game.getComponent(attackerId, this.componentTypes.FACING);

        if (attackerPos && targetPos && facing) {
            const dx = targetPos.x - attackerPos.x;
            const dz = targetPos.z - attackerPos.z;
            const angleToTarget = Math.atan2(dz, dx);
            facing.angle = angleToTarget;
        }

        if(this.game.gameManager.has('triggerSinglePlayAnimation')){
            const animationSpeed = this.calculateAnimationSpeed(attackerId, combat.attackSpeed);
            const minAnimationTime = 1 / combat.attackSpeed * 0.8; // 80% of attack interval
            this.game.gameManager.call('triggerSinglePlayAnimation', attackerId, 'attack', animationSpeed, minAnimationTime);
        }

        if (combat.projectile) {
            this.scheduleProjectileLaunch(attackerId, targetId, combat);
        } else {
            this.scheduleMeleeDamage(attackerId, targetId, combat);
        }
    }

    calculateAnimationSpeed(attackerId, animationSpeed) {
        const attackInterval = 1 / animationSpeed;
        
        // Default fallback duration
        let baseAnimationDuration = 0.8;
        
        if (this.game.gameManager.has('getEntityAnimations')) {
            // NEW: Get duration from VAT bundle instead of mixer actions
            const CT = this.componentTypes;
            const renderable = this.game.getComponent(attackerId, CT.RENDERABLE);
            
            if (renderable) {
                const batchInfo = this.game.renderSystem?.getBatchInfo(
                    renderable.objectType, 
                    renderable.spawnType
                );
                
                if (batchInfo) {
                    const bundle = this.game.modelManager?.getVATBundle(
                        renderable.objectType, 
                        renderable.spawnType
                    );
                    
                    if (bundle?.meta?.clips) {
                        // Find attack clip duration
                        const attackClip = bundle.meta.clips.find(clip => 
                            clip.name === 'attack' || clip.name === 'combat' || clip.name === 'fight'
                        );
                        if (attackClip) {
                            baseAnimationDuration = attackClip.duration;
                        }
                    }
                }
            }
            
            // OLD SYSTEM COMPATIBILITY (remove this once VAT is working):
            // Keep this as fallback in case you need it temporarily
            const entityAnimations = this.game.gameManager.call('getEntityAnimations');
            if (entityAnimations) {
                const animationActions = entityAnimations.get(attackerId);
                if (animationActions && animationActions.attack) {
                    const attackAction = animationActions.attack;
                    if (attackAction.getClip) {
                        baseAnimationDuration = attackAction.getClip().duration;
                    }
                }
            }
        }
        
        // Calculate speed to fit animation into attack interval
        const targetAnimationDuration = Math.max(attackInterval * 0.9, 0.2);
        let resultSpeed = baseAnimationDuration / targetAnimationDuration;
        
        return resultSpeed;
    }

    scheduleMeleeDamage(attackerId, targetId, combat) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot schedule melee damage');
            return;
        }

        const attackInterval = 1 / combat.attackSpeed;
        const damageDelay = attackInterval * this.DAMAGE_TIMING_RATIO;
    
        const element = this.getDamageElement(attackerId, combat);
        
        this.game.gameManager.call('scheduleDamage',
            attackerId,
            targetId,
            combat.damage,
            element,
            damageDelay,
            {
                isMelee: true,
                weaponRange: combat.range + this.ATTACK_RANGE_BUFFER + 1
            }
        );
    }

    scheduleProjectileLaunch(attackerId, targetId, combat) {
        const attackInterval = 1 / combat.attackSpeed;
        const launchDelay = attackInterval * this.DAMAGE_TIMING_RATIO;
        
        // Clean generic scheduling
        this.game.gameManager.call('scheduleAction', () => {
            this.fireProjectileAttack(attackerId, targetId, combat.projectile);
        }, launchDelay, attackerId);
    }

    fireProjectileAttack(attackerId, targetId, projectileTypeId) {
        if (!this.game.projectileSystem) return;
        const projectileData = this.game.getCollections().projectiles[projectileTypeId];
        if (!projectileData) return;
        this.game.gameManager.call('fireProjectile', attackerId, targetId, {
            id: projectileTypeId,
            ...projectileData
        });
    }

    getDamageElement(entityId, combat) {
        if (combat.element) {
            return combat.element;
        }
        
        const weaponElement = this.getWeaponElement(entityId);
        if (weaponElement) {
            return weaponElement;
        }
        
        return this.game.damageSystem?.ELEMENT_TYPES?.PHYSICAL || 'physical';
    }

    getWeaponElement(entityId) {
        if (!this.game.equipmentSystem) return null;
        
        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);
        if (!equipment) return null;
        
        const mainHandItem = equipment.slots.mainHand;
        if (mainHandItem) {
            const itemData = this.game.gameManager.call('getItemData', mainHandItem);
            if (itemData && itemData.stats && itemData.stats.element) {
                return itemData.stats.element;
            }
        }

        const offHandItem = equipment.slots.offHand;
        if (offHandItem) {
            const itemData = this.game.gameManager.call('getItemData', offHandItem);
            if (itemData && itemData.stats && itemData.stats.element) {
                return itemData.stats.element;
            }
        }
        
        return null;
    }

    calculateDistances(pos1, pos2, collision1, collision2) {
        const dx = pos2.x - pos1.x;
        const dz = pos2.z - pos1.z;
        const centerToCenterDistance = Math.sqrt(dx * dx + dz * dz);
        const radius1 = this.getUnitRadius(collision1);
        const radius2 = this.getUnitRadius(collision2);
        const edgeToEdgeDistance = Math.max(0, centerToCenterDistance - radius1 - radius2);
        const distanceToTargetEdge = Math.max(0, centerToCenterDistance - radius2);
        return {
            centerToCenter: centerToCenterDistance,
            edgeToEdge: edgeToEdgeDistance,
            attackerCenterToTargetEdge: distanceToTargetEdge,
            attackerRadius: radius1,
            targetRadius: radius2
        };
    }

    isInAttackRange(attackerId, targetId, combat, extraBuffer = 0) {
        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const attackerCollision = this.game.getComponent(attackerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!attackerPos || !targetPos) return false;

        const distances = this.calculateDistances(attackerPos, targetPos, attackerCollision, targetCollision);
        const effectiveRange = combat.range + this.ATTACK_RANGE_BUFFER + extraBuffer;
        return distances.attackerCenterToTargetEdge <= effectiveRange;
    }

    isInVisionRange(viewerId, targetId, visionRange) {
        const viewerPos = this.game.getComponent(viewerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const viewerCollision = this.game.getComponent(viewerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!viewerPos || !targetPos) return false;

        const distances = this.calculateDistances(viewerPos, targetPos, viewerCollision, targetCollision);
        return distances.attackerCenterToTargetEdge <= visionRange;
    }

    isWithinEdgeToEdgeRange(attackerId, targetId, maxRange) {
        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const attackerCollision = this.game.getComponent(attackerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!attackerPos || !targetPos) return false;
        const distances = this.calculateDistances(attackerPos, targetPos, attackerCollision, targetCollision);
        return distances.edgeToEdge <= maxRange;
    }

    getUnitRadius(collision) {
        if (collision && collision.radius) {
            return Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius);
        }
        return this.DEFAULT_UNIT_RADIUS;
    }

    startDeathProcess(entityId) {

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        const existingDeathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
        if (existingDeathState && existingDeathState.isDying) return;
        
        if (this.game.damageSystem) {
            this.game.gameManager.call('clearAllStatusEffects', entityId);
        }
        
        this.game.addComponent(entityId, ComponentTypes.DEATH_STATE, Components.DeathState(true, this.game.state.now, 2.0));
        if (this.game.hasComponent(entityId, ComponentTypes.AI_STATE)) {
            this.game.removeComponent(entityId, ComponentTypes.AI_STATE);
        }
        const velocity = this.game.getComponent(entityId, ComponentTypes.VELOCITY);
        if (velocity) { velocity.x = 0; velocity.y = 0; velocity.z = 0; }
        
        if (this.game.hasComponent(entityId, ComponentTypes.COMBAT)) {
            this.game.removeComponent(entityId, ComponentTypes.COMBAT);
        }
        
        if (this.game.animationSystem) {
            this.game.gameManager.call('playDeathAnimation', entityId);
        }
        if(this.game.abilitySystem){
            this.game.gameManager.call('removeEntityAbilities', entityId);
        }
    }
    
    applyDamage(sourceId, targetId, damage, element, options = {}) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot apply damage');
            return { damage: 0, prevented: true, reason: 'no_damage_system' };
        }
                
        return this.game.gameManager.call('applyDamage', sourceId, targetId, damage, element, options);
    }

    applySplashDamage(sourceId, centerPos, damage, element, radius, options = {}) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot apply splash damage');
            return [];
        }
        
        return this.game.gameManager.call('applySplashDamage', sourceId, centerPos, damage, element, radius, options);
    }

    curePoison(targetId, stacksToRemove = null) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot cure poison');
            return false;
        }

        return this.game.gameManager.call('curePoison', targetId, stacksToRemove);
    }

    getPoisonStacks(entityId) {
        if (!this.game.damageSystem) {
            return 0;
        }

        return this.game.gameManager.call('getPoisonStacks', entityId);
    }

    getEffectiveAttackSpeed(entityId, baseAttackSpeed) {
        const attackerMods = this.game.gameManager.call('getAttackerModifiers', entityId);
        return baseAttackSpeed * (attackerMods.attackSpeedMultiplier || 1.0);
    }

    getStatusEffects(entityId) {
        if (!this.game.damageSystem) {
            return { poison: [] };
        }

        return this.game.gameManager.call('getStatusEffects', entityId);
    }

    setRetaliatoryTarget(entityId, attackerId) {
        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
        if (!aiState) return;
        
        if (aiState.target) return;
        
        const attackerHealth = this.game.getComponent(attackerId, this.componentTypes.HEALTH);
        const attackerDeathState = this.game.getComponent(attackerId, this.componentTypes.DEATH_STATE);
        if (!attackerHealth || attackerHealth.current <= 0) return;
        if (attackerDeathState && attackerDeathState.isDying) return;
        
        const attackerTeam = this.game.getComponent(attackerId, this.componentTypes.TEAM);
        const defenderTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
        if (attackerTeam && defenderTeam && attackerTeam.team === defenderTeam.team) return;
        
        aiState.target = attackerId;
    }

    debugStatusEffects() {
        if (!this.game.damageSystem) {
            return;
        }

        this.game.gameManager.call('debugStatusEffects');
    }
};

// system: ProjectileSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ProjectileSystem'] = class ProjectileSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.projectileSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();

        // Configuration
        this.HIT_DETECTION_RADIUS = 24;
        this.TRAIL_UPDATE_INTERVAL = 0.05;
        
        // Ballistic configuration
        this.DEFAULT_LAUNCH_ANGLE = Math.PI / 4; // 45 degrees
        this.MIN_LAUNCH_ANGLE = Math.PI / 6; // 30 degrees
        this.MAX_LAUNCH_ANGLE = Math.PI / 3; // 60 degrees
        this.BALLISTIC_HEIGHT_MULTIPLIER = 0.3; // How high the arc goes relative to distance
        this.PROJECTILE_LIFETIME = 200;
        
        // Ground impact detection
        this.GROUND_IMPACT_THRESHOLD = 0; // Distance from ground to trigger impact
        
        // Trail tracking for visual effects
        this.projectileTrails = new Map();
        
        // Get gravity from movement system
        this.GRAVITY = this.game.movementSystem?.GRAVITY;
    }
    
    // Deterministic rounding helper
    roundForDeterminism(value, precision = 6) {
        return Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision);
    }

    init() {
        this.game.gameManager.register('deleteProjectileTrail', this.deleteProjectileTrail.bind(this));
        this.game.gameManager.register('fireProjectile', this.fireProjectile.bind(this));
    }

    deleteProjectileTrail(entityId) {
        if (this.projectileTrails) {
            this.projectileTrails.delete(entityId);
        }
    }

    fireProjectile(sourceId, targetId, projectileData = {}) {
        const sourcePos = this.game.getComponent(sourceId, this.componentTypes.POSITION);
        const sourceCombat = this.game.getComponent(sourceId, this.componentTypes.COMBAT);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!sourcePos || !sourceCombat || !targetPos) return null;
        
        // Create projectile entity
        const projectileId = this.game.createEntity();
        const components = this.game.componentManager.getComponents();
        
        // Determine projectile element (from weapon, combat component, or projectile data)
        const projectileElement = this.determineProjectileElement(sourceId, projectileData);
        
        // Pass source ID to trajectory calculation for ballistic projectiles
        const projectileDataWithSource = { ...projectileData, sourceId: sourceId };
        
        // Calculate trajectory based on projectile type
        const trajectory = this.calculateTrajectory(sourcePos, targetPos, projectileDataWithSource);
        
        // Determine spawn height - ballistic projectiles start above ground to avoid immediate impact
        const spawnHeight = Math.max(sourcePos.y + 20, 20);           
        
        // Add components with full 3D support
        this.game.addComponent(projectileId, this.componentTypes.POSITION, 
            components.Position(sourcePos.x, spawnHeight, sourcePos.z));
        
        this.game.addComponent(projectileId, this.componentTypes.VELOCITY, 
            components.Velocity(trajectory.vx, trajectory.vy, trajectory.vz, projectileData.speed, projectileData.ballistic || false));
        
         // Enhanced projectile component with element
        this.game.addComponent(projectileId, this.componentTypes.PROJECTILE, {
            damage: sourceCombat.damage,
            speed: projectileData.speed,
            range: sourceCombat.range * 1.5,
            target: targetId,
            source: sourceId,
            startTime: this.game.state.now,
            startX: sourcePos.x,
            startY: spawnHeight,
            startZ: sourcePos.z,
            isBallistic: projectileData.ballistic || false,
            targetX: targetPos.x,
            targetY: targetPos.y + 20,
            targetZ: targetPos.z,
            launchAngle: trajectory.launchAngle,
            timeToTarget: trajectory.timeToTarget,
            weaponRange: trajectory.weaponRange || sourceCombat.range,
            element: projectileElement
        });

        const sourceTeam = this.game.getComponent(sourceId, this.componentTypes.TEAM);
        
        // Add UNIT_TYPE component for projectiles
        this.game.addComponent(projectileId, this.componentTypes.UNIT_TYPE, 
            components.UnitType(projectileData.id, projectileData.title, 0));
        
        // Add TEAM component (same team as source)
        if (sourceTeam) {
            this.game.addComponent(projectileId, this.componentTypes.TEAM, 
                components.Team(sourceTeam.team));
        }

        // Visual component        
        this.game.addComponent(projectileId, this.componentTypes.RENDERABLE, 
            components.Renderable("projectiles", projectileData.id));
        
        // Use LifetimeSystem instead of direct component
        if (this.game.gameManager) {
            this.game.gameManager.call('addLifetime', projectileId, this.PROJECTILE_LIFETIME, {
                fadeOutDuration: 1.0, // Fade out in last second
                onDestroy: (entityId) => {
                    // Custom cleanup for projectiles
                    this.cleanupProjectileData(entityId);
                }
            });
        } else {
            // Fallback to old method if LifetimeSystem not available
            this.game.addComponent(projectileId, this.componentTypes.LIFETIME,
                components.Lifetime(this.PROJECTILE_LIFETIME, this.game.state.now));
        }
        
        // Homing component if specified
        if (projectileData.homing && projectileData.homingStrength > 0) {
            const homingStrength = projectileData.ballistic ? 
                projectileData.homingStrength * 0.3 : projectileData.homingStrength;
            this.game.addComponent(projectileId, this.componentTypes.HOMING_TARGET, 
                components.HomingTarget(targetId, homingStrength, { x: targetPos.x, y: targetPos.y, z: targetPos.z }));
        }
        
        return projectileId;
    }
    
    cleanupProjectileData(projectileId) {
        // Clean up trail data
        this.projectileTrails.delete(projectileId);
    }

    /**
     * Determine the element of a projectile based on various sources
     */
    determineProjectileElement(sourceId, projectileData) {
        // Priority order: projectile data > weapon element > combat element > default physical
        
        // 1. Check projectile data for explicit element
        if (projectileData.element) {
            return projectileData.element;
        }
        
        // 2. Check combat component element
        const sourceCombat = this.game.getComponent(sourceId, this.componentTypes.COMBAT);
        if (sourceCombat && sourceCombat.element) {
            return sourceCombat.element;
        }
        
        // 3. Default to physical
        const elementTypes = this.game.gameManager ? this.game.gameManager.call('getDamageElementTypes') : null;
        return elementTypes?.PHYSICAL || 'physical';
    }

    calculateTrajectory(sourcePos, targetPos, projectileData) {
        const dx = targetPos.x - sourcePos.x;
        const dy = targetPos.y - sourcePos.y; // Height difference
        const dz = targetPos.z - sourcePos.z; // Forward/backward distance
        const projectileSpeed = projectileData.speed;
        
        // For ballistic projectiles, calculate arc trajectory based on weapon range
        if (projectileData.ballistic) {
            return this.calculateBallisticTrajectory(sourcePos, targetPos, projectileSpeed, projectileData);
        } else {
            // Direct trajectory for non-ballistic projectiles
            const totalDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (totalDistance === 0) {
                return { vx: 0, vy: 0, vz: 0, launchAngle: 0, timeToTarget: 0 };
            }
            
            const initialVx = (dx / totalDistance) * projectileSpeed;
            const initialVy = (dy / totalDistance) * projectileSpeed;
            const initialVz = (dz / totalDistance) * projectileSpeed;
            
            return {
                vx: this.roundForDeterminism(initialVx),
                vy: this.roundForDeterminism(initialVy),
                vz: this.roundForDeterminism(initialVz),
                launchAngle: this.roundForDeterminism(Math.atan2(Math.sqrt(dx * dx + dz * dz), dy)),
                timeToTarget: this.roundForDeterminism(totalDistance / projectileSpeed)
            };
        }
    }
    
    calculateBallisticTrajectory(sourcePos, targetPos, speed, projectileData) {
        const dx = targetPos.x - sourcePos.x;
        const dy = targetPos.y - sourcePos.y; // Height difference
        const dz = targetPos.z - sourcePos.z; // Forward/backward distance
        
        const horizontalDistance = Math.sqrt(dx * dx + dz * dz);
        
        if (horizontalDistance === 0) {
            return { vx: 0, vy: 0, vz: 0, launchAngle: 0, timeToTarget: 0 };
        }
        
        // Get the firing unit's combat range to determine proper ballistic trajectory
        const sourceId = projectileData.sourceId;
        const sourceCombat = sourceId ? this.game.getComponent(sourceId, this.componentTypes.COMBAT) : null;
        const weaponRange = sourceCombat ? sourceCombat.range : horizontalDistance;
        
        // Use 45-degree angle for optimal range (gives maximum distance for given initial velocity)
        const launchAngle = Math.PI / 4; // 45 degrees
        const g = this.GRAVITY;
        
        // Calculate the initial velocity needed to reach the weapon's maximum range at 45 degrees
        const optimalInitialVelocity = Math.sqrt(weaponRange * g);
        
        // Calculate what range this velocity would achieve at our target distance
        const actualRange = Math.min(horizontalDistance, weaponRange);
        
        // If target is within range, calculate trajectory to hit it exactly
        let initialVelocity;
        let actualLaunchAngle = launchAngle;
        
        if (horizontalDistance <= weaponRange) {
            // Target is within range - calculate exact trajectory
            const maxRangeAtOptimalVelocity = (optimalInitialVelocity * optimalInitialVelocity) / g;
            
            if (horizontalDistance <= maxRangeAtOptimalVelocity) {
                // We can reach this distance with our optimal velocity
                initialVelocity = optimalInitialVelocity;
                // Calculate the required angle: sin(2Î¸) = (range * g) / vâ‚€Â²
                const sin2Theta = (horizontalDistance * g) / (initialVelocity * initialVelocity);
                
                // We want the lower trajectory angle (there are two solutions)
                const angle2Theta = Math.asin(Math.min(1, sin2Theta));
                actualLaunchAngle = angle2Theta / 2;
                
                // Prefer angles between 15Â° and 75Â° for realistic artillery
                if (actualLaunchAngle < Math.PI / 12) { // Less than 15Â°
                    actualLaunchAngle = Math.PI / 12;
                } else if (actualLaunchAngle > 5 * Math.PI / 12) { // More than 75Â°
                    actualLaunchAngle = 5 * Math.PI / 12;
                }
            } else {
                // Use 45Â° and calculate required velocity for this specific distance
                actualLaunchAngle = Math.PI / 4;
                initialVelocity = Math.sqrt(horizontalDistance * g);
            }
        } else {
            // Target is beyond weapon range - fire at maximum range in target direction
            initialVelocity = optimalInitialVelocity;
            actualLaunchAngle = Math.PI / 4; // 45Â° for maximum range
        }
        
        // Calculate time of flight
        const timeToTarget = (2 * initialVelocity * Math.sin(actualLaunchAngle)) / g;
        
        // Calculate horizontal direction unit vector
        const horizontalDirectionX = dx / horizontalDistance;
        const horizontalDirectionZ = dz / horizontalDistance;
        
        // Calculate initial velocity components
        const horizontalVelocity = initialVelocity * Math.cos(actualLaunchAngle);
        const vx = horizontalDirectionX * horizontalVelocity;
        const vz = horizontalDirectionZ * horizontalVelocity;
        const vy = initialVelocity * Math.sin(actualLaunchAngle); // Initial upward velocity
        
        // Adjust for height difference if target is at different elevation
        if (Math.abs(dy) > 5) { // Only adjust for significant height differences
            const heightAdjustment = dy / timeToTarget;
            const adjustedVy = vy + heightAdjustment;
            
            return {
                vx: this.roundForDeterminism(vx),
                vy: this.roundForDeterminism(adjustedVy),
                vz: this.roundForDeterminism(vz),
                launchAngle: this.roundForDeterminism(actualLaunchAngle),
                timeToTarget: this.roundForDeterminism(timeToTarget),
                weaponRange: this.roundForDeterminism(weaponRange),
                calculatedRange: this.roundForDeterminism((initialVelocity * initialVelocity * Math.sin(2 * actualLaunchAngle)) / g)
            };
        }
        
        return {
            vx: this.roundForDeterminism(vx),
            vy: this.roundForDeterminism(vy),
            vz: this.roundForDeterminism(vz),
            launchAngle: this.roundForDeterminism(actualLaunchAngle),
            timeToTarget: this.roundForDeterminism(timeToTarget),
            weaponRange: this.roundForDeterminism(weaponRange),
            calculatedRange: this.roundForDeterminism((initialVelocity * initialVelocity * Math.sin(2 * actualLaunchAngle)) / g)
        };
    }
    
    update() {
        if (this.game.state.phase !== 'battle') return;
        
        const projectiles = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.VELOCITY, 
            this.componentTypes.PROJECTILE
        );        
        projectiles.forEach(projectileId => {
            const pos = this.game.getComponent(projectileId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(projectileId, this.componentTypes.VELOCITY);
            const projectile = this.game.getComponent(projectileId, this.componentTypes.PROJECTILE);
            const homing = this.game.getComponent(projectileId, this.componentTypes.HOMING_TARGET);
                        
            // Update homing behavior
            if (homing && homing.targetId && projectile.isBallistic) {
                this.updateBallisticHoming(projectileId, pos, vel, projectile, homing);
            } else if (homing && homing.targetId) {
                this.updateHomingProjectile(projectileId, pos, vel, projectile, homing);
            }
            
            // Handle different collision types based on projectile type
            if (projectile.isBallistic) {
                // Ballistic projectiles ONLY check for ground impact
                this.handleProjectileGroundImpact(projectileId, pos, projectile);
            } else {
                // Non-ballistic projectiles check for direct unit hits
                this.checkProjectileCollisions(projectileId, pos, projectile);
            }
            
            // Update visual trail
            this.updateProjectileTrail(projectileId, pos);
        });
    }
    
    updateBallisticHoming(projectileId, pos, vel, projectile, homing) {
        // Get current target position
        const targetPos = this.game.getComponent(homing.targetId, this.componentTypes.POSITION);
        
        if (targetPos) {
            // Update last known position
            homing.lastKnownPosition = { x: targetPos.x, y: targetPos.y, z: targetPos.z };
            
            // For ballistic projectiles, we adjust the trajectory mid-flight
            // Calculate time elapsed since launch
            const timeElapsed = this.game.state.now - projectile.startTime;
            const remainingTime = Math.max(0.1, projectile.timeToTarget - timeElapsed);
            
            // Calculate where we need to be to hit the moving target
            const dx = targetPos.x - pos.x;
            const dy = targetPos.y - pos.y;
            const dz = targetPos.z - pos.z;
            
            // Adjust horizontal velocity to reach new target position
            const requiredHorizontalVelX = dx / remainingTime;
            const requiredHorizontalVelZ = dz / remainingTime;
            
            // Apply homing adjustment with strength factor
            const homingStrength = homing.homingStrength * this.game.state.deltaTime * 2; // Reduced for ballistic
            vel.vx = this.roundForDeterminism(vel.vx * (1 - homingStrength) + requiredHorizontalVelX * homingStrength);
            vel.vz = this.roundForDeterminism(vel.vz * (1 - homingStrength) + requiredHorizontalVelZ * homingStrength);
            
            // For vertical homing, we need to be more careful to maintain ballistic arc
            // Only adjust if we're in the descending phase
            if (vel.vy < 0) { // Falling down
                const requiredVerticalVel = (dy + 0.5 * this.GRAVITY * remainingTime * remainingTime) / remainingTime;
                vel.vy = this.roundForDeterminism(vel.vy * (1 - homingStrength * 0.5) + requiredVerticalVel * (homingStrength * 0.5));
            }
        } else if (homing.lastKnownPosition) {
            // Target is gone, continue toward last known position
            const dx = homing.lastKnownPosition.x - pos.x;
            const dy = homing.lastKnownPosition.y - pos.y;
            const dz = homing.lastKnownPosition.z - pos.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance < 20) {
                // Close enough to last known position, destroy projectile
                this.destroyProjectile(projectileId);
                return;
            }
        }
    }
    
    updateHomingProjectile(projectileId, pos, vel, projectile, homing) {
        // Get current target position
        const targetPos = this.game.getComponent(homing.targetId, this.componentTypes.POSITION);
        
        if (targetPos) {
            // Update last known position
            homing.lastKnownPosition = { x: targetPos.x, y: targetPos.y, z: targetPos.z };
            
            // Calculate direction to target
            const dx = targetPos.x - pos.x;
            const dy = targetPos.y - pos.y;
            const dz = targetPos.z - pos.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance > 0) {
                // Calculate desired velocity direction
                const desiredVx = (dx / distance) * projectile.speed;
                const desiredVy = (dy / distance) * projectile.speed;
                const desiredVz = (dz / distance) * projectile.speed;
                
                // Blend current velocity with desired velocity based on homing strength
                const homingStrength = homing.homingStrength * this.game.state.deltaTime * 5; // Adjust responsiveness
                vel.vx = this.roundForDeterminism(vel.vx * (1 - homingStrength) + desiredVx * homingStrength);
                vel.vy = this.roundForDeterminism(vel.vy * (1 - homingStrength) + desiredVy * homingStrength);
                vel.vz = this.roundForDeterminism(vel.vz * (1 - homingStrength) + desiredVz * homingStrength);
                
                // Maintain speed
                const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy + vel.vz * vel.vz);
                if (currentSpeed > 0) {
                    const speedRatio = projectile.speed / currentSpeed;
                    vel.vx = this.roundForDeterminism(vel.vx * speedRatio);
                    vel.vy = this.roundForDeterminism(vel.vy * speedRatio);
                    vel.vz = this.roundForDeterminism(vel.vz * speedRatio);
                }
            }
        } else {
            homing.targetId = null;
        }
    }
    
    checkProjectileCollisions(projectileId, pos, projectile) {
        // Only for NON-ballistic projectiles
        if (projectile.isBallistic) return; // Skip collision check for ballistic
        
        // Get all potential targets
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.TEAM,
            this.componentTypes.HEALTH
        );
        
        const sourceTeam = this.game.getComponent(projectile.source, this.componentTypes.TEAM);
        if (!sourceTeam) return;
        
        let hitDetected = false;

        for (const entityId of allEntities) {
            if (hitDetected) break; // Stop after first hit to ensure consistency
            if (entityId === projectile.source) continue; // Don't hit the source
            
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            const entityHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            
            if (!entityPos || !entityTeam || !entityHealth) continue;
            if (entityTeam.team === sourceTeam.team) continue; // Don't hit allies
            
            // Calculate 3D distance with consistent precision
            const dx = Math.round((entityPos.x - pos.x) * 1000) / 1000;
            const dy = Math.round((entityPos.y - pos.y) * 1000) / 1000;
            const dz = Math.round((entityPos.z - pos.z) * 1000) / 1000;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            // Get entity radius for collision detection
            const entityUnitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            const entityRadius = this.getUnitRadius(entityUnitType);

            // Check collision for direct hit
            if (distance <= entityRadius + this.HIT_DETECTION_RADIUS) {
                // Direct hit detected!
                this.handleProjectileHit(projectileId, entityId, entityPos, projectile);
                hitDetected = true;
                break;
            }
        }
    }
    
    handleProjectileGroundImpact(entityId, pos, projectile) {
        // Only for ballistic projectiles
        if (!projectile.isBallistic) return;
        
        // Get actual terrain height for projectile impact
        const terrainHeight = this.game.gameManager ? this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z) : null;
        const actualGroundLevel = terrainHeight !== null ? terrainHeight : this.game.movementSystem?.GROUND_LEVEL || 0;
        
        // Check if projectile hit the ground
        if (pos.y <= actualGroundLevel + this.GROUND_IMPACT_THRESHOLD) {
            // Ballistic projectiles explode on ground impact
            this.triggerBallisticExplosion(entityId, pos, projectile, actualGroundLevel);
            return;
        }
    }

    handleProjectileHit(projectileId, targetId, targetPos, projectile) {
        if (this.game.gameManager) {
            const damage = projectile.damage;
            const elementTypes = this.game.gameManager.call('getDamageElementTypes');
            const element = projectile.element || elementTypes.PHYSICAL;

            this.game.gameManager.call('applyDamage', projectile.source, targetId, damage, element, {
                isProjectile: true,
                projectileId: projectileId
            });
            if(!this.game.isServer){
                this.game.gameManager.call('createParticleEffect', targetPos.x, targetPos.y, targetPos.z, 'magic', {
                    color: this.getElementalEffectColor(element),
                    count: 3
                });
            }
        }


        this.destroyProjectile(projectileId);
    }

    triggerBallisticExplosion(entityId, pos, projectile, groundLevel) {
        this.createGroundExplosion(entityId, pos, projectile, groundLevel);

        if (this.game.gameManager) {
            const splashRadius = 80;
            const splashDamage = Math.floor(projectile.damage);
            const elementTypes = this.game.gameManager.call('getDamageElementTypes');
            const element = projectile.element || elementTypes.PHYSICAL;

            const results = this.game.gameManager.call('applySplashDamage',
                projectile.source,
                pos,
                splashDamage,
                element,
                splashRadius,
                {
                    isBallistic: true,
                    projectileId: entityId,
                    allowFriendlyFire: false
                }
            );

            if (this.game.combatAISystems && projectile.source && results) {
                for (const result of results) {
                    if (result.targetId && result.actualDamage > 0) {
                        this.game.combatAISystems.setRetaliatoryTarget(result.targetId, projectile.source);
                    }
                }
            }
        }

        this.destroyProjectile(entityId);
    }
    
 

    createGroundExplosion(projectileId, pos, projectile, groundLevel) {

    }

    // Get visual effect color based on element
    getElementalEffectColor(element) {
        if (!this.game.gameManager) return '#ff2200'; // blood-red

        const elementTypes = this.game.gameManager.call('getDamageElementTypes');

        switch (element) {
            case elementTypes.FIRE:
                return '#ffaa00'; // Default orange
            case elementTypes.COLD:
                return '#44aaff'; // Light blue
            case elementTypes.LIGHTNING:
                return '#ffff44'; // Bright yellow
            case elementTypes.POISON:
                return '#44ff44'; // Green
            case elementTypes.DIVINE:
                return '#ffddaa'; // Golden
            case elementTypes.PHYSICAL:
            default:
                return '#ff2200'; // Default orange
        }
    }

    // Get explosion effect type based on element
    getElementalExplosionEffect(element) {
        if (!this.game.gameManager) return 'explosion';

        const elementTypes = this.game.gameManager.call('getDamageElementTypes');

        switch (element) {
            case elementTypes.FIRE:
                return 'fire_explosion';
            case elementTypes.COLD:
                return 'ice_explosion';
            case elementTypes.LIGHTNING:
                return 'lightning_explosion';
            case elementTypes.POISON:
                return 'poison_explosion';
            case elementTypes.DIVINE:
                return 'divine_explosion';
            case elementTypes.PHYSICAL:
            default:
                return 'explosion';
        }
    }
    
    updateProjectileTrail(projectileId, pos) {
        const projectileVisual = this.game.getComponent(projectileId, this.componentTypes.PROJECTILE_VISUAL);
        if (!projectileVisual || projectileVisual.trailLength <= 0) return;
        
        if (!this.projectileTrails.has(projectileId)) {
            this.projectileTrails.set(projectileId, []);
        }
        
        const trail = this.projectileTrails.get(projectileId);
        
        // Add current position to trail (full 3D)
        trail.push({ x: pos.x, y: pos.y, z: pos.z, time: (this.game.state.now || 0) });
        
        // Remove old trail points
        while (trail.length > projectileVisual.trailLength) {
            trail.shift();
        }
    }
        
    destroyProjectile(projectileId) {
        this.game.gameManager.call('destroyEntityImmediately', projectileId, true);    
        this.game.destroyEntity(projectileId);
        this.cleanupProjectileData(projectileId);
    }
    
    getUnitRadius(unitType) {
        const DEFAULT_UNIT_RADIUS = 15;
        
        if (unitType && unitType.size) {
            return Math.max(DEFAULT_UNIT_RADIUS, unitType.size);
        }
        
        const collections = this.game.getCollections && this.game.getCollections();
        if (collections && collections.units && unitType) {
            const unitDef = collections.units[unitType.id];
            if (unitDef && unitDef.size) {
                return Math.max(DEFAULT_UNIT_RADIUS, unitDef.size);
            }
        }
        
        return DEFAULT_UNIT_RADIUS;
    }
    
    getProjectileTrail(projectileId) {
        return this.projectileTrails.get(projectileId) || [];
    }
    entityDestroyed(entityId) {
        // Clean up projectile trails
        if (this.projectileTrails) {
            this.projectileTrails.delete(entityId);
        }
        
        // Clean up any projectile tracking
        if (this.activeProjectiles) {
            this.activeProjectiles.delete(entityId);
        }
    }
};

// system: TeamHealthSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['TeamHealthSystem'] = class TeamHealthSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.teamHealthSystem = this;
        
        
        // Team health configuration
        this.MAX_TEAM_HEALTH = 2500;
        this.teamHealth = {
            left: this.MAX_TEAM_HEALTH,
            right: this.MAX_TEAM_HEALTH
        };
        
        // Track if we've already processed this round's result
        this.roundProcessed = false;
        
        if(!this.game.isServer){
            console.log('this.game', this.game);
            this.initializeUI();
        }
    }
    
    initializeUI() {
        // Delay creation to ensure DOM is ready
        setTimeout(() => {
            this.updateHealthDisplay();
        }, 100);
    }
    
    updateHealthDisplay() {
        const playerFill = document.getElementById('playerHealthFill');
        const playerText = document.getElementById('playerHealthText');
        const opponentFill = document.getElementById('opponentHealthFill');
        const opponentText = document.getElementById('opponentHealthText');
        
        let myHealth = this.teamHealth[this.game.state.mySide] || this.MAX_TEAM_HEALTH;
        let opponentHealth = this.teamHealth[this.game.state.mySide == 'left' ? 'right' : 'left'] || this.MAX_TEAM_HEALTH;
        if (playerFill && playerText) {
            const playerPercent = (myHealth / this.MAX_TEAM_HEALTH) * 100;
            playerFill.style.width = `${playerPercent}%`;
            playerText.textContent = `${myHealth}/${this.MAX_TEAM_HEALTH}`;
        }
        
        if (opponentFill && opponentText) {
            const opponentPercent = (opponentHealth / this.MAX_TEAM_HEALTH) * 100;
            opponentFill.style.width = `${opponentPercent}%`;
            opponentText.textContent = `${opponentHealth}/${this.MAX_TEAM_HEALTH}`;
        }
    }
    
    onBattleStart() {
        this.roundProcessed = false;
     
    }
    
    // Apply damage when PhaseSystem tells us a round ended
    applyRoundDamage(winningTeam, survivingUnits) {
        
        // Calculate damage based on surviving squads' base values
        const damageResult = this.calculateSquadBasedDamage(survivingUnits);
        const losingTeam = winningTeam === 'left' ? 'right' : 'left';
        
        // Apply damage to losing team
        this.dealDamageToTeam(losingTeam, damageResult.totalDamage);
        
        // Return result object
        return {
            result: winningTeam === this.game.state.mySide ? 'victory' : 'defeat',
            winningTeam: winningTeam,
            losingTeam: losingTeam,
            damage: damageResult.totalDamage,
            survivingSquads: damageResult.survivingSquads,
            gameOver: this.teamHealth[losingTeam] <= 0,
            remainingHealth: {
                left: this.teamHealth.left,
                right: this.teamHealth.right
            }
        };
    }
    
    // Apply no damage for draws
    applyRoundDraw() {
        if (this.roundProcessed) return null;
        this.roundProcessed = true;

        
        // Return draw result
        return {
            result: 'draw',
            winningTeam: null,
            losingTeam: null,
            damage: 0,
            gameOver: false,
            remainingHealth: {
                left: this.teamHealth.left,
                right: this.teamHealth.right
            }
        };
    }
    
    /**
     * Calculate damage based on squads, not individual units
     * If ANY units from a squad survive, the entire squad's base value counts as damage
     * @param {Array} survivingUnits - Array of surviving unit entity IDs
     * @returns {Object} Damage calculation results
     */
    calculateSquadBasedDamage(survivingUnits) {
        const squadMap = new Map(); // squadId -> {unitType, survivors, totalUnits}
        let totalDamage = 0;
        let survivingSquadCount = 0;
        const squadDetails = [];
        if(!survivingUnits){ 
            return {
                totalDamage: 0,
                survivingSquads: 0,
                squadDetails: []
            };
        }
        // Group surviving units by their squad placement ID
        survivingUnits.forEach(unitId => {
            // Find which squad this unit belongs to
            const squadInfo = this.findSquadForUnit(unitId);
            if (squadInfo) {
                const { placementId, unitType } = squadInfo;
                
                if (!squadMap.has(placementId)) {
                    squadMap.set(placementId, {
                        unitType: unitType,
                        survivors: 0,
                        totalUnits: this.getOriginalSquadSize(placementId),
                        placementId: placementId
                    });
                }
                
                squadMap.get(placementId).survivors++;
            }
        });
        
        // Calculate damage for each squad that has survivors
        squadMap.forEach((squadData, placementId) => {
            if (squadData.survivors > 0) {
                // Entire squad's base value counts as damage
                const squadBaseDamage = squadData.unitType.value || 50;
                totalDamage += squadBaseDamage;
                survivingSquadCount++;
                
                squadDetails.push({
                    name: squadData.unitType.title || squadData.unitType.id || 'Unknown Squad',
                    damage: squadBaseDamage,
                    survivingUnits: squadData.survivors,
                    totalUnits: squadData.totalUnits,
                    placementId: placementId
                });
                
            }
        });
        
        return {
            totalDamage: totalDamage,
            survivingSquads: survivingSquadCount,
            squadDetails: squadDetails
        };
    }
    
    /**
     * Find which squad a unit belongs to
     * @param {number} unitId - Unit entity ID
     * @returns {Object|null} Squad info or null
     */
    findSquadForUnit(unitId) {
        // Check with experience system first (most reliable)
        const squadData = this.game.gameManager.call('findSquadByUnitId', unitId);
        if (squadData) {
            const unitType = this.getCurrentUnitTypeForSquad(squadData.placementId);
            return {
                placementId: squadData.placementId,
                unitType: unitType || { value: squadData.squadValue, title: 'Unknown', id: 'unknown' }
            };
        }

        // Fallback: search placement system
        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];
        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];
        const allPlacements = [...playerPlacements, ...opponentPlacements];

        for (const placement of allPlacements) {
            if (placement.squadUnits) {
                const unitMatch = placement.squadUnits.find(entityId => entityId === unitId);
                if (unitMatch) {
                    return {
                        placementId: placement.placementId,
                        unitType: placement.unitType
                    };
                }
            }
        }

        // Last resort: use unit type component directly
        const unitTypeComponent = this.game.getComponent(unitId, this.componentTypes.UNIT_TYPE);
        if (unitTypeComponent) {
            return {
                placementId: `unknown_${unitId}`,
                unitType: {
                    value: unitTypeComponent.value || 50,
                    title: unitTypeComponent.type || 'Unknown Unit',
                    id: unitTypeComponent.id || 'unknown'
                }
            };
        }

        return null;
    }
    
    /**
     * Get the current unit type for a squad (handles specializations)
     * @param {string} placementId - Squad placement ID
     * @returns {Object|null} Current unit type
     */
    getCurrentUnitTypeForSquad(placementId) {
        const unitType = this.game.gameManager.call('getCurrentUnitTypeForSquad', placementId);
        if (unitType) {
            return unitType;
        }

        // Fallback to placement system
        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];
        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];
        const placement = playerPlacements.find(p => p.placementId === placementId) ||
                         opponentPlacements.find(p => p.placementId === placementId);
        return placement ? placement.unitType : null;
    }
    
    /**
     * Get the original size of a squad when it was placed
     * @param {string} placementId - Squad placement ID
     * @returns {number} Original squad size
     */
    getOriginalSquadSize(placementId) {
        // Check experience system first
        const squadData = this.game.gameManager.call('getSquadExperienceData', placementId);
        if (squadData) {
            return squadData.totalUnitsInSquad || squadData.squadSize;
        }

        // Fallback to placement system
        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];
        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];
        const placement = playerPlacements.find(p => p.placementId === placementId) ||
                         opponentPlacements.find(p => p.placementId === placementId);
        if (placement) {
            return placement.squadUnits ? placement.squadUnits.length : 1;
        }

        return 1; // Default fallback
    }
    
    dealDamageToTeam(team, damage) {
        this.teamHealth[team] = Math.max(0, this.teamHealth[team] - damage);
        if(!this.game.isServer){
            this.updateHealthDisplay();
            this.showDamageEffect(team, damage);
        }
    }
    
    showDamageEffect(team, damage) {
        // Create floating damage text
        const damageText = document.createElement('div');
        damageText.className = `damage-popup ${team}-damage`;
        damageText.textContent = `-${damage}`;
        
        // Position based on team
        const healthBar = document.querySelector(`.${team}-health`);
        if (healthBar) {
            const rect = healthBar.getBoundingClientRect();
            damageText.style.position = 'fixed';
            damageText.style.left = `${rect.left + rect.width / 2}px`;
            damageText.style.top = `${rect.top}px`;
            damageText.style.zIndex = '1000';
            
            document.body.appendChild(damageText);
            
            // Animate and remove
            setTimeout(() => {
                if (damageText.parentNode) {
                    damageText.parentNode.removeChild(damageText);
                }
            }, 2000);
        }
    }
    
    resetTeamHealth() {
        this.teamHealth.left = this.MAX_TEAM_HEALTH;
        this.teamHealth.right = this.MAX_TEAM_HEALTH;
        this.roundProcessed = false;
        this.updateHealthDisplay();
    }
    
    getTeamHealth(team) {
        return this.teamHealth[team] || 0;
    }
    
    getHealthPercentage(team) {
        return (this.teamHealth[team] / this.MAX_TEAM_HEALTH) * 100;
    }
    
    // Get health status for UI
    getHealthStatus() {
        return {
            left: {
                current: this.teamHealth.left,
                max: this.MAX_TEAM_HEALTH,
                percentage: this.getHealthPercentage('left')
            },
            right: {
                current: this.teamHealth.right,
                max: this.MAX_TEAM_HEALTH,
                percentage: this.getHealthPercentage('right')
            }
        };
    }

    getLeftHealth() {
        return this.teamHealth.left || 0;
    }

    // Method for multiplayer compatibility - returns current right health  
    getRightHealth() {
        return this.teamHealth.right || 0;
    }

    // Method to set left health (for multiplayer server updates)
    setLeftHealth(health) {
        this.teamHealth.left = Math.max(0, Math.min(health, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Method to set right health (for multiplayer server updates)
    setRightHealth(health) {
        this.teamHealth.right = Math.max(0, Math.min(health, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Multiplayer-specific method to sync both team healths from server
    syncHealthFromServer(leftHealth, rightHealth) {
        this.teamHealth.left = Math.max(0, Math.min(leftHealth, this.MAX_TEAM_HEALTH));
        this.teamHealth.right = Math.max(0, Math.min(rightHealth, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Check if either team is eliminated (for multiplayer game end conditions)
    isGameOver() {
        return this.teamHealth.left <= 0 || this.teamHealth.right <= 0;
    }

    // Get the winning team (for multiplayer results)
    getWinningTeam() {
        if (this.teamHealth.left <= 0) return 'right';
        if (this.teamHealth.right <= 0) return 'left';
        return null; // No winner yet
    }
};

// system: DeathSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DeathSystem'] = class DeathSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.deathSystem = this;
    }
    
    update() {
        // Get all entities with death state
        const dyingEntities = this.game.getEntitiesWith(this.componentTypes.DEATH_STATE);
        dyingEntities.forEach(entityId => {
            const deathState = this.game.getComponent(entityId, this.componentTypes.DEATH_STATE);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        
            if (deathState.isDying) {
                const timeSinceDeath = this.game.state.now - deathState.deathStartTime;
                
                // Remove health (corpses can't be damaged)
                if (this.game.hasComponent(entityId, this.componentTypes.HEALTH)) {
                    this.game.removeComponent(entityId, this.componentTypes.HEALTH);
                }
                
                // Remove velocity (corpses don't move)
                if (this.game.hasComponent(entityId, this.componentTypes.VELOCITY)) {
                    this.game.removeComponent(entityId, this.componentTypes.VELOCITY);
                }
                
                const timerExpired = timeSinceDeath >= deathState.deathAnimationDuration * 0.975;
                
                if (timerExpired) {
                    console.log(entityId, "DIED");
                    if(unitType && unitType.collection == "buildings"){
                        this.destroyBuilding(entityId);
                    } else {
                        this.convertToCorpse(entityId);
                    }
                }
            }
        });
    }



    destroyBuilding(entityId) {
        this.game.triggerEvent('onDestroyBuilding', entityId);
        this.game.destroyEntity(entityId);  
        return { success: true };
    }
    
    convertToCorpse(entityId) {
        const Components = this.game.componentManager.getComponents();
        
        // Get current components before conversion
        const position = this.game.getComponent(entityId, this.componentTypes.POSITION);
        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
        const renderable = this.game.getComponent(entityId, this.componentTypes.RENDERABLE);
        
        if (!position || !unitType || !team) return;

        // CRITICAL: Notify AnimationSystem FIRST to set corpse state
        if(this.game.gameManager.has('setCorpseAnimation')){
            this.game.gameManager.call('setCorpseAnimation', entityId);
        }

        // Remove death state
        this.game.removeComponent(entityId, this.componentTypes.DEATH_STATE);        
        
        this.game.triggerEvent('onUnitKilled', entityId);
        // Add corpse component
        this.game.addComponent(entityId, this.componentTypes.CORPSE, Components.Corpse(
            { ...unitType }, 
            (this.game.state.now || 0), 
            team.team
        ));
        
    }
    
    // Rest of your existing methods remain the same...
    getCorpsesInRange(position, range, teamFilter = null) {
        const corpses = this.game.getEntitiesWith(this.componentTypes.CORPSE);
        const nearbyCorpses = [];
        
        corpses.forEach(corpseId => {
            const corpsePos = this.game.getComponent(corpseId, this.componentTypes.POSITION);
            const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
            
            if (!corpsePos || !corpse) return;
            
            // Check team filter if specified
            if (teamFilter && corpse.teamAtDeath !== teamFilter) return;
            
            // Check distance
            const dx = corpsePos.x - position.x;
            const dz = corpsePos.z - position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance <= range) {
                nearbyCorpses.push({
                    entityId: corpseId,
                    position: corpsePos,
                    corpse: corpse,
                    distance: distance
                });
            }
        });
        
        return nearbyCorpses;
    }
    
    consumeCorpse(corpseId) {
        // Remove corpse from battlefield (for abilities that consume corpses)
        const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
        if (!corpse) return null;
        
        // Return corpse data for the ability to use
        const corpseData = { ...corpse };
        
        // Destroy the corpse entity
        this.game.destroyEntity(corpseId);
        
        return corpseData;
    }
    
    getAllCorpses() {
        return this.game.getEntitiesWith(this.componentTypes.CORPSE);
    }
    
    getCorpsesByTeam(team) {
        const corpses = this.game.getEntitiesWith(this.componentTypes.CORPSE);
        return corpses.filter(corpseId => {
            const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
            return corpse && corpse.teamAtDeath === team;
        });
    }
};

// system: DamageSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DamageSystem'] = class DamageSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.damageSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Element types
        this.ELEMENT_TYPES = {
            PHYSICAL: 'physical',
            FIRE: 'fire',
            COLD: 'cold',
            LIGHTNING: 'lightning',
            POISON: 'poison',
            DIVINE: 'divine'
        };

        // Poison DoT configuration
        this.POISON_CONFIG = {
            DEFAULT_DURATION: 5.0,  // seconds
            DEFAULT_TICKS: 5,       // number of damage instances
            STACK_LIMIT: 50,         // maximum poison stacks
            STACK_REFRESH: true     // new poison refreshes duration
        };

        // Status effect tracking
        this.activeStatusEffects = new Map(); // entityId -> { poison: [...], other effects }
        
        // Damage event queue for delayed damage (melee attacks, etc.)
        this.pendingDamageEvents = new Map();
        
        // Configuration
        this.RESISTANCE_CAP = 0.9; // Maximum resistance (90%)
        this.MIN_DAMAGE = 1; // Minimum damage that can be dealt
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('applyDamage', this.applyDamage.bind(this));
        this.game.gameManager.register('applySplashDamage', this.applySplashDamage.bind(this));
        this.game.gameManager.register('getDamageElementTypes', () => this.ELEMENT_TYPES);
        this.game.gameManager.register('scheduleDamage', this.scheduleDamage.bind(this));
        this.game.gameManager.register('curePoison', this.curePoison.bind(this));
        this.game.gameManager.register('getPoisonStacks', this.getPoisonStacks.bind(this));
        this.game.gameManager.register('clearAllDamageEffects', this.clearAllDamageEffects.bind(this));
        this.game.gameManager.register('clearAllStatusEffects', this.clearAllStatusEffects.bind(this));
        this.game.gameManager.register('getAttackerModifiers', this.getAttackerModifiers.bind(this));
    }

    // =============================================
    // CORE DAMAGE APPLICATION METHODS
    // =============================================

    /**
     * Main damage application method - handles all damage types and resistances
     * @param {number} sourceId - Entity dealing damage
     * @param {number} targetId - Entity receiving damage  
     * @param {number} baseDamage - Base damage amount
     * @param {string} element - Damage element type
     * @param {Object} options - Additional options (splash, crit, etc.)
     */
    applyDamage(sourceId, targetId, baseDamage, element = this.ELEMENT_TYPES.PHYSICAL, options = {}) {
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetId, this.componentTypes.DEATH_STATE);
        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);

        if (!targetHealth || (targetDeathState && targetDeathState.isDying)) {
            return { damage: 0, prevented: true, reason: 'target_invalid' };
        }
        
        const defenderMods = this.getDefenderModifiers(targetId);
        // Get target's defenses
        const defenses = this.getEntityDefenses(targetId, defenderMods);
        const attackerMods = this.getAttackerModifiers(sourceId);
        let buffedDamage = baseDamage * attackerMods.damageMultiplier;

        

        if (options.isCritical) {
            buffedDamage *= options.criticalMultiplier || 2.0;
        }
        // Handle poison as special case (DoT)
        if (element === this.ELEMENT_TYPES.POISON) {
            return this.applyPoisonDoT(sourceId, targetId, buffedDamage, options);
        }
        // Calculate final damage after resistances/armor
        const damageResult = this.calculateFinalDamage(sourceId, targetId, buffedDamage, element, defenses, defenderMods, options);

        // Apply immediate damage
        targetHealth.current -= damageResult.finalDamage;

        // Visual feedback
        this.applyVisualFeedback(targetId, damageResult, element);

        // Check for death
        if (targetHealth.current <= 0) {
            this.handleEntityDeath(targetId);
        }

        this.game.gameManager.call('setRetaliatoryTarget', targetId, sourceId);
        
        this.game.gameManager.call('showDamageNumber', targetPos.x, targetPos.y + targetUnitType.height, targetPos.z, damageResult.finalDamage, element);
        
        return {
            damage: damageResult.finalDamage,
            originalDamage: baseDamage,
            buffedDamage: buffedDamage,
            mitigated: damageResult.mitigated,
            element: element,
            fatal: targetHealth.current <= 0
        };
    }
    getAttackerModifiers(attackerId) {
        const buff = this.game.getComponent(attackerId, this.componentTypes.BUFF);
        if (!buff || !buff.isActive) return { 
            damageMultiplier: 1.0,
            attackSpeedMultiplier: 1.0 
        };
        
        const currentTime = this.game.state.now || 0;
        if (buff.endTime && currentTime > buff.endTime) return { 
            damageMultiplier: 1.0,
            attackSpeedMultiplier: 1.0 
        };
        
        return {
            damageMultiplier: buff.modifiers?.damageMultiplier || 1.0,
            attackSpeedMultiplier: buff.modifiers?.attackSpeedMultiplier || 1.0
        };
    }
    getDefenderModifiers(defenderId) {
        const buff = this.game.getComponent(defenderId, this.componentTypes.BUFF);
        if (!buff || !buff.isActive) return { 
            armorMultiplier: 1.0, 
            damageTakenMultiplier: 1.0, 
            damageReduction: 0 
        };
        
        const currentTime = this.game.state.now || 0;
        if (buff.endTime && currentTime > buff.endTime) return { 
            armorMultiplier: 1.0, 
            damageTakenMultiplier: 1.0, 
            damageReduction: 0 
        };
        
        return {
            armorMultiplier: buff.modifiers?.armorMultiplier || buff.armorMultiplier || 1.0,
            damageTakenMultiplier: buff.modifiers?.damageTakenMultiplier || buff.damageTakenMultiplier || 1.0,
            damageReduction: buff.modifiers?.damageReduction || buff.damageReduction || 0,
            additionalLightningResistance: buff.modifiers?.additionalLightningResistance || buff.additionalLightningResistance || 0,
            additionalFireResistance: buff.modifiers?.additionalFireResistance || buff.additionalFireResistance || 0,
            additionalColdResistance: buff.modifiers?.additionalColdResistance || buff.additionalColdResistance || 0,
            additionalElementalResistance: buff.modifiers?.additionalElementalResistance || buff.additionalElementalResistance || 0
        };
    }
    /**
     * Apply splash/area damage around a point
     * @param {number} sourceId - Source of the damage
     * @param {Object} centerPos - Center position {x, y, z}
     * @param {number} baseDamage - Base damage amount
     * @param {string} element - Damage element
     * @param {number} radius - Splash radius
     * @param {Object} options - Additional options
     */
    applySplashDamage(sourceId, centerPos, baseDamage, element, radius, options = {}) {
        const results = [];
        const sourceTeam = this.game.getComponent(sourceId, this.componentTypes.TEAM);
        
        if (!sourceTeam) return results;

        // Find all entities within splash radius
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        allEntities.forEach(entityId => {
            if (entityId === sourceId && !options.allowSelfDamage) return; // Don't damage source by default
            
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            
            if (!entityPos || !entityTeam) return;
            if (entityTeam.team === sourceTeam.team && !options.allowFriendlyFire) return;

            // Calculate 3D distance from explosion center
            const distance = this.calculateDistance3D(centerPos, entityPos);
            
            if (distance <= radius) {
                // Calculate damage based on distance (closer = more damage)
                const damageMultiplier = Math.max(0.2, 1 - (distance / radius));
                const adjustedDamage = Math.floor(baseDamage * damageMultiplier);
           
                // Apply damage (experience will be awarded inside applyDamage)
                const result = this.applyDamage(sourceId, entityId, adjustedDamage, element, {
                    ...options,
                    isSplash: true,
                    splashDistance: distance,
                    splashMultiplier: damageMultiplier
                });
                

                if (result.damage > 0) {
                    results.push({
                        entityId,
                        ...result,
                        distance
                    });
                }
            }
        });

        return results;
    }

    // =============================================
    // DAMAGE CALCULATION METHODS
    // =============================================

    /**
     * Calculate final damage after all resistances and modifiers
     */
    calculateFinalDamage(sourceId, targetId, baseDamage, element, defenses, defenderMods, options = {}) {
        let finalDamage = baseDamage;
        let mitigated = 0;

        // Apply element-specific damage reduction
        switch (element) {
            case this.ELEMENT_TYPES.PHYSICAL:
                const armor = defenses.armor || 0;
                mitigated = Math.min(armor, finalDamage - this.MIN_DAMAGE);
                finalDamage = Math.max(this.MIN_DAMAGE, finalDamage - armor);
                break;

            case this.ELEMENT_TYPES.FIRE:
                const fireResist = this.capResistance(defenses.fireResistance || 0);
                mitigated = Math.floor(finalDamage * fireResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - fireResist)));
                break;

            case this.ELEMENT_TYPES.COLD:
                const coldResist = this.capResistance(defenses.coldResistance || 0);
                mitigated = Math.floor(finalDamage * coldResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - coldResist)));
                break;

            case this.ELEMENT_TYPES.LIGHTNING:
                const lightningResist = this.capResistance(defenses.lightningResistance || 0);
                mitigated = Math.floor(finalDamage * lightningResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - lightningResist)));
                break;

            case this.ELEMENT_TYPES.DIVINE:
                // Divine damage cannot be reduced
                mitigated = 0;
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage));
                break;

            default:
                console.warn(`Unknown damage element: ${element}, treating as physical`);
                const defaultArmor = defenses.armor || 0;
                mitigated = Math.min(defaultArmor, finalDamage - this.MIN_DAMAGE);
                finalDamage = Math.max(this.MIN_DAMAGE, finalDamage - defaultArmor);
                break;
        }
        // Apply damage taken multiplier (from marks, etc.)
        finalDamage *= defenderMods.damageTakenMultiplier;
        
        // Apply flat damage reduction (from intimidation, shield wall, etc.)
        if (defenderMods.damageReduction > 0) {
            const reductionAmount = Math.floor(finalDamage * defenderMods.damageReduction);
            finalDamage -= reductionAmount;
            mitigated += reductionAmount;
        }
        return {
            finalDamage,
            mitigated,
            originalDamage: baseDamage
        };
    }

    /**
     * Get entity's defensive stats from all sources
     */
    getEntityDefenses(entityId, defenderMods) {
        const defenses = {
            armor: 0,
            fireResistance: 0,
            coldResistance: 0,
            lightningResistance: 0
        };

        // Get base defenses from combat component
        const combatComponent = this.game.getComponent(entityId, this.componentTypes.COMBAT);
        if (combatComponent) {
            defenses.armor = combatComponent.armor || 0;
            defenses.fireResistance = combatComponent.fireResistance || 0;
            defenses.coldResistance = combatComponent.coldResistance || 0;
            defenses.lightningResistance = combatComponent.lightningResistance || 0;
        }

        // Add temporary resistance bonuses from status effects
        defenses.armor *= defenderMods.armorMultiplier; // Apply armor multiplier from buffs
        defenses.fireResistance = defenses.fireResistance + defenderMods.additionalFireResistance + defenderMods.additionalElementalResistance;
        defenses.coldResistance = defenses.coldResistance + defenderMods.additionalColdResistance + defenderMods.additionalElementalResistance;
        defenses.lightningResistance = defenses.lightningResistance + defenderMods.additionalLightningResistance + defenderMods.additionalElementalResistance;

        return defenses;
    }

    // =============================================
    // POISON SYSTEM METHODS
    // =============================================

    /**
     * Apply poison damage over time - poison cannot be resisted, only cured
     */
    applyPoisonDoT(sourceId, targetId, totalDamage, options = {}) {
        const duration = options.duration || this.POISON_CONFIG.DEFAULT_DURATION;
        const ticks = options.ticks || this.POISON_CONFIG.DEFAULT_TICKS;
        
        // Poison cannot be resisted - it always applies at full strength
        const perTickDamage = Math.max(1, Math.ceil(totalDamage / ticks));

        // Initialize status effects for target if needed
        if (!this.activeStatusEffects.has(targetId)) {
            this.activeStatusEffects.set(targetId, { poison: [] });
        }

        const statusEffects = this.activeStatusEffects.get(targetId);
        
        // Check current poison stacks
        if (statusEffects.poison.length >= this.POISON_CONFIG.STACK_LIMIT) {
            if (this.POISON_CONFIG.STACK_REFRESH) {
                // Remove oldest poison stack and add new one
                statusEffects.poison.shift();
            } else {
                // Cannot add more poison
                return { damage: 0, prevented: true, reason: 'stack_limit' };
            }
        }
        const poisonEffect = {
            sourceId,
            remainingTicks: ticks,
            damagePerTick: perTickDamage,
            tickInterval: duration / ticks,
            nextTickTime: this.game.state.now + (duration / ticks),
            startTime: this.game.state.now,
            totalDamage: perTickDamage * ticks
        };

        statusEffects.poison.push(poisonEffect);

      
        return {
            damage: poisonEffect.totalDamage,
            isPoison: true,
            stacks: statusEffects.poison.length,
            tickDamage: perTickDamage,
            duration: duration
        };
    }

    /**
     * Process ongoing poison damage
     */
    processStatusEffects() {     

        
        for (const [entityId, statusEffects] of this.activeStatusEffects.entries()) {
            const targetHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            const targetDeathState = this.game.getComponent(entityId, this.componentTypes.DEATH_STATE);
            
            if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
                // Entity is dead or dying, remove all status effects
                this.activeStatusEffects.delete(entityId);
                continue;
            }
            // Process poison effects
            statusEffects.poison = statusEffects.poison.filter(poisonEffect => {
                if (this.game.state.now >= poisonEffect.nextTickTime) {
                    // Apply poison damage
                    targetHealth.current -= poisonEffect.damagePerTick;
                    
                    // Visual feedback for poison
                    this.applyVisualFeedback(entityId, { finalDamage: poisonEffect.damagePerTick }, this.ELEMENT_TYPES.POISON);

                    // Check for death from poison
                    if (targetHealth.current <= 0) {
                        this.handleEntityDeath(entityId);
                        return false; // Remove this poison effect
                    }

                    // Update for next tick
                    poisonEffect.remainingTicks--;
                    poisonEffect.nextTickTime = this.game.state.now + poisonEffect.tickInterval;

                    // Keep poison if ticks remain
                    return poisonEffect.remainingTicks > 0;
                }
                return true; // Keep poison effect
            });

            // Remove entity from status effects if no effects remain
            if (statusEffects.poison.length === 0) {
                this.activeStatusEffects.delete(entityId);
            }
        }
    }

    /**
     * Cure poison effects
     */
    curePoison(targetId, stacksToRemove = null) {
        const statusEffects = this.activeStatusEffects.get(targetId);
        if (!statusEffects || statusEffects.poison.length === 0) return false;

        const removeCount = stacksToRemove || statusEffects.poison.length;
        const removedStacks = statusEffects.poison.splice(0, removeCount);

        if (statusEffects.poison.length === 0) {
            this.activeStatusEffects.delete(targetId);
        }

        return true;
    }

    // =============================================
    // DELAYED DAMAGE SYSTEM
    // =============================================

    /**
     * Schedule damage to be applied later (for melee attacks, timed effects, etc.)
     */
    scheduleDamage(sourceId, targetId, damage, element, delay, options = {}) {
        const triggerTime = this.game.state.now + delay;
        const eventId = `${sourceId}_${targetId}_${this.game.state.now}_${Math.random()}`;
        
        this.pendingDamageEvents.set(eventId, {
            sourceId,
            targetId,
            damage,
            element: element || this.ELEMENT_TYPES.PHYSICAL,
            triggerTime,
            options,
            eventId
        });
        
        return eventId;
    }

    /**
     * Process pending damage events
     */
    processPendingDamage() {        

        const eventsToRemove = [];
        
        for (const [eventId, event] of this.pendingDamageEvents.entries()) {

            if (this.game.state.now >= event.triggerTime) {
                // Check if target is still valid
                const targetHealth = this.game.getComponent(event.targetId, this.componentTypes.HEALTH);
                const targetDeathState = this.game.getComponent(event.targetId, this.componentTypes.DEATH_STATE);
                
                if (targetHealth && targetHealth.current > 0 && (!targetDeathState || !targetDeathState.isDying)) {
                    // Apply the delayed damage
                     this.applyDamage(event.sourceId, event.targetId, event.damage, event.element, {
                        ...event.options,
                        isDelayed: true
                    });
                }
                
                eventsToRemove.push(eventId);
            }
        }
        
        eventsToRemove.forEach(id => this.pendingDamageEvents.delete(id));
    }


    calculateDistance3D(pos1, pos2) {
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const dz = pos2.z - pos1.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    capResistance(resistance) {
        return Math.min(this.RESISTANCE_CAP, Math.max(-1.0, resistance));
    }

    getPoisonStacks(entityId) {
        const statusEffects = this.activeStatusEffects.get(entityId);
        return statusEffects ? statusEffects.poison.length : 0;
    }


    applyVisualFeedback(targetId, damageResult, element) {
        const targetAnimation = this.game.getComponent(targetId, this.componentTypes.ANIMATION);
        if (targetAnimation) {
            // Different flash intensities based on element
            switch (element) {
                case this.ELEMENT_TYPES.FIRE:
                    targetAnimation.flash = 0.6;
                    break;
                case this.ELEMENT_TYPES.COLD:
                    targetAnimation.flash = 0.5;
                    break;
                case this.ELEMENT_TYPES.LIGHTNING:
                    targetAnimation.flash = 0.8;
                    break;
                case this.ELEMENT_TYPES.POISON:
                    targetAnimation.flash = 0.3; // Subtle for DoT
                    break;
                case this.ELEMENT_TYPES.DIVINE:
                    targetAnimation.flash = 0.7;
                    break;
                default:
                    targetAnimation.flash = 0.5;
                    break;
            }
        }
    }


    handleEntityDeath(entityId) {
        // Notify other systems about death
        this.game.gameManager.call('startDeathProcess', entityId);
    }

    entityDestroyed(entityId) {
        // Clear pending damage events for this entity
        const eventsToRemove = [];
        for (const [eventId, event] of this.pendingDamageEvents.entries()) {
            if (event.sourceId === entityId || event.targetId === entityId) {
                eventsToRemove.push(eventId);
            }
        }
        eventsToRemove.forEach(id => this.pendingDamageEvents.delete(id));
        
        // Clear status effects
        this.activeStatusEffects.delete(entityId);
    }

    update() {
        this.processStatusEffects();
        this.processPendingDamage();
    }

    clearAllStatusEffects(entityId) {
        this.activeStatusEffects.delete(entityId);
    }

    clearAllDamageEffects() {        
        this.activeStatusEffects.clear();  
        this.pendingDamageEvents.clear();
    }

    getStatusEffects(entityId) {
        return this.activeStatusEffects.get(entityId) || { poison: [] };
    }

};

// system: AbilitySystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['AbilitySystem'] = class AbilitySystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.abilitySystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        this.abilityActionCounter = 0;
        this.entityAbilities = new Map();
        this.abilityCooldowns = new Map();
        this.abilityQueue = new Map();
        this.abilityActions = new Map();
    }

    init() {
        this.game.gameManager.register('getEntityAbilities', this.getEntityAbilities.bind(this));
        this.game.gameManager.register('removeEntityAbilities', this.removeEntityAbilities.bind(this));
    }

    addAbilitiesToUnit(entityId, abilityIds) {
        if (!Array.isArray(abilityIds)) {
            abilityIds = [abilityIds];
        }
        const unitAbilities = [];
        
        abilityIds.forEach(abilityId => {
            const AbilityClass = this.game.app.appClasses[abilityId];
            if (AbilityClass) {
                const abilityInstance = new AbilityClass(this.game, this.game.getCollections().abilities[abilityId]);
                unitAbilities.push(abilityInstance);
            } else {
                console.warn(`Ability '${abilityId}' not found`);
            }
        });
        
        if (unitAbilities.length > 0) {
            this.entityAbilities.set(entityId, unitAbilities);
        }
    }

    update() {
        if (this.game.state.phase !== 'battle') return;

        this.processAbilityQueue();
        this.processAbilityActions();
        this.updateAIAbilityUsage();
    }
    processAbilityQueue() {        
        for (const [entityId, queuedAbility] of this.abilityQueue.entries()) {
            if (this.game.state.now >= queuedAbility.executeTime) {
                const abilities = this.entityAbilities.get(entityId);
                if (abilities) {
                    const ability = abilities.find(a => a.id === queuedAbility.abilityId);
                    if (ability) {
                        // Execute ability and get potential callback
                        const abilityAction = ability.execute(entityId, queuedAbility.targetData);
                        
                        // If ability returns a callback, schedule it deterministically
                        if (typeof abilityAction === 'function') {
                            // Add to a delayed effects queue
                            this.scheduleAbilityAction(abilityAction, ability.castTime);
                        }
                    }
                }
                this.abilityQueue.delete(entityId);
            }
        }
    }
    scheduleAbilityAction(action, castTime) {        
        const executeTime = this.game.state.now + castTime;
        const effectId = `${this.game.state.now}_${this.abilityActionCounter++}`;
    
        this.abilityActions.set(effectId, {
            callback: action,
            executeTime: executeTime
        });
    }
    processAbilityActions() {
        if (!this.abilityActions) return;
        
        for (const [effectId, abilityAction] of this.abilityActions.entries()) {
            if (this.game.state.now >= abilityAction.executeTime) {
                abilityAction.callback();
                this.abilityActions.delete(effectId);
            }
        }
    }
    updateAIAbilityUsage() {
        const sortedEntityIds = Array.from(this.entityAbilities.keys()).sort((a, b) => 
            String(a).localeCompare(String(b))
        );
        
        sortedEntityIds.forEach(entityId => {
            const abilities = this.entityAbilities.get(entityId);
            this.considerAbilityUsage(entityId, abilities);
        });
    }
    
    considerAbilityUsage(entityId, abilities) {
        if (this.abilityQueue.has(entityId)) {
            return; // Entity is already casting an ability, wait for it to finish
        }
        
        const availableAbilities = abilities
            .filter(ability => this.isAbilityOffCooldown(entityId, ability.id))
            .filter(ability => ability.canExecute(entityId))
            .sort((a, b) => b.priority - a.priority);
        
        // Check if unit is waiting and now has abilities available
        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
        if (aiState && aiState.state === 'waiting' && availableAbilities.length > 0) {
            // Transition back to attacking state since we have abilities ready
            if (this.game.combatAISystems) {
                this.game.combatAISystems.changeAIState(aiState, 'attacking');
                
                // Re-enable movement decisions by resetting decision time
                aiState.aiBehavior.lastDecisionTime = 0;
                
            }
        }
        
        if (availableAbilities.length > 0) {
            this.useAbility(entityId, availableAbilities[0].id);
        }
    }
    
    useAbility(entityId, abilityId, targetData = null) {
        const abilities = this.entityAbilities.get(entityId);
        if (!abilities) return false;
        
        const ability = abilities.find(a => a.id === abilityId);
        if (!ability) return false;
        

        
        if (!this.isAbilityOffCooldown(entityId, abilityId)) {
            return false;
        }
        
        if (!ability.canExecute(entityId, targetData)) {
            return false;
        }

        if (!ability.isPassive) {
            this.startAbilityAnimation(entityId, ability);
        }
        this.abilityQueue.set(entityId, {
            abilityId: abilityId,
            targetData: targetData,
            executeTime: this.game.state.now + ability.castTime
        });
        
        this.setCooldown(entityId, abilityId, ability.cooldown);
        ability.logAbilityUsage(entityId);
        
        return true;
    }
    
    startAbilityAnimation(entityId, ability) {
        const animationsToTry = ['attack', 'idle'];

        for (const anim of animationsToTry) {

            // For abilities, use normal speed unless it's an attack-based ability
            let animationSpeed = 1.0;
            let minAnimationTime = 1.5;

            if (ability) {
                animationSpeed = this.game.gameManager.call('calculateAnimationSpeed', entityId, ability.castTime);
                minAnimationTime = 1 / ability.castTime;
            }
            if(this.game.gameManager.has('triggerSinglePlayAnimation')){
                this.game.gameManager.call('triggerSinglePlayAnimation', entityId, anim, animationSpeed, minAnimationTime);
            }
            break;

        }
    }
    
    setCooldown(entityId, abilityId, cooldownDuration) {
        const key = `${entityId}_${abilityId}`;
        this.abilityCooldowns.set(key, this.game.state.now + cooldownDuration);
    }
    
    isAbilityOffCooldown(entityId, abilityId) {
        const key = `${entityId}_${abilityId}`;
        const cooldownEnd = this.abilityCooldowns.get(key);
        return !cooldownEnd || this.game.state.now >= cooldownEnd;
    }
    
    getRemainingCooldown(entityId, abilityId) {
        const key = `${entityId}_${abilityId}`;
        const cooldownEnd = this.abilityCooldowns.get(key);
        return !cooldownEnd ? 0 : Math.max(0, cooldownEnd - this.game.state.now);
    }
    
    getEntityAbilities(entityId) {
        return this.entityAbilities.get(entityId) || [];
    }
    
    getAbilityCooldowns(entityId) {
        const abilities = this.getEntityAbilities(entityId);

        return abilities.map(ability => ({
            id: ability.id,
            name: ability.name,
            remainingCooldown: this.getRemainingCooldown(entityId, ability.id),
            totalCooldown: ability.cooldown
        }));
    }
    
    createAbility(abilityId) {
        const AbilityClass = this.game.app.appClasses[abilityId];
        return AbilityClass ? new AbilityClass() : null;
    }
    
    getAvailableAbilityIds() {
        return Object.keys(this.game.getCollections().abilities);
    }
        
    removeEntityAbilities(entityId) {
        this.entityAbilities.delete(entityId);
        this.abilityQueue.delete(entityId);
        
        // Clean up cooldowns
        const keysToRemove = [];
        for (const key of this.abilityCooldowns.keys()) {
            if (key.startsWith(`${entityId}_`)) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => this.abilityCooldowns.delete(key));
        
    }
    onPlacementPhaseStart() {
        for (const [entityId, abilities] of this.entityAbilities.entries()) {
            abilities.forEach(ability => {
                if (typeof ability.onPlacementPhaseStart === 'function') {
                    ability.onPlacementPhaseStart(entityId);
                }
            });
        }            
    }     
    onBattleEnd() {
        
        // Call onBattleEnd on all ability instances
        for (const [entityId, abilities] of this.entityAbilities.entries()) {
            abilities.forEach(ability => {
                if (typeof ability.onBattleEnd === 'function') {
                    ability.onBattleEnd(entityId);
                }
            });
        }
        
        // Clear all ability queues and cooldowns
        this.abilityQueue.clear();
        this.abilityActions.clear();
        this.abilityCooldowns.clear();
        this.abilityActionCounter = 0;
        
    }

    destroy() {
        this.entityAbilities.clear();
        this.abilityCooldowns.clear();
        this.abilityQueue.clear();
        this.abilityActions.clear();
    }
    entityDestroyed(entityId) {
        this.removeEntityAbilities(entityId);
    }
};

// system: SquadExperienceSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SquadExperienceSystem'] = class SquadExperienceSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.squadExperienceSystem = this;
        
        // Squad experience tracking
        this.squadExperience = new Map(); // placementId -> experience data
        this.savedSquadExperience = new Map(); // placementId -> saved experience data
        
        // Experience configuration
        this.config = {
            experiencePerLevel: 15,     // Base experience needed per level
            maxLevel: 10,                // Maximum squad level
            levelUpCostRatio: 0.5,       // Cost to level up = squad value * ratio
            experienceMultiplier: 1.0,   // Global experience gain multiplier
            baselineXPPerSecond: 1,   // tune: ~1â€“3% of a cheap unitâ€™s value per 10s
            baselineXPCombatOnly: true  // only tick during combat phase
        };
        
        // Level bonuses (applied to all units in squad)
        this.levelBonuses = {
            1: { hp: 1.0, damage: 1.0, name: "Rookie" },            
            2: { hp: 1.15, damage: 1.15, name: "Veteran" },
            3: { hp: 1.3, damage: 1.3, name: "Ascended" },
            4: { hp: 1.4, damage: 1.4, name: "Elite" },
            5: { hp: 1.5, damage: 1.5, name: "Champion" },
            6: { hp: 1.6, damage: 1.6, name: "Legendary" },
            7: { hp: 1.7, damage: 1.7, name: "Mythic" },
            8: { hp: 1.8, damage: 1.8, name: "Divine" },
            9: { hp: 1.9, damage: 1.9, name: "Transcendent" },
            10: { hp: 2.0, damage: 2.0, name: "Godlike" }
        };
        
        // UI update throttling
        this.lastUIUpdate = 0;
        this.UI_UPDATE_INTERVAL = 500; // Update UI every 500ms

    }

    init() {
        this.game.gameManager.register('canAffordLevelUp', this.canAffordLevelUp.bind(this));
        this.game.gameManager.register('applySpecialization', this.applySpecialization.bind(this));
        this.game.gameManager.register('levelUpSquad', this.levelUpSquad.bind(this));
        this.game.gameManager.register('getLevelUpCost', this.getLevelUpCost.bind(this));
        this.game.gameManager.register('initializeSquad', this.initializeSquad.bind(this));
        this.game.gameManager.register('removeSquad', this.removeSquad.bind(this));
        this.game.gameManager.register('getSquadsReadyToLevelUp', this.getSquadsReadyToLevelUp.bind(this));
        this.game.gameManager.register('showSpecializationSelection', this.showSpecializationSelection.bind(this));
        this.game.gameManager.register('findSquadByUnitId', this.findSquadByUnitId.bind(this));
        this.game.gameManager.register('getCurrentUnitType', this.getCurrentUnitType.bind(this));
        this.game.gameManager.register('getSquadInfo', this.getSquadInfo.bind(this));
        this.game.gameManager.register('resetSquadExperience', this.reset.bind(this));
    }

    /**
     * Initialize experience tracking for a new squad
     * @param {string} placementId - Unique placement identifier
     * @param {Object} unitType - Unit type definition (not squadData)
     * @param {Array} unitIds - Array of entity IDs in the squad
     * @param {string} team - Team identifier
     */
    initializeSquad(placementId, unitType, unitIds, team) {
        // Check if we already have experience data for this placement ID
        const existingData = this.squadExperience.get(placementId);
        if (existingData) {
       
            // Update unit IDs and size for respawned squad
            existingData.unitIds = [...unitIds];
            existingData.squadSize = unitIds.length;
            
            // Apply level bonuses to new units
            this.applyLevelBonuses(placementId);
            return existingData;
        }
        
        // Create new squad data
        const squadValue = this.calculateSquadValue(unitType);
        
        const experienceData = {
            placementId: placementId,
            level: 1,
            experience: 0,
            experienceToNextLevel: this.calculateExperienceNeeded(0),
            squadValue: squadValue,
            unitIds: [...unitIds],
            team: team,
            squadSize: unitIds.length,
            canLevelUp: false,
            totalUnitsInSquad: unitIds.length, // Just use actual unit count
            lastExperienceGain: 0,
            creationTime: this.game.state.now
        };
        
        this.squadExperience.set(placementId, experienceData);
        
        // Try to restore saved experience for player squads
  
        this.restoreSquadExperience(placementId, experienceData);
        
        // Apply initial bonuses if any
        this.applyLevelBonuses(placementId);
         return experienceData;
    }
    /**
     * Add experience to a squad
     * @param {string} placementId - Squad placement ID
     * @param {number} experience - Experience to add
     */
    addExperience(placementId, experience) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return;
        
        // Don't gain experience if already at max level or ready to level up
        if (squadData.level >= this.config.maxLevel || squadData.canLevelUp) {
            return;
        }
        
        squadData.experience += experience;
        squadData.lastExperienceGain = this.game.state.now;
        
        // Check if squad can level up
        if (squadData.experience >= squadData.experienceToNextLevel) {
            squadData.canLevelUp = true;
            // Stop gaining experience until manually leveled up
            squadData.experience = squadData.experienceToNextLevel;
                
        }
        
        // Update UI periodically
        if (this.game.state.now - this.lastUIUpdate > this.UI_UPDATE_INTERVAL) {
            this.updateSquadUI();
            this.lastUIUpdate = this.game.state.now;
        }
    }
    getLevelUpCost(placementId){
        
        const squadData = this.squadExperience.get(placementId);
        if(squadData){
            const levelUpCost = this.getLevelUpCostBySquadValue(squadData.squadValue)

            return levelUpCost;
        } else {
            return -1;
        }
    }
    getLevelUpCostBySquadValue(squadValue){
        return Math.floor(squadValue * this.config.levelUpCostRatio);
    }
    canAffordLevelUp(placementId, playerGold){
                
        const levelUpCost = this.getLevelUpCost(placementId);

         if (levelUpCost < 0 || playerGold < levelUpCost) {    
            return false;
         }
         return true;
    }
    /**
     * Level up a squad (only during placement phase)
     * @param {string} placementId - Squad placement ID
     * @param {string} specializationId - Optional specialization unit ID (for level 3+)
     * @returns {boolean} Success status
     */
    async levelUpSquad(placementId, specializationId = null, playerId = null, callback) {
        if (this.game.state.phase !== 'placement') {
            console.log("incorrect phase to level up");
            callback(false);
        }
        
        const squadData = this.squadExperience.get(placementId);
        if (!squadData || !squadData.canLevelUp) {
            console.log("squad cant level up", placementId, squadData, this.squadExperience);
            callback(false);
        };        
                        
        // Check for specialization selection UI (unchanged)
        const isSpecializationLevel = squadData.level >= 2;
        const currentUnitType = this.getCurrentUnitType(placementId, squadData.team);
        const hasSpecializations = currentUnitType && currentUnitType.specUnits && currentUnitType.specUnits.length > 0;
        if (!this.game.isServer && isSpecializationLevel && hasSpecializations && !specializationId) {
            this.showSpecializationSelection(placementId, squadData, callback);
            console.log('showing spec selection');
            return;
        }
        
        
        try {
            if (!this.game.isServer) {
                // Handle specialization case
                if (specializationId && isSpecializationLevel && hasSpecializations) {
                    const success = await this.makeNetworkCall('LEVEL_SQUAD', 
                        { placementId, specializationId }, 'SQUAD_LEVELED');
       
                    if (!success) {
                        console.log('no success making network call apply_spec or level_squad');
                        callback(false);
                    } 
                    this.applySpecialization(placementId, specializationId, playerId);
                } else {
                    // Handle regular level up
                    const success = await this.makeNetworkCall('LEVEL_SQUAD', 
                        { placementId }, 'SQUAD_LEVELED');
                    
                    if (!success) {
                        console.log('no success making network call level_squad');
                        callback(false);
                    }
                }
            } 
                
            // Deduct cost optimistically
            callback(this.finishLevelingSquad(squadData, placementId, specializationId));
            
        } catch (error) {
            // Refund gold on any error
            console.log('failed to level squad', error);
            callback(false);
        }
    }

    // Helper method to promisify network calls
    makeNetworkCall(action, data, expectedResponse) {
        return new Promise((resolve, reject) => {
            this.game.clientNetworkManager.call(action, data, expectedResponse, (responseData, error) => {
                if(responseData && responseData.success) {
                    resolve(responseData);
                } else {
                    reject(error);
                }
            });
        });
    }

    finishLevelingSquad(squadData, placementId, specializationId) {
        console.log('finishLevelingSquad');
        // Level up
        squadData.level++;
        squadData.experience = 0;
        squadData.experienceToNextLevel = this.calculateExperienceNeeded(squadData.level);
        squadData.canLevelUp = false;
        
        // Apply level bonuses to all units in squad
        this.applyLevelBonuses(placementId);
        
        const levelUpCost = this.getLevelUpCost(placementId);  
        this.game.state.playerGold -= levelUpCost;
            
        console.log('leveling squad for cost', placementId, levelUpCost);
        // Visual effects
        squadData.unitIds.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);
            if (pos) {
                const effectType = specializationId ? 'magic' : 'heal';
                this.game.gameManager.call('createParticleEffect',
                    pos.x, pos.y + 20, pos.z,
                    effectType,
                    { count: 3, speedMultiplier: specializationId ? 1.5 : 1.2 }
                );
            }
        });
        return true;
    }
    
    /**
     * Apply specialization transformation to a squad
     * @param {string} placementId - Squad placement ID
     * @param {string} specializationId - Specialization unit type ID
     * @returns {boolean} Success status
     */
    applySpecialization(placementId, specializationId, playerId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return false;
        
        // Get the specialization unit type
        const collections = this.game.getCollections();
        if (!collections || !collections.units || !collections.units[specializationId]) {
            console.error(`Specialization unit type ${specializationId} not found`);
            return false;
        }
        
        const specializationUnitType = collections.units[specializationId];
        
        // Find the placement in PlacementSystem to update the unit type
        const placement = this.game.gameManager.call('getPlacementById', placementId);
        if (!placement) {
            console.error(`Placement ${placementId} not found`);
            return false;
        }
        
        // Update the placement's unit type
        const oldUnitType = placement.unitType;
        placement.unitType = { id: specializationId, ...specializationUnitType };
        
        // Recreate all units in the squad with the new unit type
        const componentTypes = this.game.componentManager.getComponentTypes();
        const newUnitIds = [];
        
        console.log('applying specialization to ', squadData, squadData.unitIds);
        console.log('placement', placement);
        // Store positions of old units
        const positions = [];
        squadData.unitIds.forEach(entityId => {
            const pos = this.game.getComponent(entityId, componentTypes.POSITION);
            if (pos) {
                positions.push({ x: pos.x, y: pos.y, z: pos.z });
            }
            // Destroy old unit
            if (this.game.destroyEntity) {
                this.game.destroyEntity(entityId);
            }
        });
        
        // Create new specialized units at the same positions
        positions.forEach(pos => {
            const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);
            const unitY = terrainHeight !== null ? terrainHeight : pos.y;
            
            const entityId = this.game.unitCreationManager.create(
                pos.x, unitY, pos.z, 
                placement.targetPosition,
                placement, 
                squadData.team
            );
            console.log('created new unit', placement.unitType, entityId);
            newUnitIds.push(entityId);
        });
        
        // Update squad data with new unit IDs
        squadData.unitIds = newUnitIds;
        
        // Update squad value based on new unit type
        squadData.squadValue = this.calculateSquadValue(placement.unitType);

        return true;
    }
    
    /**
     * Show specialization selection UI
     * @param {string} placementId - Squad placement ID
     * @param {Object} squadData - Squad experience data
     */
    showSpecializationSelection(placementId, squadData, callback) {
        const currentUnitType = this.getCurrentUnitType(placementId, squadData.team);
        if (!currentUnitType || !currentUnitType.specUnits) return;
        
        const collections = this.game.getCollections();
        if (!collections || !collections.units) return;
        
        // Create specialization selection modal
        const modal = document.createElement('div');
        modal.className = 'specialization-modal';
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); z-index: 10000;
            display: flex; justify-content: center; align-items: center;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #ffaa00; border-radius: 10px;
            padding: 20px; max-width: 600px; width: 90%;
            color: #fff; text-align: center;
        `;
        
        const squadName = this.getSquadDisplayName(placementId);
        content.innerHTML = `
            <h3 style="color: #ffaa00; margin-bottom: 15px;">â­ SPECIALIZATION AVAILABLE! â­</h3>
            <p style="margin-bottom: 20px;">Choose a specialization for your ${squadName}:</p>
            <div id="specialization-options" style="margin-bottom: 20px;"></div>
            <button id="cancel-specialization" style="
                background: #666; color: #fff; border: none; padding: 8px 16px;
                border-radius: 4px; cursor: pointer; margin-right: 10px;
            ">Cancel</button>
        `;
        
        modal.appendChild(content);
        
        // Add specialization options
        const optionsContainer = content.querySelector('#specialization-options');
        currentUnitType.specUnits.forEach(specId => {
            const specUnit = collections.units[specId];
            if (specUnit) {
                const optionButton = document.createElement('button');
                optionButton.style.cssText = `
                    display: block; width: 100%; margin: 8px 0; padding: 12px;
                    background: linear-gradient(135deg, #006600, #008800);
                    color: white; border: 1px solid #00aa00; border-radius: 4px;
                    cursor: pointer; transition: all 0.2s ease;
                `;
                
                const squadValue = this.calculateSquadValue(specUnit);
                const levelUpCost = this.getLevelUpCostBySquadValue(squadValue);
                optionButton.innerHTML = `
                    <strong>${specUnit.title || specId}</strong><br>
                    <small style="opacity: 0.8;">${specUnit.hp || 100} HP, ${specUnit.damage || 10} DMG - Cost: ${levelUpCost}g</small>
                `;
                
                optionButton.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    this.levelUpSquad(placementId, specId, null, callback);
                });
                
                optionButton.addEventListener('mouseenter', () => {
                    optionButton.style.background = 'linear-gradient(135deg, #008800, #00aa00)';
                    optionButton.style.transform = 'translateY(-2px)';
                });
                
                optionButton.addEventListener('mouseleave', () => {
                    optionButton.style.background = 'linear-gradient(135deg, #006600, #008800)';
                    optionButton.style.transform = 'translateY(0)';
                });
                
                optionsContainer.appendChild(optionButton);
            }
        });
        
        // Cancel button
        content.querySelector('#cancel-specialization').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        // Close on escape
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                document.body.removeChild(modal);
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        document.body.appendChild(modal);
    }
    
    /**
     * Get the current unit type for a squad
     * @param {string} placementId - Squad placement ID
     * @returns {Object|null} Unit type or null if not found
     */
    getCurrentUnitType(placementId, side) {
        const placements = this.game.gameManager.call('getPlacementsForSide', side);
        if(placements){
            const placement = placements.find(p => p.placementId === placementId);
            return placement ? placement.unitType : null;
        }
        return null;
    }
    
    /**
     * Apply level bonuses to all units in a squad
     * @param {string} placementId - Squad placement ID
     */
    applyLevelBonuses(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData || squadData.level <= 1) {
            return;
        }
        
        const bonuses = this.levelBonuses[squadData.level];
        if (!bonuses) {
            return;
        }
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        squadData.unitIds.forEach(entityId => {
            const unitType = this.game.getComponent(entityId, componentTypes.UNIT_TYPE);
            if (unitType) {
                const baseUnitData = this.game.getCollections().units[unitType.id];
            
                // Apply health bonus
                const health = this.game.getComponent(entityId, componentTypes.HEALTH);
                if (health && bonuses.hp > 1) {
                    const newMaxHealth = Math.floor(baseUnitData.hp * bonuses.hp);
                    const healthIncrease = newMaxHealth - health.max;
                    health.max = newMaxHealth;
                    health.current += healthIncrease; // Also increase current health
                }
                
                // Apply damage bonus
                const combat = this.game.getComponent(entityId, componentTypes.COMBAT);
                if (combat && bonuses.damage > 1) {
                    combat.damage = Math.floor(baseUnitData.damage * bonuses.damage);
                }
                
                // Visual indicator (flash effect)
                const animation = this.game.getComponent(entityId, componentTypes.ANIMATION);
                if (animation) {
                    animation.flash = 0.8;
                }
            }
        });
    }
    
    /**
     * Calculate total health of all units in a squad
     * @param {string} placementId - Squad placement ID
     * @returns {number} Total health
     */
    calculateSquadTotalHealth(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return 100; // Default fallback
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        let totalHealth = 0;
        
        squadData.unitIds.forEach(entityId => {
            const health = this.game.getComponent(entityId, componentTypes.HEALTH);
            if (health) {
                totalHealth += health.max;
            }
        });
        
        return Math.max(1, totalHealth); // Avoid division by zero
    }
    
    /**
     * Calculate squad value based on unit type
     * @param {Object} unitType - Unit type definition
     * @returns {number} Squad value (just the unit's base cost)
     */
    calculateSquadValue(unitType) {
        return unitType.value || 0;
    }
    
    /**
     * Calculate experience needed for next level
     * @param {number} currentLevel - Current level
     * @returns {number} Experience needed
     */
    calculateExperienceNeeded(currentLevel) {
        // Exponential scaling: level 1 = 100, level 2 = 150, level 3 = 225, etc.
        return Math.floor(this.config.experiencePerLevel * Math.pow(1.5, currentLevel));
    }
    
    /**
     * Find squad data by unit entity ID
     * @param {number} entityId - Unit entity ID
     * @returns {Object|null} Squad experience data
     */
    findSquadByUnitId(entityId) {
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            if (squadData.unitIds.includes(entityId)) {
                return squadData;
            }
        }
        return null;
    }
    
    /**
     * Get display name for a squad
     * @param {string} placementId - Squad placement ID
     * @returns {string} Display name
     */
    getSquadDisplayName(placementId) {
        // Try to get the name from placement system
        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', this.game.state.mySide);
        if (playerPlacements) {
            const placement = playerPlacements.find(p => p.placementId === placementId);
            if (placement && placement.unitType) {
                return placement.unitType.title || placement.unitType.id || 'Squad';
            }
        }

        const enemyPlacements = this.game.gameManager.call('getPlacementsForSide', this.game.state.mySide === 'left' ? 'right' : 'left');
        if (enemyPlacements) {
            const enemyPlacement = enemyPlacements.find(p => p.placementId === placementId);
            if (enemyPlacement && enemyPlacement.unitType) {
                return enemyPlacement.unitType.title || enemyPlacement.unitType.id || 'Enemy Squad';
            }
        }

        return `Squad ${placementId.slice(-4)}`;
    }
    
    /**
     * Get level bonus name
     * @param {number} level - Squad level
     * @returns {string} Bonus name
     */
    getLevelBonusName(level) {
        return this.levelBonuses[level]?.name || '';
    }
    
    /**
     * Update squad experience UI
     */
    updateSquadUI() {
        // This method could update a dedicated squad experience panel
        // For now, we'll just ensure the shop system can access this data
        this.game.gameManager.call('updateSquadExperience');
    }
    
    /**
     * Get all player squads that can level up
     * @returns {Array} Array of squad data that can level up
     */
    getSquadsReadyToLevelUp() {
        const readySquads = [];
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            if (squadData.canLevelUp && squadData.team == this.game.state.mySide) {
                readySquads.push({
                    ...squadData,
                    displayName: this.getSquadDisplayName(placementId),
                    levelUpCost: Math.floor(squadData.squadValue * this.config.levelUpCostRatio),
                    nextLevelName: this.getLevelBonusName(squadData.level + 1)
                });
            }
        }
        
        return readySquads;
    }
    
    /**
     * Get squad experience info for display
     * @param {string} placementId - Squad placement ID
     * @returns {Object} Experience info
     */
    getSquadInfo(placementId) {
        return this.squadExperience.get(placementId);        
    }

    setSquadInfo(placementId, placementExperience){
        if(placementExperience){
            this.squadExperience.set(placementId, placementExperience);
            console.log('applying opponent level bonuses', placementId);
            this.applyLevelBonuses(placementId);
        }
    }

    getExperienceFromPlacements(placements){
        let experience = {};
        placements.forEach((placement) => {
            experience[placement.placementId] = this.getSquadInfo(placement.placementId)
        });
        return experience;
    }
    
    /**
     * Clean up squad data when units are destroyed
     * MODIFIED: Only remove on explicit request, not automatic cleanup
     * @param {string} placementId - Squad placement ID
     */
    removeSquad(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (squadData) {
           this.squadExperience.delete(placementId);
        }
    }
    
    /**
     * Update method called each frame
     */
    update() {

        this.tickBaselineXP();
    }
    tickBaselineXP() {
        // Optional: restrict to combat only
        if (this.config.baselineXPCombatOnly && this.game?.state?.phase !== 'battle') return;

        for (const [placementId, squadData] of this.squadExperience.entries()) {
            // Respect caps: no gain if at max or waiting for manual level-up
            if (squadData.level >= this.config.maxLevel || squadData.canLevelUp) continue;

            const unitsAliveInSquad = this.unitsAliveInSquad(squadData);
            if (unitsAliveInSquad > 0) {
                const squadLivingRatio = unitsAliveInSquad / squadData.totalUnitsInSquad;                
                const xp = squadLivingRatio * this.config.baselineXPPerSecond * this.game.state.deltaTime * this.config.experienceMultiplier;
                if (xp > 0) this.addExperience(placementId, xp);
            }
        }
    }
    unitsAliveInSquad(squadData) {
        if (!squadData || !squadData.unitIds?.length) return 0;
        const componentTypes = this.game.componentManager.getComponentTypes();
        let count = 0;
        for (const id of squadData.unitIds) {
            const h = this.game.getComponent(id, componentTypes.HEALTH);
            if (h && h.current > 0) count++;
        }
        return count;
    }
    /**
     * Clean up experience data for squads with dead/missing units
     * MODIFIED: Never remove experience data, just update unit lists
     */
    onPlacementPhaseStart() {
        
        this.saveSquadExperience();
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            const validUnits = squadData.unitIds.filter(entityId => {
                const health = this.game.getComponent(entityId, componentTypes.HEALTH);
                return health && health.current > 0;
            });
            
            if (validUnits.length < squadData.unitIds.length) {             
                squadData.unitIds = validUnits;
                squadData.squadSize = validUnits.length;
            }
        }
    }
    
    /**
     * Reset all experience data (for new game)
     */
    reset() {
        this.squadExperience.clear();
        this.savedSquadExperience.clear();
    }

    /**
     * Save player squad experience before round cleanup
     */
    saveSquadExperience() {
        this.savedSquadExperience = new Map();
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {

            // Save the experience data
            this.savedSquadExperience.set(placementId, {
                level: squadData.level,
                experience: squadData.experience,
                experienceToNextLevel: squadData.experienceToNextLevel,
                canLevelUp: squadData.canLevelUp,
                squadValue: squadData.squadValue,
                totalUnitsInSquad: squadData.totalUnitsInSquad
            });
            
        }
    }

    /**
     * Restore saved player experience to a respawned squad
     */
    restoreSquadExperience(placementId, squadData) {
        const saved = this.savedSquadExperience.get(placementId);
        if (saved) {
            squadData.level = saved.level;
            squadData.experience = saved.experience;
            squadData.experienceToNextLevel = saved.experienceToNextLevel;
            squadData.canLevelUp = saved.canLevelUp;
            
          
            // Apply level bonuses if squad has levels
            if (squadData.level > 0) {
                this.applyLevelBonuses(placementId);
            }
            
            return true;
        }
        return false;
    }
    /**
     * Get debug information
     * @returns {Object} Debug info
     */
    getDebugInfo() {
        const squads = Array.from(this.squadExperience.values());
        return {
            totalSquads: squads.length,
            leftSquads: squads.filter(s => s.team === 'left').length,
            rightSquads: squads.filter(s => s.team === 'right').length,
            squadsReadyToLevelUp: squads.filter(s => s.canLevelUp).length,
            averageLevel: squads.length > 0 ? squads.reduce((sum, s) => sum + s.level, 0) / squads.length : 0,
            maxLevel: Math.max(0, ...squads.map(s => s.level))
        };
    }
};

// system: ServerBattlePhaseSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ServerBattlePhaseSystem'] = class ServerBattlePhaseSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.engine = this.game.app;    
        this.game.serverBattlePhaseSystem = this;
        this.serverNetworkManager = this.engine.serverNetworkManager;
        
        // Battle configuration
        this.maxBattleDuration = 30; // 90 seconds max
        this.minBattleDuration = 29;
        this.currentBattleTime = 0;
        // Battle state tracking
        this.battleResults = new Map();
        this.createdSquads = new Map();
        this.maxRounds = 5;
        this.baseGoldPerRound = 50;
    }

    init(params) {
        this.params = params || {};

        this.game.gameManager.register('startBattle', this.startBattle.bind(this));
        this.game.gameManager.register('spawnSquadFromPlacement', this.spawnSquadFromPlacement.bind(this));
    }

    startBattle(room) {
        try {

            this.game.state.isPaused = false;
            // Change room phase
            this.game.state.phase = 'battle';
            
            return { success: true };
            
        } catch (error) {
            console.error('Error in startBattle:', error);
            return { success: false, error: error.message };
        }
    }
    spawnSquadFromPlacement(playerId, placement) {
        try {
            const player = this.game.room.getPlayer(playerId);
            
            if (!this.game.unitCreationManager) {
                throw new Error('Unit creation manager not available');
            }
            
            // Get placements from placement phase manager
            const placementManager = this.game.placementSystem;
            if (!placementManager) {
                throw new Error('Placement phase manager not available');
            }
            let createdSquad = null;
      
            // Create squads using unit creation manager
            createdSquad = this.game.unitCreationManager.createSquadFromPlacement(
                placement,
                player.stats.side,
                playerId
            );

            if(!createdSquad){
                console.log("Failed to create squads");
                return { success: false };
            } else {
                // Store created squads for tracking
                let playerSquads = this.createdSquads.get(playerId);
                if(playerSquads){
                    playerSquads.push(createdSquad);
                } else {
                    playerSquads = [createdSquad];                    
                }
                this.createdSquads.set(playerId, playerSquads);
                return { success: true, squad: createdSquad };
            }
            
        } catch (error) {
            console.error('Error spawning units from placements:', error);
            return { success: false, error: `Failed to spawn units: ${error.message}` };
        }
    }

    // Called by game update loop to check for battle end
    update() {
        if (this.game.state?.phase !== 'battle') {
            return;
        }
        this.currentBattleTime += this.game.state.deltaTime;
        // Check for battle end conditions
        this.checkForBattleEnd();
    }

    checkForBattleEnd() {
        if (!this.game.componentManager) return;
        
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const allBattleEntities = this.game.getEntitiesWith(
            ComponentTypes.TEAM,
            ComponentTypes.HEALTH,
            ComponentTypes.UNIT_TYPE
        );

        const aliveEntities = allBattleEntities.filter(entityId => {
            const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
            const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
            return health && health.current > 0 && (!deathState || !deathState.isDying);
        });

        const teams = new Map();
        for (const entityId of aliveEntities) {
            const team = this.game.getComponent(entityId, ComponentTypes.TEAM);
            if (team) {
                if (!teams.has(team.team)) {
                    teams.set(team.team, []);
                }
                teams.get(team.team).push(entityId);
            }
        }
        const aliveTeams = Array.from(teams.keys());
           
        const noCombatActive = this.checkNoCombatActive(aliveEntities);
        const allUnitsAtTarget = this.checkAllUnitsAtTargetPosition(aliveEntities);
        
        if( this.currentBattleTime < this.minBattleDuration){
            return;
        }
        if( this.currentBattleTime > this.maxBattleDuration){
            this.endBattle(this.game.room, null);
            return;
        }

        if (aliveEntities.length === 0) {
            console.log('no alive entities');
            this.endBattle(this.game.room, null);
            return;
        }
        
        if (aliveTeams.length === 1 && allUnitsAtTarget) {
            console.log('aliveTeams length is 1', aliveTeams, aliveEntities);
            console.log('all entities', allBattleEntities);
            console.log('aliveEntities', aliveEntities);
            this.endBattle(this.game.room, aliveTeams[0]);
            return;
        }
     
        if (noCombatActive && allUnitsAtTarget) {
            console.log('no combat active and all units at target');
            this.endBattle(this.game.room, null);
        }
    }

    checkNoCombatActive(aliveEntities) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        
        for (const entityId of aliveEntities) {
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
         //   console.log(entityId, 'currentTarget', aiState.target);
            if (aiState && aiState.target) {
                return false;
            }
        }
        
        return true;
    }

    checkAllUnitsAtTargetPosition(aliveEntities) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const TARGET_POSITION_THRESHOLD = 20;
        
        for (const entityId of aliveEntities) {
            const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
            const targetPos = aiState?.targetPosition;

            if (!pos || !targetPos) {
                continue;
            }
            const distance = Math.sqrt(
                Math.pow(targetPos.x - pos.x, 2) + 
                Math.pow(targetPos.z - pos.z, 2)
            );
  
            if (distance > TARGET_POSITION_THRESHOLD) {
                return false;
            }
        }
        
        return true;
    }

    endBattle(room, winner = null, reason = 'unknown') {

        this.game.triggerEvent('onBattleEnd');        
        const playerStats = this.getPlayerStats(room);
        let battleResult = {
            winner: winner,
            reason: reason,
            round: this.game.state.round,
            survivingUnits: this.getSurvivingUnits(),
            playerStats: playerStats
        };
        
        const entitySync = this.serializeAllEntities();
        // Broadcast with updated health values
        this.serverNetworkManager.broadcastToRoom(room.id, 'BATTLE_END', {
            result: battleResult,
            gameState: room.getGameState(), // This will also have updated player health
            entitySync: entitySync
        });
        // Check for game end or continue to next round
        if (this.shouldEndGame(room)) {
            this.endGame(room);
        } else {
            this.game.state.round += 1;
            // Transition back to placement phase
            this.game.state.phase = 'placement';
            // Reset placement ready states
            for (const [playerId, player] of room.players) {
                player.placementReady = false;
            }
            this.game.triggerEvent('onPlacementPhaseStart');
        }
    }


    serializeAllEntities() {
        const serialized = {};
        
        for (const [entityId, componentTypes] of this.game.entities) {
            serialized[entityId] = {};
            
            for (const componentType of componentTypes) {
                const component = this.game.getComponent(entityId, componentType);
                if (component) {
                    serialized[entityId][componentType] = JSON.parse(JSON.stringify(component));
                }
            }
        }
        
        return serialized;
    }
    calculateRoundGold(round) {
        return this.baseGoldPerRound + (round * this.baseGoldPerRound);
    }
    getSurvivingUnits() {
        const survivors = {};
        
        // Count surviving units from created squads
        for (const [playerId, squads] of this.createdSquads) {
            let survivingCount = 0;
            let sideSurvivors = [];
            for (const squad of squads) {
                if (squad.squadUnits && this.game.componentManager) {
                    const ComponentTypes = this.game.componentManager.getComponentTypes();
                    
                    for (const entityId of squad.squadUnits) {
                        const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                        const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                  
                        if (health && health.current > 0 && (!deathState || !deathState.isDying)) {
                            sideSurvivors.push(entityId);
                            survivingCount++;
                        }
                    }
                }
            }
            
            survivors[playerId] = sideSurvivors;
        }
        
        return survivors;
    }

    getPlayerStats(room) {
        const stats = {};
        for (const [playerId, player] of room.players) {
            stats[playerId] = {
                name: player.name,
                stats: player.stats
            };
        }
        return stats;
    }

    shouldEndGame(room) {
        const alivePlayers = Array.from(room.players.values()).filter(p => (p.stats.health) > 0);
        return alivePlayers.length <= 1;
    }

  
    addGoldForTeam(goldAmt, team){
        for (const [playerId, player] of room.players) {
            if(player.side == team){
                player.stats.gold = player.stats.gold + goldAmt;
                break;
            }
        }
    }

    endGame(room) {
        this.game.state.phase = 'ended';
        
        // Determine final winner
        let finalWinner = null;
        let maxHealth = -1;
        
        for (const [playerId, player] of room.players) {
            const health = player.stats.health;
            if (health > maxHealth) {
                maxHealth = health;
                finalWinner = playerId;
            }
        }
        
        const gameResult = {
            winner: finalWinner,
            finalStats: this.getPlayerStats(room),
            totalRounds: this.game.state.round
        };
        
        this.serverNetworkManager.broadcastToRoom(room.id, 'GAME_END', {
            result: gameResult,
            gameState: room.getGameState()
        });
        
        // Mark room as inactive after delay
        setTimeout(() => {
            room.isActive = false;
        }, 10000);
    }

    onBattleEnd() {

        if (!this.game.componentManager) return;
        
        this.currentBattleTime = 0;
        
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const entitiesToDestroy = new Set();
        
        // Collect battle entities (but not players)
        [
            ComponentTypes.CORPSE
        ].forEach(componentType => {
            const entities = this.game.getEntitiesWith(componentType);
            entities.forEach(id => {
                entitiesToDestroy.add(id);                
            });
        });
        
        // Destroy entities
        entitiesToDestroy.forEach(entityId => {
            try {
                this.game.destroyEntity(entityId);
            } catch (error) {
                console.warn(`Error destroying entity ${entityId}:`, error);
            }
        });
  
        // Clear squad references
        this.createdSquads.clear();
    }

};

// system: ServerPlacementSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ServerPlacementSystem'] = class ServerPlacementSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);  
        this.game.placementSystem = this;
        this.serverNetworkManager = this.engine.serverNetworkManager;  
        this.playerPlacements = new Map();
        this.leftPlacements = [];
        this.rightPlacements = [];
        this.placementReadyStates = new Map();
        this.numPlayers = 2;
     }

    init(params) {
        this.params = params || {};
        this.game.gameManager.register('getPlacementsForSide', this.getPlacementsForSide.bind(this));
        this.game.gameManager.register('getPlacementById', this.getPlacementById.bind(this));
        this.subscribeToEvents();
    }
    subscribeToEvents() {
        if (!this.game.serverEventManager) {
            console.error('No event manager found on engine');
            return;
        }

        // Subscribe to room management events
        this.game.serverEventManager.subscribe('GET_STARTING_STATE', this.handleGetStartingState.bind(this));
        this.game.serverEventManager.subscribe('SUBMIT_PLACEMENT', this.handleSubmitPlacement.bind(this));
        this.game.serverEventManager.subscribe('PURCHASE_UPGRADE', this.handlePurchaseUpgrade.bind(this));
        this.game.serverEventManager.subscribe('READY_FOR_BATTLE', this.handleReadyForBattle.bind(this));
        this.game.serverEventManager.subscribe('LEVEL_SQUAD', this.handleLevelSquad.bind(this));
        this.game.serverEventManager.subscribe('SET_SQUAD_TARGET', this.handleSetSquadTarget.bind(this));
        this.game.serverEventManager.subscribe('SET_SQUAD_TARGETS', this.handleSetSquadTargets.bind(this));
    
    }

    getPlacementById(placementId) {
        // Search in player placements first
        const leftPlacements = this.leftPlacements.find(placement => placement.placementId === placementId);
        if (leftPlacements) {
            return leftPlacements;
        }
        
        // Search in opponent placements
        const rightPlacements = this.rightPlacements.find(placement => placement.placementId === placementId);
        if (rightPlacements) {
            return rightPlacements;
        }
        
        // Return null if no matching placement is found
        return null;
    }
    getPlayerIdByPlacementId(placementId) {
        // Iterate through all players and their placements
        for (const [playerId, placements] of this.playerPlacements) {
            // Check if any placement in this player's placements matches the placementId
            const foundPlacement = placements.find(placement => placement.placementId === placementId);
            if (foundPlacement) {
                return playerId;
            }
        }
        
        // Return null if no matching placement is found
        return null;
    }
    getPlacementsForSide(side){
        if(side == 'left'){
            return this.leftPlacements;
        } else {
            return this.rightPlacements;
        }
    }

    handleGetStartingState(eventData) {
        try {
            const { playerId, data } = eventData;
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'GOT_STARTING_STATE', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            if(player){
                this.serverNetworkManager.sendToPlayer(playerId, 'GOT_STARTING_STATE', this.getStartingState(player));
            }
            
        } catch (error) {
            console.error('Error getting starting state:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'GOT_STARTING_STATE', { 
                error: 'Server error while submitting placements',
                playerId: eventData.playerId,
                ready: false,
                received: data,
                success: false
            });
        }
    }

    async handleLevelSquad(eventData){
        const { playerId, data } = eventData;
        const { placementId, specializationId } = data;
        let playerGold = 0;
        if(playerId){
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);         
            if(roomId){
                const room = this.engine.getRoom(roomId);
                if(room){
                    const player = room.players.get(playerId);                    
                    playerGold = player.stats.gold;
                    console.log('got player gold', playerGold);
            
                    if (!this.game.gameManager.call('canAffordLevelUp', placementId, playerGold)) {
                        console.log("not enough gold to level up");
                        this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_LEVELED', {
                            playerId: playerId,
                            error: "gold_low_error",
                            success: false
                        });
                        return false;
                    }
                    const success1 = specializationId ? this.game.gameManager.call('applySpecialization', placementId, specializationId, playerId) : true;

                    await this.game.gameManager.call('levelUpSquad', placementId, null, playerId, (success) => {
                        console.log('success?: ', success1, success);
                        if(success1 && success){
                            const levelUpCost = this.game.gameManager.call('getLevelUpCost', placementId);        
                            
                            player.stats.gold -= levelUpCost;
                            console.log('leveled, new gold amt:', player.stats.gold);
                            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_LEVELED', {
                                playerId: playerId,
                                currentGold: player.stats.gold,
                                success: true
                            });
                        }
                    });
           
                }
            }
        } 
    }

    handleSubmitPlacement(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placement, ready } = data;
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'SUBMITTED_PLACEMENT', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            this.serverNetworkManager.sendToPlayer(playerId, 'SUBMITTED_PLACEMENT', this.submitPlayerPlacement(playerId, player, placement, true));
            
        } catch (error) {
            console.error('Error submitting placements:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'READY_FOR_BATTLE_UPDATE', { 
                error: 'Server error while submitting placements',
                playerId: eventData.playerId,
                ready: false,
                received: data
            });
        }
    }

    handlePurchaseUpgrade(eventData) {
        try {
            const { playerId, data } = eventData;
            
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'PURCHASED_UPGRADE', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            this.serverNetworkManager.sendToPlayer(playerId, 'PURCHASED_UPGRADE', this.purchaseUpgrade(playerId, player, data.data, true));
            
        } catch (error) {
            console.error('Error purchasing upgrades:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'PURCHASED_UPGRADE', { 
                error: 'Server error while purchasing upgrades',
                playerId: eventData.playerId,
                ready: false,
                received: data
            });
        }
    }

    handleSetSquadTarget(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placementId, targetPosition, meta } = data;
            if(this.game.state.phase != "placement") {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    success: false
                });
                return;
            };
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Room not found'
                });
                return;
            }
            
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            
            if (!player) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Player not found'
                });
                return;
            }
            
            // Validate placement belongs to player            
            const placement = this.getPlacementById(placementId);
            
            if (!placement) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Placement not found'
                });
                return;
            }
            
            // Store target position in placement data
            placement.targetPosition = targetPosition;
            placement.squadUnits.forEach((unitId) => {
                   
                this.game.gameManager.call('clearCommands', unitId);
                this.game.gameManager.call('queueCommand', unitId, {
                    type: 'move',
                    controllerId: "UnitOrderSystem",
                    targetPosition: targetPosition,
                    target: null,
                    meta: meta,
                    priority: this.game.commandQueueSystem.PRIORITY.MOVE,
                    interruptible: true
                }, true); // true = interrupt current command
            
            });
                    
               
            
            // Send success response to requesting player
            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                success: true,
                placementId,
                targetPosition,
                meta
            });
            
            // Broadcast to other players in the room
            for (const [otherPlayerId, otherPlayer] of room.players) {
                if (otherPlayerId !== playerId) {
                    this.serverNetworkManager.sendToPlayer(otherPlayerId, 'OPPONENT_SQUAD_TARGET_SET', {
                        placementId,
                        targetPosition,
                        meta
                    });
                }
            }
            
            console.log(`Player ${playerId} set target for squad ${placementId}:`, targetPosition);
            
        } catch (error) {
            console.error('Error setting squad target:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'SQUAD_TARGET_SET', { 
                error: 'Server error while setting squad target'
            });
        }
    }

    handleSetSquadTargets(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placementIds, targetPositions, meta } = data;
            if(this.game.state.phase != "placement") {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    success: false
                });
                return;
            };
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    error: 'Room not found'
                });
                return;
            }
            
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            
            if (!player) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    error: 'Player not found'
                });
                return;
            }
            
            for(let i = 0; i < placementIds.length; i++){
                let placementId = placementIds[i];
                let targetPosition = targetPositions[i];
                // Validate placement belongs to player            
                const placement = this.getPlacementById(placementId);
                
                if (!placement) {
                    console.log(placementId, 'not found');
                    this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                        error: 'Placement not found'
                    });
                    return;
                }
                
                // Store target position in placement data
                placement.targetPosition = targetPosition;
                placement.squadUnits.forEach((unitId) => {
                    this.game.gameManager.call('clearCommands', unitId);
                    this.game.gameManager.call('queueCommand', unitId, {
                        type: 'move',
                        controllerId: "UnitOrderSystem",
                        targetPosition: targetPosition,
                        target: null,
                        meta: meta,
                        priority: this.game.commandQueueSystem.PRIORITY.MOVE,
                        interruptible: true
                    }, true); // true = interrupt current command
                
                });
                        

                
                console.log(`Player ${playerId} set target for squad ${placementId}:`, targetPosition);
            }

                        // Send success response to requesting player
            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                success: true
            });
            
            // Broadcast to other players in the room
            for (const [otherPlayerId, otherPlayer] of room.players) {
                if (otherPlayerId !== playerId) {
                    this.serverNetworkManager.sendToPlayer(otherPlayerId, 'OPPONENT_SQUAD_TARGETS_SET', {
                        placementIds,
                        targetPositions,
                        meta
                    });
                }
            }
            
        } catch (error) {
            console.error('Error setting squad target:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'SQUAD_TARGETS_SET', { 
                error: 'Server error while setting squad target'
            });
        }
    }


    handleReadyForBattle(eventData) {
        const { playerId, data } = eventData; 
        const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
        if (!roomId) { 
            this.serverNetworkManager.sendToPlayer(playerId, 'READY_FOR_BATTLE_RESPONSE', { 
                error: 'Room not found'
            });
            return;
        }
        const room = this.engine.getRoom(roomId);
          
        const player = room.getPlayer(playerId);
        // Update ready state
        player.ready = true;
        this.placementReadyStates.set(playerId, true);
        
        this.serverNetworkManager.sendToPlayer(playerId, 'READY_FOR_BATTLE_RESPONSE', { success: true });
            
        // Check if all players are ready and start battle if so
        if (this.areAllPlayersReady() && this.game.state.phase === 'placement') {

            const gameState = room.getGameState();
            this.serverNetworkManager.broadcastToRoom(roomId, 'READY_FOR_BATTLE_UPDATE', {                       
                gameState: gameState,
                allReady: true
            });
            this.placementReadyStates.clear();
            // Small delay to ensure clients receive the ready update

            this.game.resetCurrentTime();
            this.applyTargetPositions();
            this.game.desyncDebugger.enabled = true;
            this.game.desyncDebugger.displaySync(true);
            this.resetAI();
            this.game.gameManager.call('startBattle', room);
        } else {
            const gameState = room.getGameState();
            this.serverNetworkManager.broadcastToRoom(roomId, 'READY_FOR_BATTLE_UPDATE', {                       
                gameState: gameState,
                allReady: false
            });
        }

    }
    
    resetAI() {
        const componentTypes = this.game.componentManager.getComponentTypes();            
        const AIEntities = this.game.getEntitiesWith(componentTypes.AI_STATE, componentTypes.COMBAT);      
        AIEntities.forEach((entityId) => {
            const aiState = this.game.getComponent(entityId, componentTypes.AI_STATE);
            const combat = this.game.getComponent(entityId, componentTypes.COMBAT);
            combat.lastAttack = 0;
            aiState.aiBehavior = {};
        });
    }

    applyTargetPositions() {
     //   console.log('APPLY TARGET POSITIONS');
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        for (const [playerId, placements] of this.playerPlacements) {
            placements.forEach((placement) => {     
                const targetPosition = placement.targetPosition;         
                placement.squadUnits.forEach(entityId => {
                    const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
                    const position = this.game.getComponent(entityId, ComponentTypes.POSITION);
                    if (aiState && position) {
                        
                        if(targetPosition){
                            const currentAIController = this.game.gameManager.call('getCurrentAIControllerId', entityId);

                            if(!currentAIController || currentAIController == "UnitOrderSystem"){
                                const dx = position.x - targetPosition.x;
                                const dz = position.z - targetPosition.z;
                                const distSq = dx * dx + dz * dz;
                                const placementGridSize = this.game.getCollections().configs.game.gridSize / 2;
                                const threshold = placementGridSize * 0.5;

                                if (distSq <= threshold * threshold) {
                                    this.game.gameManager.call('removeCurrentAIController', entityId);
                                    placement.targetPosition = null;
                                } else {
                                    let currentOrderAI = this.game.gameManager.call('getAIControllerData', entityId, "UnitOrderSystem");
                                    currentOrderAI.targetPosition = targetPosition;
                                    currentOrderAI.path = [];
                                    this.game.gameManager.call('setCurrentAIController', entityId, "UnitOrderSystem", currentOrderAI);
                                }
                            }
                        }
                    }
                });
            });
        }
    }

    areAllPlayersReady() {
        let states = [...this.placementReadyStates.values()]
        return states.length == this.numPlayers && states.every(ready => ready === true);
    }


    submitPlayerPlacement(playerId, player, placement) {
        // console.log(`=== SUBMIT PLACEMENT DEBUG ===`);
        // console.log(`Player ID: ${playerId}`);
        // console.log(`Room ID: ${this.game.room?.id || 'NO ROOM'}`);
        // console.log(`Game phase: ${this.game.state.phase}`);
        // console.log(`================================`);
    
        if (this.game.state.phase !== 'placement') {
            return { success: false, error: `Not in placement phase (${this.game.state.phase})` };
        }
        
        // Validate placements if provided
        if ( !this.validatePlacement(placement, player)) {
            return { success: false, error: 'Invalid placement' };
        }


        // Deduct gold only for new units
        if (placement.unitType?.value > 0 && !placement.isStartingState) {
            player.stats.gold -= placement.unitType?.value;
        }            
        
        
        // Store placements
        let playerPlacements = this.playerPlacements.get(playerId);
        if(playerPlacements){
            playerPlacements.push(placement);
        } else {
            playerPlacements = [placement];
        }
        this.playerPlacements.set(playerId, playerPlacements);

        if(player.stats.side == 'left'){
            this.leftPlacements = this.playerPlacements.get(playerId);
        } else {
            this.rightPlacements = this.playerPlacements.get(playerId);
        }

        const result = this.game.gameManager.call('spawnSquadFromPlacement', playerId, placement);

        if(result.success && result.squad){
            let squadUnits = [];
            result.squad.squadUnits.forEach((entityId) => {
                squadUnits.push(entityId);
            })
            placement.squadUnits = squadUnits;
            if (placement.placementId) {
                this.game.gameManager.call('initializeSquad',
                    placement.placementId,
                    placement.unitType,
                    placement.squadUnits,
                    placement.team
                );
            }
            if (placement.peasantInfo && placement.collection === 'buildings') {
                const peasantInfo = placement.peasantInfo;
                const peasantId = peasantInfo.peasantId;
                const entityId = placement.squadUnits[0];

                // Get the build ability from the peasant's abilities

                const peasantAbilities = this.game.gameManager.call('getEntityAbilities', peasantId);
                if (peasantAbilities) {
                    //console.log("peasantAbilities", peasantAbilities);
                    const buildAbility = peasantAbilities.find(a => a.id === 'build');
                    if (buildAbility) {
                        buildAbility.assignToBuild(peasantId, entityId, peasantInfo);
                    }
                }
                
                
                // Clear the flag (only once for first building entity)
                this.game.state.peasantBuildingPlacement = null;
            }
        }


        return { success: result.success };
    }


    onBattleEnd() {        
        this.removeDeadSquadsAfterRound();
       
        this.game.desyncDebugger.displaySync(true);
        this.game.desyncDebugger.enabled = false;
    }
    
    removeDeadSquadsAfterRound() {
        if (!this.game.componentManager) return;

        const ComponentTypes = this.game.componentManager.getComponentTypes();

        this.playerPlacements.forEach((placements, playerId) => {
            const survivingPlacements = placements.filter(placement => {
                if (!placement.experience?.unitIds || placement.experience.unitIds.length === 0) {
                    this.cleanupDeadSquad(placement);
                    return false;
                }

                const aliveUnits = placement.experience.unitIds.filter(entityId => {
                    const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                    const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                    const buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
                    if(buildingState) return true;
                    return health && health.current > 0 && (!deathState || !deathState.isDying);
                });

                if (aliveUnits.length === 0) {
                    this.cleanupDeadSquad(placement);
                    return false;
                }

                placement.experience.unitIds = aliveUnits;
                return true;
            });

            this.playerPlacements.set(playerId, survivingPlacements);
        });
    }

    cleanupDeadSquad(placement) {
        if (placement.placementId) {
            this.game.gameManager.call('releaseGridCells', placement.placementId);
            this.game.gameManager.call('removeSquad', placement.placementId);
        }

       // console.log(`Squad eliminated: ${placement.unitType?.title || placement.placementId}`);
    }


    validatePlacement(placement, player) {
       
        if(placement.isStartingState) return true;
        // Calculate cost of only NEW units
        const newUnitCost =  placement.unitType?.value;
        
        
        if (newUnitCost > player.stats.gold) {
            console.log(`Player ${player.id} insufficient gold: ${newUnitCost} > ${player.stats.gold}`);
            return false;
        }
        if (this.game.gameManager.has('canAffordSupply') && !this.game.gameManager.call('canAffordSupply', player.stats.side, placement.unitType)) {
            console.log(`Player ${player.id} insufficient supply for unit: ${placement.unitType.id}`);
            return false;
        }
        if (!placement.gridPosition || !placement.unitType) {
            console.log(`Player ${player.id} invalid placement data:`, placement);
            return false;
        }
        
        // Validate side placement - no mirroring, direct side enforcement
        const squadData = this.game.squadManager.getSquadData(placement.unitType);
        const cells = this.game.squadManager.getSquadCells(placement.gridPosition, squadData);
        if(!this.game.gameManager.call('isValidGridPlacement', cells, player.stats.side)){
            console.log('Invalid Placement', placement);
            for (const cell of cells) {
                const key = `${cell.x},${cell.z}`;
                const cellState = this.game.gridSystem.state.get(key);
                if (cellState && cellState.occupied) {
                    console.log('occupied:', cell, cellState);
                }
            }

            return false;
        }
    
        
        return true;
    }
    clearAllPlacements(){

        this.playerPlacements.keys().forEach((playerId) => {
            this.clearPlayerPlacements(playerId);
        });

        this.playerPlacements = new Map();
        this.leftPlacements = new Map();
        this.rightPlacements = new Map();
        this.placementReadyStates = new Map();  
    }
    clearPlayerPlacements(playerId) {
        try {
            // Get player's placements
            const placements = this.playerPlacements.get(playerId) || [];
            
            // Remove entities created by this player's placements
            placements.forEach(placement => {
                if (placement.squadUnits) {
                    placement.squadUnits.forEach(entityId => {
                        try {
                            if (this.game.destroyEntity) {
                                this.game.destroyEntity(entityId);
                            }
                        } catch (error) {
                            console.warn(`Error destroying entity ${entityId}:`, error);
                        }
                    });
                }

                // Free grid cells
                if (placement.placementId) {
                    this.game.gameManager.call('releaseGridCells', placement.placementId);
                }
            });
            
            // Clear from maps
            this.playerPlacements.delete(playerId);
            
            // Clear from undo stack if it's this player
            if (this.undoStack) {
                this.undoStack = this.undoStack.filter(undo => undo.playerId !== playerId);
            }
            
            console.log(`Cleared placements for player ${playerId}`);
            
        } catch (error) {
            console.error(`Error clearing placements for player ${playerId}:`, error);
        }
    }

    saveBuilding(entityId, team, gridPosition, unitType) {
        console.log(`=== Purchase Building DEBUG ===`);     
        console.log(`Data received:`, entityId, team, unitType);

        if (unitType.id === 'goldMine') {
            // Convert footprint (terrain grid units) to placement grid cells
            const footprintWidth = unitType.footprintWidth || unitType.placementGridWidth || 2;
            const footprintHeight = unitType.footprintHeight || unitType.placementGridHeight || 2;
            const gridWidth = footprintWidth * 2;
            const gridHeight = footprintHeight * 2;

            const result = this.game.gameManager.call('buildGoldMine', entityId, team, gridPosition, gridWidth, gridHeight);
            if (!result.success) {
                return result;
            }
        }            
        console.log(`SUCCESS`);
        console.log(`================================`);
        return { success: true };
    }

    purchaseUpgrade(playerId, player, data) {
        console.log(`=== Purchase Upgrade DEBUG ===`);       
        console.log(`Data received:`, data);
    
        if (this.game.state.phase !== 'placement') {
            return { success: false, error: `Not in placement phase (${this.game.state.phase})` };
        }

        const upgrade = this.game.getCollections().upgrades[data.upgradeId];
        if(upgrade?.value <= player.stats.gold){
            player.stats.gold -= upgrade.value;
            if(!this.game.state.teams){
                this.game.state.teams = {};
            }
            if(!this.game.state.teams[player.stats.side]) {
                this.game.state.teams[player.stats.side] = {};
            } 
            if(!this.game.state.teams[player.stats.side].effects) {
                this.game.state.teams[player.stats.side].effects = {};
            }
            upgrade.effects.forEach((effectId) => {
                const effect = this.game.getCollections().effects[effectId];
                this.game.state.teams[player.stats.side].effects[effectId] = effect;
            })
            
            console.log(`SUCCESS`);
            console.log(`================================`);
            return { success: true };
        }

        console.log(`ERROR`);    
        console.log(`================================`);
        
        return { success: false, error: "Not enough gold." };
    }

    getStartingPositionFromLevel(side) {
        // Try to get level data from game collections
        const level = this.game.getCollections().levels[this.game.state.level];
        if (!level || !level.tileMap || !level.tileMap.startingLocations) {
            return null;
        }
        
        // Find starting location for this side
        const startingLoc = level.tileMap.startingLocations.find(loc => loc.side === side);
        if (startingLoc && startingLoc.gridPosition) {
            return { x: startingLoc.gridPosition.x, z: startingLoc.gridPosition.z };
        }

        return null;
    }

    getStartingState(player){
        // Get starting position from level data if available
        let startPosition = this.getStartingPositionFromLevel(player.stats.side);

        // Find nearest unclaimed gold vein
        let nearestGoldVeinLocation = null;
        let minDistance = Infinity;

        const goldVeinLocations = this.game.gameManager.call('getGoldVeinLocations');
        if (goldVeinLocations) {
            goldVeinLocations.forEach(vein => {
                // Skip if already claimed
                if (vein.claimed) return;
                
                // Calculate distance from start position to vein
                const dx = vein.gridPos.x - startPosition.x;
                const dz = vein.gridPos.z - startPosition.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestGoldVeinLocation = vein.gridPos;
                }
            });
        }
        
        
        // Calculate peasant positions on the same side as gold mine
        // TownHall is 2x2, so it occupies a 2x2 area centered at startPosition
        const dx = nearestGoldVeinLocation.x - startPosition.x;
        const dz = nearestGoldVeinLocation.z - startPosition.z;
        
        let peasantPositions = [];
        
        // Determine which side the gold mine is on and place peasants accordingly
        if (Math.abs(dx) > Math.abs(dz)) {
            // Gold mine is more to the east or west
            if (dx > 0) {
                // Gold mine is to the EAST, place peasants on east side
                // TownHall occupies x to x+1, so peasants start at x+2
                peasantPositions = [
                    { x: startPosition.x + 2, z: startPosition.z - 1 },
                    { x: startPosition.x + 2, z: startPosition.z },
                    { x: startPosition.x + 2, z: startPosition.z + 1 },
                    { x: startPosition.x + 2, z: startPosition.z + 2 }
                ];
            } else {
                // Gold mine is to the WEST, place peasants on west side
                // TownHall occupies x-1 to x, so peasants start at x-2
                peasantPositions = [
                    { x: startPosition.x - 2, z: startPosition.z - 1 },
                    { x: startPosition.x - 2, z: startPosition.z },
                    { x: startPosition.x - 2, z: startPosition.z + 1 },
                    { x: startPosition.x - 2, z: startPosition.z + 2 }
                ];
            }
        } else {
            // Gold mine is more to the north or south
            if (dz > 0) {
                // Gold mine is to the SOUTH, place peasants on south side
                // TownHall occupies z to z+1, so peasants start at z+2
                peasantPositions = [
                    { x: startPosition.x - 1, z: startPosition.z + 2 },
                    { x: startPosition.x, z: startPosition.z + 2 },
                    { x: startPosition.x + 1, z: startPosition.z + 2 },
                    { x: startPosition.x + 2, z: startPosition.z + 2 }
                ];
            } else {
                // Gold mine is to the NORTH, place peasants on north side
                // TownHall occupies z-1 to z, so peasants start at z-2
                peasantPositions = [
                    { x: startPosition.x - 1, z: startPosition.z - 2 },
                    { x: startPosition.x, z: startPosition.z - 2 },
                    { x: startPosition.x + 1, z: startPosition.z - 2 },
                    { x: startPosition.x + 2, z: startPosition.z - 2 }
                ];
            }
        }
        
        const startingUnits = [
            {
                type: "townHall",
                collection: "buildings",
                position: startPosition
            },
            {
                type: "goldMine",
                collection: "buildings",
                position: nearestGoldVeinLocation
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[0]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[1]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[2]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[3]
            }
        ];

        const pitch = 35.264 * Math.PI / 180;
        const yaw = 135 * Math.PI / 180;
        const distance = 10240;

        const cdx = Math.sin(yaw) * Math.cos(pitch);
        const cdz = Math.cos(yaw) * Math.cos(pitch);



        const worldPos = this.game.gameManager.call('convertGridToWorldPosition', startPosition.x, startPosition.z);

        const cameraPosition = {
            x: worldPos.x - cdx * distance,
            y: distance,
            z: worldPos.z - cdz * distance
        };

        const lookAt = {
            x: worldPos.x,
            y: 0, 
            z: worldPos.z
        };

        return {
            success: true,
            startingUnits,
            camera: {
                position: cameraPosition,
                lookAt
            }
        };
    }
}
;

// system: LifetimeSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['LifetimeSystem'] = class LifetimeSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.lifetimeSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Configuration
        this.CHECK_INTERVAL = 0.1; // Check lifetimes every 100ms for performance
        this.lastCheck = 0;
        
        // Track entities with custom destruction callbacks
        this.destructionCallbacks = new Map(); // entityId -> callback function
        
        // Track entities that should fade out before destruction
        this.fadeOutEntities = new Map(); // entityId -> fade data
        
        // Statistics
        this.stats = {
            entitiesDestroyed: 0,
            entitiesExpired: 0,
            entitiesFaded: 0
        };
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('addLifetime', this.addLifetime.bind(this));
        this.game.gameManager.register('destroyEntityImmediately', this.destroyEntityImmediately.bind(this));
        this.game.gameManager.register('extendLifetime', this.extendLifetime.bind(this));
    }

    update() {        
        // Only check periodically for performance
        if (this.game.state.now - this.lastCheck < this.CHECK_INTERVAL) return;
        this.lastCheck = this.game.state.now;
        
        // Get all entities with lifetime components
        const lifetimeEntities = this.game.getEntitiesWith(this.componentTypes.LIFETIME);
        
        lifetimeEntities.forEach(entityId => {
            const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
            if (!lifetime) return;
            
            const age = (this.game.state.now - lifetime.startTime);
            
            // Check if entity has expired
            if (age >= lifetime.duration) {
                this.handleExpiredEntity(entityId, lifetime);
            } 
        });
    }
    
    // =============================================
    // ENTITY EXPIRATION HANDLING
    // =============================================
    
    handleExpiredEntity(entityId, lifetime) {
        // Call custom destruction callback if registered
        const callback = this.destructionCallbacks.get(entityId);
        if (callback) {
            try {
                callback(entityId, lifetime);
            } catch (error) {
                console.warn(`Lifetime destruction callback error for entity ${entityId}:`, error);
            }
            this.destructionCallbacks.delete(entityId);
        }
        
        // Special handling for different entity types
        this.handleSpecialEntityTypes(entityId, lifetime);
        
        // Create destruction effects if specified
        this.createDestructionEffects(entityId, lifetime);
        
        // Log destruction if enabled
        this.logEntityDestruction(entityId, lifetime);
        
        // Remove from fade tracking
        this.fadeOutEntities.delete(entityId);
        
        // Destroy the entity
        this.game.destroyEntity(entityId);
        
        // Update statistics
        this.stats.entitiesDestroyed++;
        this.stats.entitiesExpired++;
    }
    
    handleSpecialEntityTypes(entityId, lifetime) {
        // Handle projectiles
        if (this.game.hasComponent(entityId, this.componentTypes.PROJECTILE)) {
            // Clean up projectile-specific data 
            this.game.gameManager.call('deleteProjectileTrail', entityId);
            
        }
        
        // Handle summons
        if (this.game.hasComponent(entityId, this.componentTypes.SUMMONED)) {
            this.handleSummonExpiration(entityId);
        }
        
        // Handle mirror images
        if (this.game.hasComponent(entityId, this.componentTypes.MIRROR_IMAGE)) {
            this.handleMirrorImageExpiration(entityId);
        }
        
        // Handle traps
        if (this.game.hasComponent(entityId, this.componentTypes.TRAP)) {
            this.handleTrapExpiration(entityId);
        }
        
        // Handle temporary effects
        if (this.game.hasComponent(entityId, this.componentTypes.TEMPORARY_EFFECT)) {
            this.handleTemporaryEffectExpiration(entityId);
        }
        
        // Handle mind controlled entities
        if (this.game.hasComponent(entityId, this.componentTypes.MIND_CONTROLLED)) {
            this.handleMindControlExpiration(entityId);
        }
        
        // Handle thorns effect
        if (this.game.thornsEntities && this.game.thornsEntities.has(entityId)) {
            this.game.thornsEntities.delete(entityId);
        }
    }
    
    handleSummonExpiration(entityId) {
        const summonPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (summonPos) {
            // Create disappearing effect
            this.game.gameManager.call('createParticleEffect',
                summonPos.x, summonPos.y, summonPos.z,
                'magic',
                { count: 3, color: 0x9370DB, scaleMultiplier: 1.5 }
            );
        }

    }
    
    handleMirrorImageExpiration(entityId) {
        const imagePos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (imagePos) {
            // Create shimmering dissolution effect
            this.game.gameManager.call('createParticleEffect',
                imagePos.x, imagePos.y, imagePos.z,
                'magic',
                { count: 3, color: 0x6495ED, scaleMultiplier: 1.2 }
            );
        }
    }
    
    handleTrapExpiration(entityId) {
        const trapPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (trapPos) {
            // Create fizzling effect for expired trap
            this.game.gameManager.call('createParticleEffect',
                trapPos.x, trapPos.y, trapPos.z,
                'magic',
                { count: 3, color: 0x696969, scaleMultiplier: 0.8 }
            );
        }


    }
    
    handleTemporaryEffectExpiration(entityId) {
        // For visual effect entities, just let them fade naturally
        const effectPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (effectPos) {
            this.game.gameManager.call('createParticleEffect',
                effectPos.x, effectPos.y, effectPos.z,
                'magic',
                { count: 3, color: 0xFFFFFF, scaleMultiplier: 0.5 }
            );
        }
    }
    
    handleMindControlExpiration(entityId) {
        const mindControl = this.game.getComponent(entityId, this.componentTypes.MIND_CONTROLLED);
        const targetTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        
        if (mindControl && targetTeam) {
            // Restore original team
            targetTeam.team = mindControl.originalTeam;
            
            // Clear AI target
            const targetAI = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
            if (targetAI && targetAI.aiBehavior) {
                targetAI.target = null;
                targetAI.targetPosition = null;
                targetAI.path = [];
                targetAI.meta = {};
            }
            
            // Visual effect
            if (targetPos) {
                this.game.gameManager.call('createParticleEffect',
                    targetPos.x, targetPos.y, targetPos.z,
                    'magic',
                    { count: 3, color: 0xDA70D6, scaleMultiplier: 1.0 }
                );
            }
            
            // Remove mind control component
            this.game.removeComponent(entityId, this.componentTypes.MIND_CONTROLLED);
            
          
        }
    }

    
    // =============================================
    // DESTRUCTION EFFECTS
    // =============================================
    
    createDestructionEffects(entityId, lifetime) {
        if (!lifetime.destructionEffect) return;

        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (!pos) return;

        const effectConfig = lifetime.destructionEffect;

        // Create particle effect
        this.game.gameManager.call('createParticleEffect',
            pos.x, pos.y, pos.z,
            effectConfig.type || 'magic',
            {
                count: effectConfig.count || 3,
                color: effectConfig.color || 0xFFFFFF,
                scaleMultiplier: effectConfig.scaleMultiplier || 1.0,
                speedMultiplier: effectConfig.speedMultiplier || 1.0
            }
        );

        // Screen effects if specified
        if (effectConfig.screenShake) {
            this.game.gameManager.call('playScreenShake',
                effectConfig.screenShake.duration || 0.2,
                effectConfig.screenShake.intensity || 1
            );
        }

        if (effectConfig.screenFlash) {
            this.game.gameManager.call('playScreenFlash',
                effectConfig.screenFlash.color || '#FFFFFF',
                effectConfig.screenFlash.duration || 0.2
            );
        }
    }
    
    // =============================================
    // PUBLIC API METHODS
    // =============================================
    
    /**
     * Add a lifetime component to an entity
     * @param {number} entityId - Entity to add lifetime to
     * @param {number} duration - Duration in seconds
     * @param {Object} options - Additional options
     */
    addLifetime(entityId, duration, options = {}) {
        
        const lifetimeData = {
            duration: duration,
            startTime: this.game.state.now,
            fadeOutDuration: options.fadeOutDuration || 0,
            destructionEffect: options.destructionEffect || null,
            onDestroy: options.onDestroy || null
        };
        
        this.game.addComponent(entityId, this.componentTypes.LIFETIME, lifetimeData);
        
        // Register destruction callback if provided
        if (options.onDestroy && typeof options.onDestroy === 'function') {
            this.destructionCallbacks.set(entityId, options.onDestroy);
        }
        
        return entityId;
    }
    
    /**
     * Extend the lifetime of an entity
     * @param {number} entityId - Entity to extend
     * @param {number} additionalDuration - Additional time in seconds
     */
    extendLifetime(entityId, additionalDuration) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            lifetime.duration += additionalDuration;
            return true;
        }
        return false;
    }
    
    /**
     * Reduce the lifetime of an entity
     * @param {number} entityId - Entity to reduce
     * @param {number} reductionAmount - Time to reduce in seconds
     */
    reduceLifetime(entityId, reductionAmount) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            lifetime.duration = Math.max(0, lifetime.duration - reductionAmount);
            return true;
        }
        return false;
    }
    
    /**
     * Get remaining lifetime of an entity
     * @param {number} entityId - Entity to check
     * @returns {number} Remaining time in seconds, or -1 if no lifetime component
     */
    getRemainingLifetime(entityId) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            const age = (this.game.state.now - lifetime.startTime);
            return Math.max(0, (lifetime.duration) - age);
        }
        return -1;
    }
    
    /**
     * Check if an entity will expire soon
     * @param {number} entityId - Entity to check
     * @param {number} threshold - Time threshold in seconds
     * @returns {boolean} True if entity will expire within threshold
     */
    willExpireSoon(entityId, threshold = 5.0) {
        const remaining = this.getRemainingLifetime(entityId);
        return remaining >= 0 && remaining <= threshold;
    }
    
    /**
     * Remove lifetime component from an entity (makes it permanent)
     * @param {number} entityId - Entity to make permanent
     */
    makeEntityPermanent(entityId) {
        if (this.game.hasComponent(entityId, this.componentTypes.LIFETIME)) {
            this.game.removeComponent(entityId, this.componentTypes.LIFETIME);
            this.destructionCallbacks.delete(entityId);
            this.fadeOutEntities.delete(entityId);
            return true;
        }
        return false;
    }
    
    /**
     * Force immediate destruction of an entity with lifetime
     * @param {number} entityId - Entity to destroy
     * @param {boolean} triggerEffects - Whether to trigger destruction effects
     */
    destroyEntityImmediately(entityId, triggerEffects = true) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            if (triggerEffects) {
                this.handleExpiredEntity(entityId, lifetime);
            } else {
                this.destructionCallbacks.delete(entityId);
                this.fadeOutEntities.delete(entityId);
                this.game.destroyEntity(entityId);
                this.stats.entitiesDestroyed++;
            }
            return true;
        }
        return false;
    }
    
    /**
     * Register a custom destruction callback for an entity
     * @param {number} entityId - Entity to register callback for
     * @param {Function} callback - Function to call on destruction
     */
    registerDestructionCallback(entityId, callback) {
        if (typeof callback === 'function') {
            this.destructionCallbacks.set(entityId, callback);
        }
    }
    
    /**
     * Get all entities with lifetime components
     * @returns {Array} Array of entity IDs
     */
    getAllLifetimeEntities() {
        return this.game.getEntitiesWith(this.componentTypes.LIFETIME);
    }
    
    /**
     * Get entities that will expire within a time threshold
     * @param {number} threshold - Time threshold in seconds
     * @returns {Array} Array of entity IDs
     */
    getExpiringEntities(threshold = 5.0) {
        const expiringEntities = [];
        
        const lifetimeEntities = this.getAllLifetimeEntities();
        
        lifetimeEntities.forEach(entityId => {
            const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
            if (lifetime) {
                const age = (this.game.state.now - lifetime.startTime);
                const remaining = lifetime.duration - age;
                
                if (remaining <= threshold && remaining > 0) {
                    expiringEntities.push(entityId);
                }
            }
        });
        
        return expiringEntities;
    }
    
    // =============================================
    // LOGGING AND STATISTICS
    // =============================================
    
    logEntityDestruction(entityId, lifetime) {
       
    }
    
    getStatistics() {
        return { ...this.stats };
    }
    
    resetStatistics() {
        this.stats.entitiesDestroyed = 0;
        this.stats.entitiesExpired = 0;
        this.stats.entitiesFaded = 0;
    }
    
    // =============================================
    // SYSTEM MANAGEMENT
    // =============================================
    
    destroy() {
        // Clean up all tracking maps
        this.destructionCallbacks.clear();
        this.fadeOutEntities.clear();
        this.resetStatistics();
    }
};

// system: GridSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['GridSystem'] = class GridSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.gridSystem = this;
        
        this.state = new Map();

        // NEW: track which half each team owns
        this.teamSides = { player: 'left', enemy: 'right' };
        this.leftBounds = null;
        this.rightBounds = null;
    }
    
    init() {
        this.game.gameManager.register('getNearbyUnits', this.getNearbyUnits.bind(this));
        this.game.gameManager.register('convertGridToWorldPosition', this.gridToWorld.bind(this));
        this.game.gameManager.register('convertWorldToGridPosition', this.worldToGrid.bind(this));
        this.game.gameManager.register('isValidGridPlacement', this.isValidGridPlacement.bind(this));
        this.game.gameManager.register('reserveGridCells', this.occupyCells.bind(this));
        this.game.gameManager.register('releaseGridCells', this.freeCells.bind(this));
        this.game.gameManager.register('getUnitGridCells', this.getUnitCells.bind(this));

        const collections = this.game.getCollections();

        const terrainGridSize = collections.configs.game.gridSize;
        const placementGridSize = terrainGridSize / 2; // Placement grid is always half the terrain grid
        const currentLevel = collections.configs.state.level;
        const terrainSize = collections.levels[currentLevel]?.tileMap?.size * terrainGridSize;

        this.cellSize = placementGridSize;
        this.terrainGridSize = terrainGridSize;
        this.showGrid = true;
        this.snapToGrid = true;
        this.highlightValidCells = true;
        
        this.dimensions = {
            width: Math.floor(terrainSize / placementGridSize),
            height: Math.floor(terrainSize / placementGridSize),
            cellSize: placementGridSize,
            startX: -terrainSize / 2,
            startZ: -terrainSize / 2
        };
        console.log("dimensions", this.dimensions);
        
        this.gridVisualization = null;

        // Compute half-splits once
        const half = Math.floor(this.dimensions.width / 2);
        this.leftBounds = {
            minX: 0,
            maxX: half - 1,
            minZ: 0,
            maxZ: this.dimensions.height - 1
        };
        this.rightBounds = {
            minX: half,
            maxX: this.dimensions.width - 1,
            minZ: 0,
            maxZ: this.dimensions.height - 1
        };

        // Default: player=left, enemy=right (can be swapped later)
        this.playerBounds = this.leftBounds;
        this.enemyBounds  = this.rightBounds;
        
        // Pre-calculate world bounds for faster collision detection
        this.worldBounds = {
            minX: this.dimensions.startX,
            maxX: this.dimensions.startX + (this.dimensions.width * placementGridSize),
            minZ: this.dimensions.startZ,
            maxZ: this.dimensions.startZ + (this.dimensions.height * placementGridSize)
        };
    }

    // NEW: set which half each team owns (call this when you learn sides from the server)
    setTeamSides(sides) {
        if (sides?.player === 'left' || sides?.player === 'right') {
            this.teamSides.player = sides.player;
        }
        if (sides?.enemy === 'left' || sides?.enemy === 'right') {
            this.teamSides.enemy = sides.enemy;
        }

        // Point player/enemy bounds at the correct half
        this.playerBounds = (this.teamSides.player === 'left') ? this.leftBounds : this.rightBounds;
        this.enemyBounds  = (this.teamSides.enemy  === 'left') ? this.leftBounds : this.rightBounds;

    }
    
    createVisualization(scene) {
        if (this.gridVisualization) {
            scene.remove(this.gridVisualization);
        }
        
        const group = new THREE.Group();
        const { width, height, cellSize, startX, startZ } = this.dimensions;
        
        // Use BufferGeometry for better performance
        const linePositions = [];
        
        // Vertical lines
        for (let x = 0; x <= width; x++) {
            const worldX = startX + (x * cellSize);
            linePositions.push(
                worldX, 1, startZ,
                worldX, 1, startZ + (height * cellSize)
            );
        }
        
        // Horizontal lines
        for (let z = 0; z <= height; z++) {
            const worldZ = startZ + (z * cellSize);
            linePositions.push(
                startX, 1, worldZ,
                startX + (width * cellSize), 1, worldZ
            );
        }
        
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
        
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x444444, 
            transparent: true, 
            opacity: 0.3 
        });
        
        const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
        group.add(lines);
        
        // Center divider line
        const dividerPositions = [
            startX + (width * cellSize / 2), 2, startZ,
            startX + (width * cellSize / 2), 2, startZ + (height * cellSize)
        ];
        
        const dividerGeometry = new THREE.BufferGeometry();
        dividerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dividerPositions, 3));
        
        const dividerMaterial = new THREE.LineBasicMaterial({ 
            color: 0xff0000, 
            transparent: true, 
            opacity: 0.5 
        });
        
        const dividerLine = new THREE.LineSegments(dividerGeometry, dividerMaterial);
        group.add(dividerLine);
        
        this.gridVisualization = group;
        scene.add(this.gridVisualization);
    }
    
    worldToGrid(worldX, worldZ) {
        const { cellSize, startX, startZ } = this.dimensions;
        return {
            x: Math.floor((worldX - startX) / cellSize),
            z: Math.floor((worldZ - startZ) / cellSize)
        };
    }
    
    gridToWorld(gridX, gridZ) {
        const { cellSize, startX, startZ } = this.dimensions;
        return {
            x: startX + (gridX * cellSize),
            z: startZ + (gridZ * cellSize)
        };
    }
    
    // OPTIMIZED: Early bounds checking
    isValidPosition(gridPos) {
        return gridPos.x >= 0 && gridPos.x < this.dimensions.width &&
               gridPos.z >= 0 && gridPos.z < this.dimensions.height;
    }

    isValidGridPlacement(cells, team) {
        if (!cells || cells.length === 0) return false;
        
        for (const cell of cells) {
            const key = `${cell.x},${cell.z}`;
            const cellState = this.state.get(key);
            if (cellState && cellState.occupied) {
                return false;
            }
        }

        
        return true;
    }

    getUnitCells(entityId) {

        const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);
        const pos = this.game.getComponent(entityId, this.game.componentTypes.POSITION);

        if(!unitType) return null;
        const cells = [];

        // For buildings, convert footprint (terrain grid units) to placement grid cells
        // For units, use placementGridWidth/Height directly (already in placement grid units)
        let placementGridWidth, placementGridHeight;

        if (unitType.collection === 'buildings') {
            // Buildings use footprint in terrain grid units, convert to placement grid cells (2x)
            const footprintWidth = unitType.footprintWidth || unitType.placementGridWidth || 1;
            const footprintHeight = unitType.footprintHeight || unitType.placementGridHeight || 1;
            placementGridWidth = footprintWidth * 2;
            placementGridHeight = footprintHeight * 2;
        } else {
            // Units use placement grid units directly
            placementGridWidth = unitType.placementGridWidth || 1;
            placementGridHeight = unitType.placementGridHeight || 1;
        }

        const gridPos = this.worldToGrid(pos.x, pos.z);
        // Calculate starting position to center the formation
        const startX = gridPos.x - Math.floor(placementGridWidth / 2);
        const startZ = gridPos.z - Math.floor(placementGridHeight / 2);
        for (let x = 0; x < placementGridWidth; x++) {
            for (let z = 0; z < placementGridHeight; z++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }

        return cells;
    }

    getNearbyUnits(pos, radius, excludeEntityId = null, collection = null) {
        const gridPos = this.worldToGrid(pos.x, pos.z);
        const cellRadius = Math.ceil(radius / this.cellSize);
        
        const nearbyUnits = [];
        const radiusSq = radius * radius;
        const seen = new Set(); // Prevent duplicates

        for (let gz = gridPos.z - cellRadius; gz <= gridPos.z + cellRadius; gz++) {
            for (let gx = gridPos.x - cellRadius; gx <= gridPos.x + cellRadius; gx++) {
                if (!this.isValidPosition({ x: gx, z: gz })) continue;
                
                const cellState = this.getCellState(gx, gz);
                if (!cellState?.entities?.length) continue;

                for (const entityId of cellState.entities) {
                    if (entityId === excludeEntityId || seen.has(entityId)) continue;

                    const entityPos = this.game.getComponent(entityId, this.game.componentTypes.POSITION);
                    const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);
                    
                    if (!entityPos || !unitType) continue;

                    const dx = entityPos.x - pos.x;
                    const dz = entityPos.z - pos.z;
                    const distSq = dx * dx + dz * dz;
                    
                    if(collection && unitType.collection != collection) continue;

                    if (distSq <= radiusSq) {
                        seen.add(entityId);
                        nearbyUnits.push({
                            x: entityPos.x,
                            z: entityPos.z,
                            y: entityPos.y,
                            id: entityId,
                            ...unitType
                        });
                    }
                }
            }
        }
        return nearbyUnits.sort((a, b) => a.id.localeCompare(b.id));
    }

    onEntityPositionUpdated(entityId) {
        const cells = this.getUnitCells(entityId);
        this.freeCells(entityId);
        this.occupyCells(cells, entityId);
    }

    occupyCells(cells, entityId) {       
        for (const cell of cells) {
            const key = `${cell.x},${cell.z}`;
            let cellState = this.state.get(key);

            if (!cellState) {
                cellState = { occupied: true, entities: [] };
                this.state.set(key, cellState);
            }

            // Add entity if not already present
            if (!cellState.entities.includes(entityId)) {
                cellState.entities.push(entityId);
            }
            cellState.entities.sort((a, b) => a.localeCompare(b));     
        }           
    }
        
    freeCells(entityId) {
        for (const [key, cellState] of this.state.entries()) {
            if (cellState.entities.includes(entityId)) {
                cellState.entities = cellState.entities.filter(id => id !== entityId);
                
                // Clean up empty cell
                if (cellState.entities.length === 0) {
                    this.state.delete(key);
                } else {                    
                    cellState.entities.sort((a, b) => a.localeCompare(b));
                }
            }
        }
    }

    clear() {
        console.log('grid system cleared');
        this.state.clear();
    }
    
    toggleVisibility(scene) {
        this.showGrid = !this.showGrid;
        
        if (this.showGrid) {
            this.createVisualization(scene);
        } else if (this.gridVisualization) {
            scene.remove(this.gridVisualization);
            this.gridVisualization = null;
        }
    }
    
    getBounds(team) {
        // Keep API compatibility; these references are updated by setTeamSides()
        return team === 'right' ? this.rightBounds : this.leftBounds;
    }
        
    getCellState(gridX, gridZ) {
        return this.state.get(`${gridX},${gridZ}`);
    }

    getOccupiedCells() {
        return Array.from(this.state.entries()).map(([key, value]) => {
            const [x, z] = key.split(',').map(Number);
            return { x, z, ...value };
        });
    }
    
    getGridInfo() {
        return {
            dimensions: this.dimensions,
            leftBounds: this.leftBounds,
            rightBounds: this.rightBounds,
            teamSides: { ...this.teamSides },
            occupiedCells: this.getOccupiedCells(),
            totalCells: this.dimensions.width * this.dimensions.height,
            occupiedCount: this.state.size
        };
    }
    
    // OPTIMIZED: Batch cell queries for better performance
    areCellsOccupied(cells) {
        for (const cell of cells) {
            const key = `${cell.x},${cell.z}`;
            if (this.state.has(key)) {
                return true;
            }
        }
        return false;
    }

    onDestroyBuilding(entityId){ 
        this.freeCells(entityId);
    }

    onUnitKilled(entityId){  
        this.freeCells(entityId);
    }

    
    // OPTIMIZED: Fast world bounds check
    isInWorldBounds(worldX, worldZ) {
        return worldX >= this.worldBounds.minX && worldX <= this.worldBounds.maxX &&
               worldZ >= this.worldBounds.minZ && worldZ <= this.worldBounds.maxZ;
    }
};

// system: SchedulingSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SchedulingSystem'] = class SchedulingSystem extends engine.BaseSystem {
   constructor(game) {
        super(game);
        this.game.schedulingSystem = this;
        
        // Scheduled actions storage
        this.scheduledActions = new Map();
        this.actionIdCounter = 0;
        
        // Entity tracking for cleanup
        this.entityActions = new Map(); // entityId -> Set of actionIds
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('scheduleAction', this.scheduleAction.bind(this));
        this.game.gameManager.register('cancelScheduledAction', this.cancelAction.bind(this));
    }

    update() {
        this.processScheduledActions();
    }
    
    /**
     * Schedule an action to execute after a delay
     * @param {Function} callback - Function to execute
     * @param {number} delaySeconds - Delay in seconds (game time)
     * @param {string|null} entityId - Optional entity ID for tracking/cleanup
     * @returns {string} actionId - Unique identifier for this action
     */
    scheduleAction(callback, delaySeconds, entityId = null) {
        const executeTime = this.game.state.now + delaySeconds;
        const actionId = `action_${this.actionIdCounter++}_${executeTime.toFixed(6)}`;
        
        this.scheduledActions.set(actionId, {
            callback: callback,
            executeTime: executeTime,
            entityId: entityId
        });
        
        // Track entity associations for cleanup
        if (entityId) {
            if (!this.entityActions.has(entityId)) {
                this.entityActions.set(entityId, new Set());
            }
            this.entityActions.get(entityId).add(actionId);
        }
        
        return actionId;
    }
    
    /**
     * Process all scheduled actions that are ready to execute
     */
    processScheduledActions() {
        const actionsToExecute = [];
        
        // Find all actions ready to execute
        for (const [actionId, action] of this.scheduledActions.entries()) {
            if (this.game.state.now >= action.executeTime) {
                actionsToExecute.push({ id: actionId, action: action });
            }
        }
        
        // Sort actions for deterministic execution order
        actionsToExecute.sort((a, b) => {
            // Primary sort: by execution time
            if (Math.abs(a.action.executeTime - b.action.executeTime) > 0.000001) {
                return a.action.executeTime - b.action.executeTime;
            }
            // Secondary sort: by action ID for deterministic tie-breaking
            return a.id.localeCompare(b.id);
        });
        
        // Execute actions in deterministic order
        actionsToExecute.forEach(({ id, action }) => {
            try {
                action.callback();
            } catch (error) {
                console.error(`Error executing scheduled action ${id}:`, error);
            }
            
            // Clean up
            this.removeAction(id, action.entityId);
        });
    }
    
    /**
     * Cancel a scheduled action
     * @param {string} actionId - Action to cancel
     * @returns {boolean} - True if action was found and cancelled
     */
    cancelAction(actionId) {
        const action = this.scheduledActions.get(actionId);
        if (action) {
            this.removeAction(actionId, action.entityId);
            return true;
        }
        return false;
    }
    
    /**
     * Cancel all actions associated with an entity
     * @param {string} entityId - Entity whose actions should be cancelled
     * @returns {number} - Number of actions cancelled
     */
    entityDestroyed(entityId) {
        const entityActionIds = this.entityActions.get(entityId);
        if (!entityActionIds) return 0;
        
        let cancelledCount = 0;
        for (const actionId of entityActionIds) {
            if (this.scheduledActions.has(actionId)) {
                this.scheduledActions.delete(actionId);
                cancelledCount++;
            }
        }
        
        this.entityActions.delete(entityId);
        return cancelledCount;
    }
    
    /**
     * Internal method to remove action and clean up tracking
     * @param {string} actionId 
     * @param {string|null} entityId 
     */
    removeAction(actionId, entityId) {
        this.scheduledActions.delete(actionId);
        
        if (entityId && this.entityActions.has(entityId)) {
            this.entityActions.get(entityId).delete(actionId);
            
            // Clean up empty entity tracking
            if (this.entityActions.get(entityId).size === 0) {
                this.entityActions.delete(entityId);
            }
        }
    }
    
    /**
     * Get info about scheduled actions (for debugging)
     * @returns {Object} - Statistics about scheduled actions
     */
    getSchedulingStats() {
        return {
            totalActions: this.scheduledActions.size,
            entitiesWithActions: this.entityActions.size,
            nextActionTime: this.getNextActionTime()
        };
    }
    
    /**
     * Get the time of the next scheduled action
     * @returns {number|null} - Time of next action, or null if none scheduled
     */
    getNextActionTime() {
        let nextTime = null;
        for (const action of this.scheduledActions.values()) {
            if (nextTime === null || action.executeTime < nextTime) {
                nextTime = action.executeTime;
            }
        }
        return nextTime;
    }
    
    /**
     * Check if an entity has scheduled actions
     * @param {string} entityId 
     * @returns {boolean}
     */
    hasEntityActions(entityId) {
        const entityActionIds = this.entityActions.get(entityId);
        return entityActionIds && entityActionIds.size > 0;
    }
    
    /**
     * Clear all scheduled actions (useful for game reset)
     */
    clearAllActions() {
        this.scheduledActions.clear();
        this.entityActions.clear();
    }
    
    /**
     * Convenience method: Schedule a delayed function call
     * @param {Object} obj - Object to call method on
     * @param {string} methodName - Method name to call
     * @param {Array} args - Arguments to pass
     * @param {number} delaySeconds - Delay in seconds
     * @param {string|null} entityId - Optional entity ID
     * @returns {string} actionId
     */
    scheduleMethodCall(obj, methodName, args = [], delaySeconds, entityId = null) {
        return this.scheduleAction(() => {
            if (obj && typeof obj[methodName] === 'function') {
                obj[methodName](...args);
            }
        }, delaySeconds, entityId);
    }
}
;

// system: PathfindingSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['PathfindingSystem'] = class PathfindingSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.pathfindingSystem = this;

        this.navMesh = null;
        this.navGridSize = null; // Will be set from config
        this.navGridWidth = 0;
        this.navGridHeight = 0;
        
        this.terrainTypes = null;
        this.walkabilityCache = new Map();
        this.ramps = new Set(); // Stores ramp locations in "x,z" format (terrain grid coords)

        this.pathCache = new Map();
        this.MAX_CACHE_SIZE = 1000;
        this.CACHE_EXPIRY_TIME = 5000;

        this.pathRequests = [];
        this.MAX_PATHS_PER_FRAME = 100;

        // Path smoothing configuration
        // Lower values = less aggressive smoothing = less corner cutting
        // Higher values = more aggressive smoothing = smoother but riskier paths
        this.MAX_SMOOTH_LOOKAHEAD = 3; // Maximum waypoints to look ahead when smoothing
        
        this.initialized = false;
    }

    init() {
        if (this.initialized) return;

        this.game.gameManager.register('isPositionWalkable', this.isPositionWalkable.bind(this));
        this.game.gameManager.register('isGridPositionWalkable', this.isGridPositionWalkable.bind(this));
        this.game.gameManager.register('requestPath', this.requestPath.bind(this));  
        this.game.gameManager.register('hasRampAt', this.hasRampAt.bind(this));  
        this.game.gameManager.register('hasDirectWalkablePath', this.hasDirectWalkablePath.bind(this)); // ADD THIS


        const collections = this.game.getCollections();
        if (!collections) {
            console.warn('PathfindingSystem: Collections not available');
            return;
        }
        
        const level = collections.levels?.[this.game.state.level];
        if (!level || !level.tileMap) {
            console.warn('PathfindingSystem: Level or tileMap not available');
            return;
        }
        
        if (!this.game.terrainSystem || !this.game.terrainSystem.initialized) {
            console.warn('PathfindingSystem: Waiting for terrain system...');
            return;
        }
        
        this.terrainTypes = level.tileMap.terrainTypes;
        if (!this.terrainTypes) {
            console.warn('PathfindingSystem: No terrain types found in level');
            return;
        }

        // Set navigation grid size to half of terrain grid (matches placement grid)
        this.navGridSize = collections.configs.game.gridSize / 2;
        console.log('PathfindingSystem: Using nav grid size', this.navGridSize);

        // Load ramps data
        this.loadRamps(level.tileMap);

        this.buildWalkabilityCache();
        this.bakeNavMesh();
        this.initialized = true;
        console.log('PathfindingSystem: Initialized with', this.terrainTypes.length, 'terrain types');
    }

    loadRamps(tileMap) {
        this.ramps.clear();

        const ramps = tileMap.ramps || [];
        for (const ramp of ramps) {
            const key = `${ramp.x},${ramp.z}`;
            this.ramps.add(key);
        }

        console.log(`PathfindingSystem: Loaded ${ramps.length} ramps`);
    }

    buildWalkabilityCache() {
        // This cache is now deprecated in favor of height-based walkability
        // Kept for backwards compatibility with old level data
        this.walkabilityCache.clear();

        for (let i = 0; i < this.terrainTypes.length; i++) {
            const terrainType = this.terrainTypes[i];
            const walkableNeighbors = terrainType.walkableNeighbors || [];

            for (let j = 0; j < this.terrainTypes.length; j++) {
                const targetType = this.terrainTypes[j].type;
                const canWalk = walkableNeighbors.includes(targetType);

                const key = `${i}-${j}`;
                this.walkabilityCache.set(key, canWalk);
            }
        }
    }

    canWalkBetweenTerrains(fromTerrainIndex, toTerrainIndex) {
        // NEW: Use height-based walkability if heightMap is available
        if (this.game.terrainSystem?.tileMap?.heightMap && this.game.terrainSystem.tileMap.heightMap.length > 0) {
            // Always walkable between same terrain types
            return true;
        }

        // OLD: Fall back to walkableNeighbors cache for backwards compatibility
        const key = `${fromTerrainIndex}-${toTerrainIndex}`;
        return this.walkabilityCache.get(key) === true;
    }

    // Convert nav grid coordinates to terrain grid coordinates
    navGridToTerrainGrid(navGridX, navGridZ) {
        const worldPos = this.navGridToWorld(navGridX, navGridZ);
        const gridSize = this.game.getCollections().configs.game.gridSize;
        const terrainSize = this.game.gameManager.call('getTerrainSize');

        const terrainX = Math.floor((worldPos.x + terrainSize / 2) / gridSize);
        const terrainZ = Math.floor((worldPos.z + terrainSize / 2) / gridSize);

        return { x: terrainX, z: terrainZ };
    }

    // Check if there's a ramp at the given nav grid position
    hasRampAtNav(navGridX, navGridZ) {
        const terrainGrid = this.navGridToTerrainGrid(navGridX, navGridZ);
        const key = `${terrainGrid.x},${terrainGrid.z}`;
        return this.ramps.has(key);
    }
    
    hasRampAt(gridX, gridZ) {
        return this.ramps.has(`${gridX},${gridZ}`);
    }

    // Get height level at nav grid position
    getHeightLevelAtNavGrid(navGridX, navGridZ) {
        const terrainGrid = this.navGridToTerrainGrid(navGridX, navGridZ);
        return this.game.terrainSystem?.getHeightLevelAtGridPosition(terrainGrid.x, terrainGrid.z) || 0;
    }

    // Check if movement between terrains is allowed (either through height + ramps or walkableNeighbors)
    canWalkBetweenTerrainsWithRamps(fromTerrainIndex, toTerrainIndex, fromNavGridX, fromNavGridZ, toNavGridX, toNavGridZ) {
        // NEW: Use height-based walkability if heightMap is available
        if (this.game.terrainSystem?.tileMap?.heightMap && this.game.terrainSystem.tileMap.heightMap.length > 0) {
            const fromHeight = this.getHeightLevelAtNavGrid(fromNavGridX, fromNavGridZ);
            const toHeight = this.getHeightLevelAtNavGrid(toNavGridX, toNavGridZ);

            // Same height level = always walkable
            if (fromHeight === toHeight) {
                return true;
            }

            // Different heights = only walkable with a ramp
            // Ramps allow movement between any adjacent height levels
            if (this.hasRampAtNav(fromNavGridX, fromNavGridZ) || this.hasRampAtNav(toNavGridX, toNavGridZ)) {
                return true;
            }

            return false;
        }

        // OLD: Use walkableNeighbors logic for backwards compatibility
        // First check normal walkability
        if (this.canWalkBetweenTerrains(fromTerrainIndex, toTerrainIndex)) {
            return true;
        }

        // If not normally walkable, check if there's a ramp at either position
        // Ramps allow movement between any terrain heights
        if (this.hasRampAtNav(fromNavGridX, fromNavGridZ) || this.hasRampAtNav(toNavGridX, toNavGridZ)) {
            return true;
        }

        return false;
    }

    bakeNavMesh() {
        const terrainSize = this.game.gameManager.call('getTerrainSize');
        
        this.navGridWidth = Math.ceil(terrainSize / this.navGridSize);
        this.navGridHeight = Math.ceil(terrainSize / this.navGridSize);
        
        this.navMesh = new Uint8Array(this.navGridWidth * this.navGridHeight);
        
        const halfTerrain = terrainSize / 2;
        
        // First pass: populate the navmesh with terrain types
        for (let z = 0; z < this.navGridHeight; z++) {
            for (let x = 0; x < this.navGridWidth; x++) {
                const worldX = (x * this.navGridSize) - halfTerrain + this.navGridSize / 2;
                const worldZ = (z * this.navGridSize) - halfTerrain + this.navGridSize / 2;
                
                const terrainType = this.game.gameManager.call('getTerrainTypeAtPosition', worldX, worldZ);
                
                const idx = z * this.navGridWidth + x;
                this.navMesh[idx] = terrainType !== null ? terrainType : 0;
            }
        }
        
        // Second pass: mark cells adjacent to impassable terrain as impassable
        // Create a copy to read from while we modify
        const originalNavMesh = new Uint8Array(this.navMesh);
        
        // for (let z = 0; z < this.navGridHeight; z++) {
        //     for (let x = 0; x < this.navGridWidth; x++) {
        //         const idx = z * this.navGridWidth + x;
        //         const currentTerrain = originalNavMesh[idx];
                
        //         // Check if this cell is walkable
        //         if (this.isTerrainWalkable(currentTerrain)) {
        //             // Check all 8 neighbors
        //             const neighbors = [
        //                 {dx: 1, dz: 0}, {dx: -1, dz: 0}, 
        //                 {dx: 0, dz: 1}, {dx: 0, dz: -1},
        //                 {dx: 1, dz: 1}, {dx: -1, dz: 1}, 
        //                 {dx: 1, dz: -1}, {dx: -1, dz: -1}
        //             ];
                    
        //             for (const {dx, dz} of neighbors) {
        //                 const nx = x + dx;
        //                 const nz = z + dz;
                        
        //                 if (nx >= 0 && nx < this.navGridWidth && nz >= 0 && nz < this.navGridHeight) {
        //                     const neighborIdx = nz * this.navGridWidth + nx;
        //                     const neighborTerrain = originalNavMesh[neighborIdx];
                            
        //                     // If neighbor is impassable or we can't walk to it
        //                     if (!this.isTerrainWalkable(neighborTerrain) || 
        //                         !this.canWalkBetweenTerrains(currentTerrain, neighborTerrain)) {
        //                         // Mark this cell as impassable (use 255 as a special marker)
        //                         this.navMesh[idx] = 255;
        //                         break;
        //                     }
        //                 }
        //             }
        //         }
        //     }
        // }
        
        console.log(`PathfindingSystem: Baked nav mesh ${this.navGridWidth}x${this.navGridHeight} with buffer zones`);
    }
    
    isTerrainWalkable(terrainIndex) {
        if (terrainIndex === null || terrainIndex === 255) return false;
        
        // A terrain is walkable if it has at least one walkable neighbor defined
        const terrainType = this.terrainTypes[terrainIndex];
        if (!terrainType) return false;
        
        const walkableNeighbors = terrainType.walkableNeighbors || [];
        return walkableNeighbors.length > 0;
    }

    worldToNavGrid(worldX, worldZ) {
        const halfTerrain = this.game.gameManager.call('getTerrainSize') / 2;
        const gridX = Math.floor((worldX + halfTerrain) / this.navGridSize);
        const gridZ = Math.floor((worldZ + halfTerrain) / this.navGridSize);
        return { x: gridX, z: gridZ };
    }

    navGridToWorld(gridX, gridZ) {
        const halfTerrain = this.game.gameManager.call('getTerrainSize') / 2;
        const worldX = (gridX * this.navGridSize) - halfTerrain + this.navGridSize / 2;
        const worldZ = (gridZ * this.navGridSize) - halfTerrain + this.navGridSize / 2;
        return { x: worldX, z: worldZ };
    }

    getTerrainAtNavGrid(gridX, gridZ) {
        if (gridX < 0 || gridX >= this.navGridWidth || gridZ < 0 || gridZ >= this.navGridHeight) {
            return null;
        }
        return this.navMesh[gridZ * this.navGridWidth + gridX];
    }

    requestPath(entityId, startX, startZ, endX, endZ, priority = 0) {
        const cacheKey = `${Math.floor(startX/50)},${Math.floor(startZ/50)}-${Math.floor(endX/50)},${Math.floor(endZ/50)}`;
        
        const cached = this.pathCache.get(cacheKey);
        if (cached && (this.game.state.now - cached.timestamp) < this.CACHE_EXPIRY_TIME) {
            return cached.path;
        }
        
        this.pathRequests.push({
            entityId,
            startX,
            startZ,
            endX,
            endZ,
            priority,
            cacheKey,
            timestamp: this.game.state.now
        });
        
        return null;
    }

    findPath(startX, startZ, endX, endZ, cacheKey = null) {
        const startGrid = this.worldToNavGrid(startX, startZ);
        const endGrid = this.worldToNavGrid(endX, endZ);
        
        if (startGrid.x === endGrid.x && startGrid.z === endGrid.z) {
            return [{ x: endX, z: endZ }];
        }
        
        const openSet = new GUTS.MinHeap();
        const closedSet = new Set();
        const cameFrom = new Map();
        const gScore = new Map();
        const fScore = new Map();
        
        const startKey = `${startGrid.x},${startGrid.z}`;
        const endKey = `${endGrid.x},${endGrid.z}`;
        
        gScore.set(startKey, 0);
        fScore.set(startKey, this.heuristic(startGrid, endGrid));
        openSet.push({ key: startKey, x: startGrid.x, z: startGrid.z, f: fScore.get(startKey) });
        
        const directions = [
            {dx: 1, dz: 0}, {dx: -1, dz: 0}, {dx: 0, dz: 1}, {dx: 0, dz: -1},
            {dx: 1, dz: 1}, {dx: -1, dz: 1}, {dx: 1, dz: -1}, {dx: -1, dz: -1}
        ];
        
        let iterations = 0;
        const maxIterations = this.navGridWidth * this.navGridHeight;
        
        // Track the closest point we've found to the destination
        let closestNode = { key: startKey, x: startGrid.x, z: startGrid.z };
        let closestDistance = this.heuristic(startGrid, endGrid);
        
        while (!openSet.isEmpty() && iterations < maxIterations) {
            iterations++;
            
            const current = openSet.pop();
            const currentKey = current.key;
            
            if (currentKey === endKey) {
                const path = this.reconstructPath(cameFrom, currentKey, endX, endZ);
                
                if (cacheKey) {
                    this.addToCache(cacheKey, path);
                }
                
                return path;
            }
            
            closedSet.add(currentKey);
            
            // Check if this is closer to the destination than previous closest
            const distToEnd = this.heuristic({ x: current.x, z: current.z }, endGrid);
            if (distToEnd < closestDistance) {
                closestDistance = distToEnd;
                closestNode = current;
            }
            
            const currentTerrain = this.getTerrainAtNavGrid(current.x, current.z);
            
            for (const dir of directions) {
                const neighborX = current.x + dir.dx;
                const neighborZ = current.z + dir.dz;
                const neighborKey = `${neighborX},${neighborZ}`;
                
                if (closedSet.has(neighborKey)) continue;
                
                const neighborTerrain = this.getTerrainAtNavGrid(neighborX, neighborZ);
                if (neighborTerrain === null || neighborTerrain === 255) continue;

                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, neighborTerrain, current.x, current.z, neighborX, neighborZ)) {
                    continue;
                }
                
                const isDiagonal = dir.dx !== 0 && dir.dz !== 0;
                
                // For diagonal moves, check both adjacent cells to prevent corner cutting
                if (isDiagonal) {
                    const terrainX = this.getTerrainAtNavGrid(current.x + dir.dx, current.z);
                    const terrainZ = this.getTerrainAtNavGrid(current.x, current.z + dir.dz);

                    // Both adjacent cells must exist and be walkable
                    if (terrainX === null || terrainX === 255 ||
                        terrainZ === null || terrainZ === 255) {
                        continue;
                    }

                    if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, current.x, current.z, current.x + dir.dx, current.z) ||
                        !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, current.x, current.z, current.x, current.z + dir.dz)) {
                        continue;
                    }
                }
                
                const moveCost = isDiagonal ? 1.414 : 1;
                const tentativeGScore = gScore.get(currentKey) + moveCost;
                
                if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                    cameFrom.set(neighborKey, currentKey);
                    gScore.set(neighborKey, tentativeGScore);
                    
                    const h = this.heuristic({x: neighborX, z: neighborZ}, endGrid);
                    const f = tentativeGScore + h;
                    fScore.set(neighborKey, f);
                    
                    openSet.push({ key: neighborKey, x: neighborX, z: neighborZ, f });
                }
            }
        }
        
        // No path found to exact destination - return path to closest reachable point
        if (closestNode.key !== startKey) {
            const closestWorld = this.navGridToWorld(closestNode.x, closestNode.z);
            const path = this.reconstructPath(cameFrom, closestNode.key, closestWorld.x, closestWorld.z);
            
            if (cacheKey) {
                this.addToCache(cacheKey, path);
            }
            
            console.log(`PathfindingSystem: No path to destination, returning path to closest point (distance: ${closestDistance.toFixed(1)})`);
            return path;
        }
        
        return null;
    }

    reconstructPath(cameFrom, currentKey, endX, endZ) {
        const path = [];
        const gridPath = [];
        
        let current = currentKey;
        while (current) {
            const [x, z] = current.split(',').map(Number);
            gridPath.unshift({ x, z });
            current = cameFrom.get(current);
        }
        
        for (const gridPoint of gridPath) {
            const worldPos = this.navGridToWorld(gridPoint.x, gridPoint.z);
            path.push(worldPos);
        }
        
        if (path.length > 0) {
            path[path.length - 1] = { x: endX, z: endZ };
        }
        
        return this.smoothPath(path);
    }

    smoothPath(path) {
        if (path.length <= 2) return path;

        const smoothed = [path[0]];
        let currentIdx = 0;

        while (currentIdx < path.length - 1) {
            let farthestVisible = currentIdx + 1;

            // Limit how far ahead we look to prevent aggressive corner cutting
            const maxLookahead = Math.min(
                path.length - 1,
                currentIdx + this.MAX_SMOOTH_LOOKAHEAD
            );

            // Check from far to near within the limited lookahead range
            // This still prioritizes smoother paths but prevents excessive shortcuts
            for (let i = maxLookahead; i > currentIdx + 1; i--) {
                if (this.hasLineOfSight(path[currentIdx], path[i])) {
                    farthestVisible = i;
                    break;
                }
            }

            smoothed.push(path[farthestVisible]);
            currentIdx = farthestVisible;
        }

        return smoothed;
    }
    hasDirectWalkablePath(fromPos, toPos, entityId = null) {
        if (!this.initialized || !this.navMesh) return false;
        
        const fromGrid = this.worldToNavGrid(fromPos.x, fromPos.z);
        const toGrid = this.worldToNavGrid(toPos.x, toPos.z);
        
        // Same grid cell = direct path
        if (fromGrid.x === toGrid.x && fromGrid.z === toGrid.z) {
            return true;
        }
        
        // Bresenham's line algorithm to check every grid cell along the path
        const dx = Math.abs(toGrid.x - fromGrid.x);
        const dz = Math.abs(toGrid.z - fromGrid.z);
        const sx = fromGrid.x < toGrid.x ? 1 : -1;
        const sz = fromGrid.z < toGrid.z ? 1 : -1;
        let err = dx - dz;
        
        let x = fromGrid.x;
        let z = fromGrid.z;
        let lastX = x;
        let lastZ = z;
        let lastTerrain = this.getTerrainAtNavGrid(x, z);

        // If starting position isn't walkable, fail immediately
        if (!this.isTerrainWalkable(lastTerrain)) {
            return false;
        }

        while (true) {
            // Reached destination
            if (x === toGrid.x && z === toGrid.z) {
                return true;
            }

            const currentTerrain = this.getTerrainAtNavGrid(x, z);

            // Hit impassable terrain or out of bounds
            if (currentTerrain === null || currentTerrain === 255) {
                return false;
            }

            // Check if current terrain is walkable
            if (!this.isTerrainWalkable(currentTerrain)) {
                return false;
            }

            // Check if we can transition from last terrain to current terrain
            if (!this.canWalkBetweenTerrainsWithRamps(lastTerrain, currentTerrain, lastX, lastZ, x, z)) {
                return false;
            }
            
            const e2 = 2 * err;
            const willMoveX = e2 > -dz;
            const willMoveZ = e2 < dx;
            
            // For diagonal movement, check both adjacent cells to prevent corner cutting
            if (willMoveX && willMoveZ) {
                const terrainX = this.getTerrainAtNavGrid(x + sx, z);
                const terrainZ = this.getTerrainAtNavGrid(x, z + sz);

                // Both adjacent cells must be valid and walkable
                if (terrainX === null || terrainX === 255 ||
                    terrainZ === null || terrainZ === 255) {
                    return false;
                }

                if (!this.isTerrainWalkable(terrainX) || !this.isTerrainWalkable(terrainZ)) {
                    return false;
                }

                // Check terrain transitions for both adjacent cells
                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, x, z, x + sx, z) ||
                    !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, x, z, x, z + sz)) {
                    return false;
                }
            }

            lastTerrain = currentTerrain;
            lastX = x;
            lastZ = z;

            // Move along the line
            if (willMoveX) {
                err -= dz;
                x += sx;
            }
            if (willMoveZ) {
                err += dx;
                z += sz;
            }
        }
    }
    hasLineOfSight(from, to) {
        const fromGrid = this.worldToNavGrid(from.x, from.z);
        const toGrid = this.worldToNavGrid(to.x, to.z);
        
        const dx = Math.abs(toGrid.x - fromGrid.x);
        const dz = Math.abs(toGrid.z - fromGrid.z);
        const sx = fromGrid.x < toGrid.x ? 1 : -1;
        const sz = fromGrid.z < toGrid.z ? 1 : -1;
        let err = dx - dz;
        
        let x = fromGrid.x;
        let z = fromGrid.z;
        let lastX = x;
        let lastZ = z;
        let lastTerrain = this.getTerrainAtNavGrid(x, z);

        while (true) {
            if (x === toGrid.x && z === toGrid.z) return true;

            const currentTerrain = this.getTerrainAtNavGrid(x, z);
            if (currentTerrain === null || currentTerrain === 255) return false;

            if (!this.canWalkBetweenTerrainsWithRamps(lastTerrain, currentTerrain, lastX, lastZ, x, z)) {
                return false;
            }
            
            const e2 = 2 * err;
            const willMoveX = e2 > -dz;
            const willMoveZ = e2 < dx;
            
            // Check for diagonal movement (corner cutting)
            if (willMoveX && willMoveZ) {
                // We're moving diagonally - check both adjacent cells to prevent corner cutting
                const terrainX = this.getTerrainAtNavGrid(x + sx, z);
                const terrainZ = this.getTerrainAtNavGrid(x, z + sz);
                
                // Both adjacent cells must be valid and walkable from current position
                if (terrainX === null || terrainX === 255 ||
                    terrainZ === null || terrainZ === 255) {
                    return false;
                }

                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, x, z, x + sx, z) ||
                    !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, x, z, x, z + sz)) {
                    return false;
                }
            }

            lastTerrain = currentTerrain;
            lastX = x;
            lastZ = z;

            if (willMoveX) {
                err -= dz;
                x += sx;
            }
            if (willMoveZ) {
                err += dx;
                z += sz;
            }
        }
    }

    heuristic(a, b) {
        const dx = Math.abs(a.x - b.x);
        const dz = Math.abs(a.z - b.z);
        return Math.sqrt(dx * dx + dz * dz);
    }

    addToCache(key, path) {
        if (this.pathCache.size >= this.MAX_CACHE_SIZE) {
            const oldestKey = null;
            let oldestTime = Infinity;
            
            for (const [k, v] of this.pathCache.entries()) {
                if (v.timestamp < oldestTime) {
                    oldestTime = v.timestamp;
                    oldestKey = k;
                }
            }
            
            if (oldestKey) {
                this.pathCache.delete(oldestKey);
            }
        }
        
        this.pathCache.set(key, {
            path: path,
            timestamp: this.game.state.now
        });
    }

    clearPathCache() {
        this.pathCache.clear();
    }

    update() {
        if (!this.initialized) {
            this.init();
            return;
        }
        
        const now = this.game.state.now;
        const keysToDelete = [];
        
        for (const [key, data] of this.pathCache.entries()) {
            if (now - data.timestamp > this.CACHE_EXPIRY_TIME) {
                keysToDelete.push(key);
            }
        }
        
        keysToDelete.sort();
        for (const key of keysToDelete) {
            this.pathCache.delete(key);
        }
        
        if (this.pathRequests.length === 0) return;
        
        this.pathRequests.sort((a, b) => {
            if (b.priority !== a.priority) return b.priority - a.priority;
            return String(a.entityId).localeCompare(String(b.entityId));
        });
        
        const pathsToProcess = Math.min(this.MAX_PATHS_PER_FRAME, this.pathRequests.length);
        
        for (let i = 0; i < pathsToProcess; i++) {
            const request = this.pathRequests.shift();
            
            const path = this.findPath(
                request.startX,
                request.startZ,
                request.endX,
                request.endZ,
                request.cacheKey
            );
            
            if (path && this.game.componentManager) {
                const componentTypes = this.game.componentManager.getComponentTypes();
                const aiState = this.game.getComponent(request.entityId, componentTypes.AI_STATE);
                
                if (aiState) {
                    aiState.path = path;
                    aiState.pathIndex = 0;
                }
            }
        }
    }

    isGridPositionWalkable(gridPos) {
        const worldPos = this.game.gameManager.call('convertGridToWorldPosition', gridPos.x, gridPos.z);
        return this.isPositionWalkable(worldPos);
    }

    isPositionWalkable(pos) {
        const grid = this.worldToNavGrid(pos.x, pos.z);
        
        // Check bounds
        if (grid.x < 0 || grid.x >= this.navGridWidth || 
            grid.z < 0 || grid.z >= this.navGridHeight) {
            return false;
        }
        
        const terrain = this.getTerrainAtNavGrid(grid.x, grid.z);
        return this.isTerrainWalkable(terrain);
    }

    ping() {
        console.log('pong');
    }
};

// system: GoldMineSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['GoldMineSystem'] = class GoldMineSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.goldMineSystem = this;
        this.goldVeinLocations = [];
        this.claimedGoldMines = new Map();
        
        console.log('[GoldMineSystem] Initialized', this.game.isServer ? '(SERVER)' : '(CLIENT)');
    }

    init(params) {
        this.params = params || {};

        this.game.gameManager.register('buildGoldMine', this.buildGoldMine.bind(this));
        this.game.gameManager.register('isValidGoldMinePlacement', this.isValidGoldMinePlacement.bind(this));
        this.game.gameManager.register('getGoldVeinLocations', () => this.goldVeinLocations);

        this.findGoldVeinLocations();
        console.log('[GoldMineSystem] Init complete. Found', this.goldVeinLocations.length, 'gold veins');
    }

    findGoldVeinLocations() {
        const tileMap = this.game.terrainSystem?.tileMap;
        if (!tileMap?.environmentObjects) {
            console.warn('[GoldMineSystem] No environment objects found');
            return;
        }

        const extensionSize = this.game.terrainSystem?.extensionSize || 0;
        const extendedSize = this.game.terrainSystem?.extendedSize || 0;

        this.goldVeinLocations = tileMap.environmentObjects
            .filter(obj => obj.type === 'goldVein')
            .map(obj => {
                const worldX = (obj.x + extensionSize) - extendedSize / 2;
                const worldZ = (obj.y + extensionSize) - extendedSize / 2;

                const gridPos = this.game.gameManager.call('convertWorldToGridPosition', worldX, worldZ);

                // Gold veins use placementGridWidth which is already in placement grid units
                // But we need to match how buildings calculate their cells (footprintWidth * 2)
                // Since gold veins have placementGridWidth=2, and buildings have footprintWidth=2,
                // we need to convert: footprintWidth * 2 = 2 * 2 = 4 placement grid cells
                const veinPlacementGridWidth = obj.placementGridWidth || 2;
                const veinPlacementGridHeight = obj.placementGridHeight || 2;
                // Convert to match building footprint calculation
                const gridWidth = veinPlacementGridWidth * 2;
                const gridHeight = veinPlacementGridHeight * 2;

                const cells = this.calculateGoldVeinCells(gridPos, gridWidth, gridHeight);

                return {
                    x: obj.x,
                    y: obj.y,
                    worldX: worldX,
                    worldZ: worldZ,
                    gridPos: gridPos,
                    gridWidth: gridWidth,  // 4 (placement grid cells)
                    gridHeight: gridHeight,  // 4 (placement grid cells)
                    cells: cells,
                    claimed: false,
                    claimedBy: null,
                    instanceIndex: null,
                    originalIndex: tileMap.environmentObjects.indexOf(obj)
                };
            });

        console.log('[GoldMineSystem] Found gold veins:', this.goldVeinLocations);

        if (!this.game.isServer) {
            this.mapGoldVeinInstances();
        }
    }

    calculateGoldVeinCells(gridPos, gridWidth, gridHeight) {
        const cells = [];
        const startX = gridPos.x - Math.round(gridWidth / 2);
        const startZ = gridPos.z - Math.round(gridHeight / 2);

        for (let z = 0; z < gridHeight; z++) {
            for (let x = 0; x < gridWidth; x++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }

        return cells;
    }

    isValidGoldMinePlacement(gridPos, buildingGridWidth, buildingGridHeight) {
        const buildingCells = this.calculateGoldVeinCells(gridPos, buildingGridWidth, buildingGridHeight);

        for (const vein of this.goldVeinLocations) {
            if (vein.claimed) continue;

            if (this.cellsMatch(buildingCells, vein.cells)) {
                return { valid: true, vein: vein };
            }
        }

        return { valid: false };
    }

    cellsMatch(cells1, cells2) {
        if (cells1.length !== cells2.length) return false;

        const cellSet = new Set(cells2.map(c => `${c.x},${c.z}`));
        
        for (const cell of cells1) {
            if (!cellSet.has(`${cell.x},${cell.z}`)) {
                return false;
            }
        }

        return true;
    }

    mapGoldVeinInstances() {
        if (!this.game.gameManager.call('getWorldScene')) {
            console.warn('[GoldMineSystem] No scene available for mapping instances');
            return;
        }

        const goldVeinInstancedMeshes = [];
        this.game.gameManager.call('getWorldScene').traverse(child => {
            if (child instanceof THREE.InstancedMesh && child.userData.objectType === 'goldVein') {
                goldVeinInstancedMeshes.push(child);
            }
        });

        let globalIndex = 0;
        for (const vein of this.goldVeinLocations) {
            vein.instanceIndex = globalIndex;
            vein.instancedMeshes = goldVeinInstancedMeshes;
            globalIndex++;
        }
    }

    buildGoldMine(entityId, team, gridPos, buildingGridWidth, buildingGridHeight) {

        const validation = this.isValidGoldMinePlacement(gridPos, buildingGridWidth, buildingGridHeight);
        if (!validation.valid) {
            console.warn('[GoldMineSystem] Invalid placement - no matching unclaimed vein');
            return { success: false, error: 'Must be placed on a gold vein' };
        }

        const vein = validation.vein;

        vein.claimed = true;
        vein.claimedBy = team;

        let mineModel = null;
        if (!this.game.isServer) {
            mineModel = this.replaceVeinWithMine(vein);
        }

        this.claimedGoldMines.set(entityId, {
            entityId: entityId,
            position: { x: vein.x, z: vein.y },
            worldPosition: { x: vein.worldX, z: vein.worldZ },
            gridPos: vein.gridPos,
            cells: vein.cells,
            veinIndex: vein.originalIndex,
            veinData: vein,
            team: team,
            model: mineModel
        });

        return { success: true };
    }

    destroyGoldMine(entityId) {
        const goldMine = this.claimedGoldMines.get(entityId);
        if (!goldMine) {
            return { success: false, error: 'No gold mine to destroy' };
        }

        // Clear any miners targeting this mine
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && miningState.targetMineEntityId === entityId) {
                miningState.targetMineEntityId = null;
                miningState.targetMinePosition = null;
                miningState.waitingPosition = null;
                miningState.state = 'idle';
            }
        }

        if (!this.game.isServer) {
            console.log('[GoldMineSystem] CLIENT: Restoring vein');
            this.restoreVein(goldMine.veinData);
        } else {
            console.log('[GoldMineSystem] SERVER: Releasing mine claim');
            goldMine.veinData.claimed = false;
            goldMine.veinData.claimedBy = null;
        }
        
        this.claimedGoldMines.delete(entityId);

        console.log('[GoldMineSystem] Gold mine destroyed. Remaining mines:', this.claimedGoldMines.size);
        return { success: true };
    }

    // Check if a mine is currently occupied by looking at component states
    isMineOccupied(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'mining') {
                return true;
            }
        }
        
        return false;
    }

    // Get the current miner at a mine by checking component states
    getCurrentMiner(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'mining') {
                return minerEntityId;
            }
        }
        
        return null;
    }

    // Get all miners in queue (waiting_at_mine state) for a specific mine
    getMinersInQueue(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        const queuedMiners = [];
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'waiting_at_mine') {
                queuedMiners.push(minerEntityId);
            }
        }
        
        return queuedMiners;
    }

    // Get queue position for a specific miner
    getQueuePosition(mineEntityId, minerEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        return queue.indexOf(minerEntityId);
    }

    // Check if a miner is next in queue
    isNextInQueue(mineEntityId, minerEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        return queue.length > 0 && queue[0] === minerEntityId;
    }

    // Process next miner in queue when mine becomes available
    processNextInQueue(mineEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        
        if (queue.length === 0) {
            return;
        }
        
        const nextMinerId = queue[0];
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miningState = this.game.getComponent(nextMinerId, ComponentTypes.MINING_STATE);
        
        if (miningState && miningState.state === 'waiting_at_mine') {
            const aiState = this.game.getComponent(nextMinerId, ComponentTypes.AI_STATE);
            const pos = this.game.getComponent(nextMinerId, ComponentTypes.POSITION);
            const vel = this.game.getComponent(nextMinerId, ComponentTypes.VELOCITY);
            
            if (pos && vel && miningState.targetMinePosition) {
                miningState.waitingPosition = null;
                
                pos.x = miningState.targetMinePosition.x;
                pos.z = miningState.targetMinePosition.z;
                vel.vx = 0;
                vel.vz = 0;
                
                miningState.state = 'mining';
                miningState.miningStartTime = this.game.state.now;
                
                if (aiState) {
                    aiState.state = 'idle';
                    aiState.targetPosition = null;
                }
            }
        }
    }

    replaceVeinWithMine(vein) {
        return;
        // if (vein.instancedMeshes && vein.instanceIndex !== null) {
        //     vein.instancedMeshes.forEach(mesh => {
        //         const matrix = new THREE.Matrix4();
        //         const position = new THREE.Vector3(0, -10000, 0);
        //         matrix.makeTranslation(position.x, position.y, position.z);
        //         matrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));
        //         mesh.setMatrixAt(vein.instanceIndex, matrix);
        //         mesh.instanceMatrix.needsUpdate = true;
        //     });
        // } 
    }

    restoreVein(vein) {
        // if (vein.instancedMeshes && vein.instanceIndex !== null) {
        //     const extensionSize = this.game.terrainSystem?.extensionSize || 0;
        //     const extendedSize = this.game.terrainSystem?.extendedSize || 0;
        //     const heightMapSettings = this.game.worldSystem?.heightMapSettings;
            
        //     let height = 0;
        //     if (heightMapSettings?.enabled) {
        //         height = heightMapSettings.heightStep * this.game.terrainSystem.tileMap.extensionTerrainType;
        //     }

        //     const worldX = (vein.x + extensionSize) - extendedSize / 2;
        //     const worldZ = (vein.y + extensionSize) - extendedSize / 2;

        //     const dummy = new THREE.Object3D();
        //     dummy.position.set(worldX, height, worldZ);
        //     dummy.rotation.y = Math.random() * Math.PI * 2;
        //     dummy.scale.set(50, 50, 50);
        //     dummy.updateMatrix();

        //     vein.instancedMeshes.forEach(mesh => {
        //         const matrix = new THREE.Matrix4();
        //         matrix.copy(dummy.matrix);
        //         if (mesh.userData.relativeMatrix) {
        //             matrix.multiply(mesh.userData.relativeMatrix);
        //         }
        //         mesh.setMatrixAt(vein.instanceIndex, matrix);
        //         mesh.instanceMatrix.needsUpdate = true;
        //     });            
        // }

        vein.claimed = false;
        vein.claimedBy = null;
    }

    
    onBattleEnd() {
        const entities = this.game.getEntitiesWith(this.game.componentTypes.MINING_STATE);        
        entities.forEach(entityId => {
            const miningState = this.game.getComponent(entityId, this.game.componentTypes.MINING_STATE);
            if (miningState) {
                miningState.miningStartTime = 0;
                miningState.depositStartTime = 0;
            }
        });
    }

    onDestroyBuilding(entityId){
        const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);
        if (unitType.id === 'goldMine') {
            this.game.goldMineSystem.destroyGoldMine(entityId);
        } 
    }

    reset() {
        
        if (!this.game.isServer) {
            for (const [entityId, goldMine] of this.claimedGoldMines) {
                this.restoreVein(goldMine.veinData, goldMine.model);
            }
        } else {
            for (const [entityId, goldMine] of this.claimedGoldMines) {
                goldMine.veinData.claimed = false;
                goldMine.veinData.claimedBy = null;
            }
        }
        
        this.claimedGoldMines.clear();
        
    }
};

// system: VisionSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['VisionSystem'] = class VisionSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.visionSystem = this;

        // Default unit height for line of sight calculations
        this.DEFAULT_UNIT_HEIGHT = 25;
    }

    init() {
        this.game.gameManager.register('hasLineOfSight', this.hasLineOfSight.bind(this));
    }


    hasLineOfSight(from, to, unitType, viewerEntityId = null) {
        const dx = to.x - from.x;
        const dz = to.z - from.z;
        const distanceSq = dx * dx + dz * dz;
        const distance = Math.sqrt(distanceSq);
        const gridSize = this.game.getCollections().configs.game.gridSize;

        if (distance < gridSize*2) return true;

        const terrainSystem = this.game.terrainSystem;
        if (!terrainSystem) {
            console.warn('[hasLineOfSight] No terrain system found!');
            return true;
        }

        // Get discrete heightmap levels for from and to positions
        const fromGridX = Math.floor((from.x + terrainSystem.terrainSize / 2) / gridSize);
        const fromGridZ = Math.floor((from.z + terrainSystem.terrainSize / 2) / gridSize);
        const toGridX = Math.floor((to.x + terrainSystem.terrainSize / 2) / gridSize);
        const toGridZ = Math.floor((to.z + terrainSystem.terrainSize / 2) / gridSize);

        const fromHeightLevel = terrainSystem.getHeightLevelAtGridPosition(fromGridX, fromGridZ);
        const toHeightLevel = terrainSystem.getHeightLevelAtGridPosition(toGridX, toGridZ);

        // Cannot see up to tiles with higher heightmap values
        if (toHeightLevel > fromHeightLevel) {
            return false;
        }

        const fromTerrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(from.x, from.z);
        const toTerrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(to.x, to.z);

        // Use unit height from unitType, or fall back to default if not available
        const unitHeight = (unitType && unitType.height) ? unitType.height : this.DEFAULT_UNIT_HEIGHT;

        const fromEyeHeight = fromTerrainHeight + unitHeight;
        const toEyeHeight = toTerrainHeight + unitHeight;

        // Check for terrain blocking along the path (for same-level or downward vision)
        if (!this.checkTileBasedLOS(from, to, fromEyeHeight, toTerrainHeight, fromHeightLevel)) {
            return false;
        }
        
        let nearbyTrees = [];

        const midX = (from.x + to.x) / 2;
        const midZ = (from.z + to.z) / 2;
        const unitSize = (unitType && unitType.size) ? unitType.size : gridSize;
        nearbyTrees = this.game.gameManager.call('getNearbyUnits', { x: midX, y: 0, z: midZ} , distance / 2 + unitSize, viewerEntityId, 'worldObjects');


        if (nearbyTrees.length > 0) {
            const numSamples = Math.max(2, Math.ceil(distance / (gridSize * 0.5)));
            const stepX = dx / numSamples;
            const stepZ = dz / numSamples;
            
            for (let i = 1; i < numSamples; i++) {
                const t = i / numSamples;
                const sampleX = from.x + stepX * i;
                const sampleZ = from.z + stepZ * i;
                const rayHeight = fromEyeHeight + (toEyeHeight - fromEyeHeight) * t;
                
                for (const unit of nearbyTrees) {                    
                    const dx = sampleX - unit.x;
                    const dz = sampleZ - unit.z;
                    const distSq = dx * dx + dz * dz;
                    if(!unit.size) unit.size = gridSize;
                    if (distSq < unit.size * unit.size) {            
                        if (rayHeight < unit.y+unit.height) {
                            return false;
                        }
                    }
                }
            }
        }
        
        return true;
    }

    checkTileBasedLOS(from, to, fromEyeHeight, toTerrainHeight, fromHeightLevel) {
        const terrainSystem = this.game.terrainSystem;
        const gridSize = this.game.getCollections().configs.game.gridSize;

        const fromGridX = Math.floor((from.x + terrainSystem.terrainSize / 2) / gridSize);
        const fromGridZ = Math.floor((from.z + terrainSystem.terrainSize / 2) / gridSize);
        const toGridX = Math.floor((to.x + terrainSystem.terrainSize / 2) / gridSize);
        const toGridZ = Math.floor((to.z + terrainSystem.terrainSize / 2) / gridSize);

        const tiles = this.bresenhamLine(fromGridX, fromGridZ, toGridX, toGridZ);

        // Check intermediate tiles along the path
        for (let i = 1; i < tiles.length - 1; i++) {
            const tile = tiles[i];

            // Check if this intermediate tile has a higher heightmap level than the viewer
            const tileHeightLevel = terrainSystem.getHeightLevelAtGridPosition(tile.x, tile.z);
            if (tileHeightLevel > fromHeightLevel) {
                // Cannot see through a tile with higher elevation
                return false;
            }

            // Also check if the ray goes below the terrain at this point (for smooth terrain variations)
            const t = i / (tiles.length - 1);
            const worldX = tile.x * gridSize - terrainSystem.terrainSize / 2;
            const worldZ = tile.z * gridSize - terrainSystem.terrainSize / 2;
            const rayHeight = fromEyeHeight + (toTerrainHeight - fromEyeHeight) * t;
            const terrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(worldX, worldZ);

            if (rayHeight <= terrainHeight) {
                return false;
            }
        }

        return true;
    }

    bresenhamLine(x0, z0, x1, z1) {
        const tiles = [];
        
        const dx = Math.abs(x1 - x0);
        const dz = Math.abs(z1 - z0);
        const sx = x0 < x1 ? 1 : -1;
        const sz = z0 < z1 ? 1 : -1;
        let err = dx - dz;
        
        let x = x0;
        let z = z0;
        
        while (true) {
            tiles.push({ x, z });
            
            if (x === x1 && z === z1) break;
            
            const e2 = 2 * err;
            if (e2 > -dz) {
                err -= dz;
                x += sx;
            }
            if (e2 < dx) {
                err += dx;
                z += sz;
            }
        }
        
        return tiles;
    }
};

// system: SupplySystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SupplySystem'] = class SupplySystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.supplySystem = this;
        this.supplyElement = null;
    }

    init() {
        this.game.gameManager.register('getCurrentSupply', this.getCurrentSupply.bind(this));
        this.game.gameManager.register('getCurrentPopulation', this.getCurrentPopulation.bind(this));
        this.game.gameManager.register('canAffordSupply', this.canAffordSupply.bind(this));
        if(!this.game.isServer){
            this.supplyElement = document.getElementById('playerSupplies');
        }
        
    }

    updateSupplyDisplay() {
        if (!this.supplyElement) return;

        const team = this.game.state.mySide;
        if (!team) return;

        const currentPop = this.getCurrentPopulation(team);
        const currentSupply = this.getCurrentSupply(team);

        const isAtLimit = currentPop >= currentSupply;

        this.supplyElement.innerHTML = `${currentPop}/${currentSupply}`;
    }

    update() {
        if(this.game.isServer) return;
        if (this.game.state.phase === 'placement') {
            this.updateSupplyDisplay();
        }
    }

    getCurrentSupply(team) {
        const placements = this.game.gameManager.call('getPlacementsForSide', team);
        if (!placements) return 0;

        let totalSupply = 0;

        placements.forEach(placement => {     
            if(placement.unitType.supplyProvided){      
                totalSupply += placement.unitType.supplyProvided;            
            }
        });
        return totalSupply;
    }


    getCurrentPopulation(team) {
        const placements = this.game.gameManager.call('getPlacementsForSide', team);
        if (!placements) return 0;

        let totalPopulation = 0;

        placements.forEach(placement => {     
            if(placement.unitType.supplyCost){      
                totalPopulation += placement.unitType.supplyCost;            
            }
        });
        return totalPopulation;
    }

    canAffordSupply(team, unitType) {
        const currentPop = this.getCurrentPopulation(team);
        const currentSupply = this.getCurrentSupply(team);
        const supplyCost = unitType.supplyCost || 0;

        return (currentPop + supplyCost) <= currentSupply;
    }


};

// ========== Abilities ==========

// ability: BaseAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BaseAbility'] = class BaseAbility {
    constructor(game, config = {}) {
        this.game = game;
        this.id = config.id || 'unknown';
        this.name = config.name || 'Unknown Ability';
        this.description = config.description || '';
        this.cooldown = config.cooldown || 10.0;
        this.range = config.range || 100;
        this.manaCost = config.manaCost || 0;
        this.targetType = config.targetType || 'auto';
        this.animation = config.animation || 'cast';
        this.priority = config.priority || 5;
        this.castTime = config.castTime || 1.5;
        this.autoTrigger = config.autoTrigger || 'combat';
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.effects = this.defineEffects();
    }
    
    defineEffects() {
        return {
            cast: { type: 'magic', options: { count: 15, scaleMultiplier: 0.8, speedMultiplier: 0.6 } },
            impact: { type: 'magic', options: { count: 10, scaleMultiplier: 1.2 } }
        };
    }
    
    createVisualEffect(position, effectName = 'cast', customOptions = {}) {
        if (!this.game.effectsSystem) return;
        
        const effectDef = this.effects[effectName];
        if (effectDef) {
            const mergedOptions = { ...effectDef.options, ...customOptions, heightOffset: customOptions.heightOffset || 0 };
            this.game.effectsSystem.createParticleEffect(position.x, position.y + mergedOptions.heightOffset, position.z, effectDef.type, mergedOptions);
        } else {
            this.game.effectsSystem.createParticleEffect(position.x, position.y + customOptions.heightOffset || 0, position.z, 'magic', customOptions);
        }
    }
    
    logAbilityUsage(casterEntity, message = null, showScreenEffect = false) {
      
    }
    
    dealDamageWithEffects(sourceId, targetId, damage, element = 'physical', options = {}) {
        if (this.game.damageSystem) {
            const result = this.game.damageSystem.applyDamage(sourceId, targetId, damage, element, { isSpell: true, ...options });
            
            const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
            if (targetPos && this.game.effectsSystem) {
                const effectType = result.isCritical ? 'critical' : 'damage';
                this.game.effectsSystem.showDamageNumber(targetPos.x, targetPos.y + 15, targetPos.z, result.damage, effectType);
                this.createVisualEffect(targetPos, 'impact');
            }
            
            return result;
        }
        return null;
    }
    
    // FIXED: Entities already sorted from getEntitiesWith()
    getEnemiesInRange(casterEntity, range = null) {
        const effectiveRange = range || this.range;
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!casterPos || !casterTeam) return [];
        
        return this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.TEAM, this.componentTypes.HEALTH)
            .filter(entityId => {
                if (entityId === casterEntity) return false;
                
                const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
                const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
                const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);
                
                if (!pos || !team || !health || health.current <= 0) return false;
                if (team.team === casterTeam.team) return false;
                
                const distance = Math.sqrt(Math.pow(pos.x - casterPos.x, 2) + Math.pow(pos.z - casterPos.z, 2));
                return distance <= effectiveRange;
            });
    }
    
    // FIXED: Entities already sorted from getEntitiesWith()
    getAlliesInRange(casterEntity, range = null) {
        const effectiveRange = range || this.range;
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!casterPos || !casterTeam) return [];
        
        return this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.TEAM, this.componentTypes.HEALTH)
            .filter(entityId => {
                const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
                const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
                const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);
                
                if (!pos || !team || !health || health.current <= 0) return false;
                if (team.team !== casterTeam.team) return false;
                
                const distance = Math.sqrt(Math.pow(pos.x - casterPos.x, 2) + Math.pow(pos.z - casterPos.z, 2));
                return distance <= effectiveRange;
            });
    }
    
    // FIXED: Entities already sorted, remove redundant sorting
    findBestClusterPosition(entities, minCluster = 2) {
        if (entities.length < minCluster) return null;
        
        let bestPos = null;
        let bestScore = 0;
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            if (!pos) return;
            
            let nearbyCount = 0;
            entities.forEach(otherId => {
                if (otherId === entityId) return;
                const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);
                if (!otherPos) return;
                
                const distance = Math.sqrt(Math.pow(pos.x - otherPos.x, 2) + Math.pow(pos.z - otherPos.z, 2));
                if (distance <= 80) nearbyCount++;
            });
            
            // Use >= for consistent tie-breaking (first in sorted order wins)
            if (nearbyCount >= minCluster - 1 && nearbyCount >= bestScore) {
                bestScore = nearbyCount;
                bestPos = { x: pos.x, y: pos.y, z: pos.z };
            }
        });
        
        return bestPos;
    }
    onBattleEnd() {
    }
    canExecute(casterEntity) { return true; }
    execute(casterEntity, targetData = null) { console.log(`${this.name} executed by entity ${casterEntity}`); }
};

// ability: ShieldWallAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ShieldWallAbility'] = class ShieldWallAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'shield_wall',
            name: 'Shield Wall',
            description: 'Form a defensive stance, reducing damage and taunting enemies',
            cooldown: 12.0,
            range: 0, // Self-buff with taunt radius
            manaCost: 30,
            targetType: 'self',
            animation: 'cast',
            priority: 4,
            castTime: 1.0,
            ...params
        });
        
        this.wallDuration = 10.0;
        this.damageReduction = 0.75; // 75% damage reduction
        this.tauntRadius = 200;
        this.originalArmorMultiplier = 1.0;
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x708090,
                    colorRange: { start: 0x708090, end: 0xC0C0C0 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            shield_formation: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4682B4,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            defensive_stance: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 0.6
                }
            },
            taunt_aura: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF6347,
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if already has shield wall to prevent stacking
        const existingWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);
        if (existingWall && existingWall.isActive) return false;
        
        // Use when enemies are nearby and threatening
        const enemies = this.getEnemiesInRange(casterEntity, this.tauntRadius);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Soldier prepares to form a shield wall...`);
        
        // Schedule the shield wall formation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.formShieldWall(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    formShieldWall(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);
        
        if (!casterPos) return;
        
        // Create shield formation effect
        this.createVisualEffect(casterPos, 'shield_formation');
        
        // Store original armor for restoration later
        const originalArmor = casterCombat ? casterCombat.armor : 0;
        
        // Apply shield wall component with proper timing
        const Components = this.game.componentManager.getComponents();
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const endTime = currentTime + this.wallDuration;
        
        this.game.addComponent(casterEntity, this.componentTypes.SHIELD_WALL, 
            Components.ShieldWall(
                this.damageReduction,
                endTime,
                this.tauntRadius,
                originalArmor
            )
        );
        
        // Schedule defensive stance visual effect
        this.game.schedulingSystem.scheduleAction(() => {
            const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
            if (pos) {
                this.createVisualEffect(pos, 'defensive_stance');
            }
        }, 0.5, casterEntity);
        
        // Apply taunt effect to nearby enemies
        this.applyTauntToEnemies(casterEntity);
        
        // Screen effects for dramatic formation
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.3, 1);
        }
        
    
      
        
        // Schedule shield wall expiration warning
        this.game.schedulingSystem.scheduleAction(() => {
            this.warnShieldWallEnding(casterEntity);
        }, this.wallDuration - 1.5, casterEntity);
        
        // Schedule shield wall removal (failsafe)
        this.game.schedulingSystem.scheduleAction(() => {
            this.removeShieldWall(casterEntity);
        }, this.wallDuration, casterEntity);
    }
    
    applyTauntToEnemies(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity, this.tauntRadius);
        if (enemies.length === 0) return;
        
        // Sort enemies deterministically for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let tauntedCount = 0;
        
        sortedEnemies.forEach((enemyId, index) => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyAI = this.game.getComponent(enemyId, this.componentTypes.AI_STATE);
            
            if (!enemyPos || !enemyAI) return;
            
            // Apply taunt component
            const Components = this.game.componentManager.getComponents();
            const currentTime = this.game.state.now || this.game.state.now || 0;
            const tauntEndTime = currentTime + (this.wallDuration * 0.8); // Taunt lasts 80% of shield wall
            
            this.game.addComponent(enemyId, this.componentTypes.TAUNT, 
                Components.Taunt(
                    casterEntity,     // Taunter
                    tauntEndTime,     // End time
                    this.tauntRadius, // Radius
                    true              // Is taunted
                )
            );
            
            // Force AI to target the shield wall user
  
            enemyAI.target = casterEntity;
            enemyAI.targetPosition = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
            enemyAI.path = [];
            enemyAI.meta = {};
        
            // Schedule staggered taunt effects for visual appeal
            this.game.schedulingSystem.scheduleAction(() => {
                const pos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (pos) {
                    this.createVisualEffect(pos, 'taunt_aura');
                }
            }, index * 0.1, enemyId);
            
            tauntedCount++;
        });
        
        if (tauntedCount > 0) {
            this.logAbilityUsage(casterEntity, 
                `Shield wall taunts ${tauntedCount} enemies to attack!`);
        }
    }
    
    // FIXED: Shield wall ending warning
    warnShieldWallEnding(casterEntity) {
        const shieldWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        // Check if shield wall still exists and is active
        if (!shieldWall || !shieldWall.isActive || !casterPos) return;
        
        // Create warning effect
        this.createVisualEffect(casterPos, 'cast', { 
            count: 4, 
            color: 0x708090,
            scaleMultiplier: 0.8 
        });
     
    }
    
    // FIXED: Proper shield wall removal
    removeShieldWall(casterEntity) {
        const shieldWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!shieldWall) return;
        
        // Create dissolution effect
        if (casterPos) {
            this.createVisualEffect(casterPos, 'defensive_stance', { 
                count: 6, 
                scaleMultiplier: 0.6 
            });
        }
        
        // Remove shield wall component
        this.game.removeComponent(casterEntity, this.componentTypes.SHIELD_WALL);
        
       
    }
};

// ability: ArenaPresenceAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ArenaPresenceAbility'] = class ArenaPresenceAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'arena_presence',
            name: 'Arena Presence',
            description: 'Intimidate nearby enemies, reducing their damage and accuracy (does not stack)',
            cooldown: 10.0,
            range: 120,
            manaCost: 25,
            targetType: 'area',
            animation: 'cast',
            priority: 5,
            castTime: 1.2,
            ...params
        });
        
        this.intimidationDuration = 15.0;
        this.damageReduction = 0.25; // 25% damage reduction
        this.accuracyReduction = 0.2; // 20% accuracy reduction
        this.fearRadius = this.range;
        this.element = 'psychological';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    colorRange: { start: 0x8B0000, end: 0xFF4500 },
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.0
                }
            },
            intimidation_aura: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x800000,
                    scaleMultiplier: 2.5,
                    speedMultiplier: 0.6
                }
            },
            fear_effect: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4B0000,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.0
                }
            },
            presence_wave: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x660000,
                    scaleMultiplier: 3.0,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Need enemies nearby to intimidate
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Gladiator's presence fills the arena with dread...`);
        
        // Schedule the intimidation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.unleashArenaPresence(casterEntity, enemies);
        }, this.castTime, casterEntity);
    }
    
    unleashArenaPresence(casterEntity, targetEnemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Create intimidation aura effect
        this.createVisualEffect(casterPos, 'intimidation_aura');
        
        // Create expanding presence wave
        this.createVisualEffect(casterPos, 'presence_wave');
        
        // Sort enemies deterministically for consistent processing
        const sortedEnemies = targetEnemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let intimidatedCount = 0;
        let refreshedCount = 0;
        
        // Apply intimidation to each enemy in deterministic order
        sortedEnemies.forEach((enemyId, index) => {
            const intimidationResult = this.applyIntimidation(casterEntity, enemyId);
            
            if (intimidationResult.success) {
                if (intimidationResult.wasRefreshed) {
                    refreshedCount++;
                } else {
                    intimidatedCount++;
                }
                
                // Schedule staggered fear effects for visual appeal
                this.game.schedulingSystem.scheduleAction(() => {
                    const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                    if (enemyPos) {
                        this.createVisualEffect(enemyPos, 'fear_effect');
                    }
                }, index * 0.1, enemyId);
            }
        });
        
        // Screen effects for dramatic presence
        if (this.game.effectsSystem && (intimidatedCount > 0 || refreshedCount > 0)) {
            this.game.effectsSystem.playScreenShake(0.4, 2);
            this.game.effectsSystem.playScreenFlash('#8B0000', 0.6);
        }
        
       
    }
    
    applyIntimidation(casterEntity, enemyId) {
        // Validate enemy still exists and is alive
        const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
        const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
        
        if (!enemyHealth || enemyHealth.current <= 0 || !enemyPos) {
            return { success: false, reason: 'target_invalid' };
        }
        
        // Check if already intimidated - don't stack multiple intimidations
        const existingBuff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const endTime = currentTime + this.intimidationDuration;
        
        if (existingBuff && existingBuff.buffType === 'intimidated') {
            // Refresh duration instead of stacking
            existingBuff.endTime = endTime;
            existingBuff.appliedTime = currentTime;
            
         
            
            return { success: true, wasRefreshed: true };
        } else {
            // Apply new intimidation buff
            const Components = this.game.componentManager.getComponents();
            
            this.game.addComponent(enemyId, this.componentTypes.BUFF, 
                Components.Buff(
                    'intimidated', 
                    { 
                        damageReduction: this.damageReduction,
                        accuracyReduction: this.accuracyReduction,
                        intimidatedBy: casterEntity,
                        fearLevel: 1
                    }, 
                    endTime,      // End time
                    false,        // Not stackable
                    1,            // Single stack
                    currentTime   // Applied time
                )
            );
            
       
            
            return { success: true, wasRefreshed: false };
        }
    }
    
    // Helper method to check intimidation effectiveness
    getIntimidationEffectiveness(casterEntity, enemyId) {
        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);
        const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
        
        if (!casterCombat || !enemyCombat || !casterHealth || !enemyHealth) {
            return 1.0; // Default effectiveness
        }
        
        // Calculate intimidation effectiveness based on relative power
        const casterPower = (casterCombat.damage || 1) * (casterHealth.current || 1);
        const enemyPower = (enemyCombat.damage || 1) * (enemyHealth.current || 1);
        
        const powerRatio = casterPower / Math.max(enemyPower, 1);
        
        // Effectiveness between 0.5 and 1.5 based on power difference
        return Math.max(0.5, Math.min(1.5, 0.7 + (powerRatio * 0.3)));
    }
    
    // Helper method to get current intimidation status
    getIntimidationStatus(enemyId) {
        const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
        
        if (!buff || buff.buffType !== 'intimidated') {
            return { isIntimidated: false };
        }
        
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const timeRemaining = Math.max(0, buff.endTime - currentTime);
        
        return {
            isIntimidated: true,
            timeRemaining: timeRemaining,
            damageReduction: buff.modifiers?.damageReduction || this.damageReduction,
            accuracyReduction: buff.modifiers?.accuracyReduction || this.accuracyReduction,
            intimidatedBy: buff.modifiers?.intimidatedBy
        };
    }
};

// ability: BlizzardAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BlizzardAbility'] = class BlizzardAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'blizzard',
            name: 'Blizzard',
            description: 'Summons a devastating blizzard that freezes all enemies',
            cooldown: 5.0,
            range: 300,
            manaCost: 0,
            targetType: 'auto',
            animation: 'cast',
            priority: 10,
            castTime: 2.5,
            autoTrigger: 'many_enemies',
            ...params
        });
        
        this.damage = 3;
        this.blizzardRadius = 150;
        this.duration = 3.0;
        this.tickInterval = 0.4;
        this.element = 'cold';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x88ccff,
                    colorRange: { start: 0x88ccff, end: 0xffffff },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            },
            blizzard: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xaaddff,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 3;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `An arctic blizzard engulfs the battlefield!`, true);
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.createBlizzard(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    createBlizzard(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Screen effect
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#aaffff', 0.6);
        }
        
        // DESYNC SAFE: Schedule all blizzard ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeBlizzardTick(casterEntity, tickIndex);
            }, tickDelay, casterEntity);
        }
    }
    
    // DESYNC SAFE: Execute a single blizzard tick deterministically
    executeBlizzardTick(casterEntity, tickIndex) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // DESYNC SAFE: Get all enemies deterministically
        const allEnemies = this.getEnemiesInRange(casterEntity, 1000); // Very large range to cover battlefield
        
        if (allEnemies.length === 0) return;
        
        // Sort enemies deterministically for consistent processing order
        const sortedEnemies = allEnemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            // Only affect living enemies
            if (enemyPos && enemyHealth && enemyHealth.current > 0) {
                // Create localized blizzard effect at each enemy
                this.createVisualEffect(enemyPos, 'blizzard', { count: 3 });
                
                // Apply cold damage
                this.dealDamageWithEffects(casterEntity, enemyId, this.damage, this.element, {
                    isBlizzard: true,
                    tickIndex: tickIndex
                });
            }
        });
        
        // Additional visual flair for certain ticks
        if (tickIndex === 0 || tickIndex % 3 === 0) {
            // Create additional atmospheric effects on key ticks
            const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
            if (casterPos) {
                this.createVisualEffect(casterPos, 'blizzard', { 
                    count: 8, 
                    scaleMultiplier: 2.5,
                    heightOffset: 20 
                });
            }
        }
    }
};

// ability: BloodlustAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BloodlustAbility'] = class BloodlustAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'bloodlust',
            name: 'Bloodlust',
            description: 'Heal when dealing damage and gain stacking damage bonuses',
            cooldown: 5.0,
            range: 0,
            manaCost: 0,
            targetType: 'self',
            animation: 'cast',
            priority: 7,
            castTime: 1.0,
            ...params
        });
        
        this.lifeStealAmount = 0.3; // 30% life steal
        this.damagePerKill = 5; // Damage bonus per kill
        this.maxStacks = 10; // Maximum kill stacks
        this.duration = 30.0; // 30 seconds duration
    }
    
    defineEffects() {
        return {
            cast: { 
                type: 'magic', 
                options: { 
                    count: 3, 
                    color: 0x880000, 
                    colorRange: { start: 0x880000, end: 0xDC143C },
                    scaleMultiplier: 1.4,
                    speedMultiplier: 1.2
                } 
            },
            bloodlust: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xB22222,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if already has bloodlust active to prevent stacking
        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        return !existingBuff || existingBuff.buffType !== 'bloodlust';
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Berserker enters a bloodthirsty frenzy!", true);
        
        // DESYNC SAFE: Use scheduling system for bloodlust activation
        this.game.schedulingSystem.scheduleAction(() => {
            this.activateBloodlust(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    activateBloodlust(casterEntity) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;
        
        // Check if already has bloodlust to prevent double application
        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        if (existingBuff && existingBuff.buffType === 'bloodlust') {
            // DESYNC SAFE: Refresh duration instead of stacking
            existingBuff.endTime = this.game.state.now + this.duration;
            existingBuff.appliedTime = this.game.state.now;
            
            // Visual refresh effect
            this.createVisualEffect(casterPos, 'bloodlust');
            return;
        }
        
        // Apply bloodlust buff
        const Components = this.game.componentManager.getComponents();
        this.game.addComponent(casterEntity, this.componentTypes.BUFF, 
            Components.Buff('bloodlust', { 
                lifeSteal: this.lifeStealAmount, 
                damagePerKill: this.damagePerKill, 
                maxStacks: this.maxStacks,
                currentStacks: 0 // Start with 0 kill stacks
            }, this.game.state.now + this.duration, true, 1, this.game.state.now));
        
        // Visual bloodlust effect
        this.createVisualEffect(casterPos, 'bloodlust');
        
        // Screen effect for dramatic activation
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.2, 1.5);
            this.game.effectsSystem.playScreenFlash('#8B0000', 0.3);
        }
        
        // DESYNC SAFE: Schedule buff removal
        this.game.schedulingSystem.scheduleAction(() => {
            this.removeBloodlust(casterEntity);
        }, this.duration, casterEntity);
        
 
    }
    
    // DESYNC SAFE: Remove bloodlust buff
    removeBloodlust(casterEntity) {
        // Check if entity still exists and has the bloodlust buff
        if (this.game.hasComponent(casterEntity, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'bloodlust') {
                const stacksGained = buff.modifiers.currentStacks || 0;
                
                this.game.removeComponent(casterEntity, this.componentTypes.BUFF);
                
                // Visual effect when bloodlust expires
                const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
                if (casterPos) {
                    this.createVisualEffect(casterPos, 'bloodlust', { 
                        count: 5, 
                        scaleMultiplier: 0.8,
                        color: 0x696969 
                    });
                }
                
             
            }
        }
    }
    
    // Helper method to handle kill stacking (called by damage system when enemy dies)
    onEnemyKilled(killerId) {
        if (!this.game.hasComponent(killerId, this.componentTypes.BUFF)) return;
        
        const buff = this.game.getComponent(killerId, this.componentTypes.BUFF);
        if (!buff || buff.buffType !== 'bloodlust') return;
        
        // Increase kill stacks up to maximum
        const currentStacks = buff.modifiers.currentStacks || 0;
        if (currentStacks < this.maxStacks) {
            buff.modifiers.currentStacks = currentStacks + 1;
            
            // Visual effect for gaining a kill stack
            const killerPos = this.game.getComponent(killerId, this.componentTypes.POSITION);
            if (killerPos) {
                this.createVisualEffect(killerPos, 'bloodlust', { 
                    count: 3, 
                    scaleMultiplier: 1.2,
                    heightOffset: 10 
                });
            }
    
        }
    }
};

// ability: BurningAuraAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BurningAuraAbility'] = class BurningAuraAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'burning_aura',
            name: 'Burning Aura',
            description: 'Emanate heat that burns nearby enemies',
            cooldown: 0,
            range: 100,
            manaCost: 0,
            targetType: 'area',
            animation: 'cast',
            priority: 6,
            castTime: 0,
            ...params
        });
        this.drainPerSecond = 8;
        this.duration = 12.0; // 12 seconds instead of 1200 seconds
        this.tickInterval = 1.0; // 1 second between ticks
        this.hasActiveAura = false;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'fire',
                options: {
                    count: 3,
                    color: 0x4B0082,
                    colorRange: { start: 0x4B0082, end: 0x000000 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            burning: {
                type: 'fire',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            empowerment: {
                type: 'fire',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Only allow one active aura per caster
        return !this.hasActiveAura;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        this.createVisualEffect(pos, 'cast');
        
        // Mark aura as active
        this.hasActiveAura = true;
        
        // DESYNC SAFE: Schedule all aura ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeAuraTick(casterEntity, tickIndex, totalTicks);
            }, tickDelay, casterEntity);
        }
        
        // DESYNC SAFE: Schedule aura cleanup
        this.game.schedulingSystem.scheduleAction(() => {
            this.hasActiveAura = false;
        }, this.duration, casterEntity);
    }
    
    // DESYNC SAFE: Execute a single aura tick deterministically
    executeAuraTick(casterEntity, tickIndex, totalTicks) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {
            // Caster is dead, end the aura early
            this.hasActiveAura = false;
            return;
        }
        
        // DESYNC SAFE: Get enemies and allies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // Sort for consistent processing order
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Process enemies - burn their health
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.range) {
                // Apply burn damage
                this.dealDamageWithEffects(casterEntity, enemyId, this.drainPerSecond, 'fire', {
                    tickIndex: tickIndex
                });
                
                // Visual corruption effect
                this.createVisualEffect(enemyPos, 'burning', { heightOffset: 10 });
            }
        });
        // Additional visual effects every few ticks
        if (tickIndex % 3 === 0) {
            this.createVisualEffect(casterPos, 'burning', { 
                count: 6, 
                scaleMultiplier: 2.5,
                heightOffset: 15 
            });
        }
    }
};

// ability: ChargeAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ChargeAbility'] = class ChargeAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'charge',
            name: 'Charge',
            description: 'Rush forward dealing damage and stunning enemies',
            cooldown: 5.0,
            range: 150,
            manaCost: 0,
            targetType: 'enemy',
            animation: 'attack',
            priority: 8,
            castTime: 0.5,
            ...params
        });
        
        this.chargeDamage = 55;
        this.chargeSpeed = 300;
        this.chargeDuration = 0.8; // How long the charge takes
        this.stunDuration = 2.0; // How long enemies are stunned
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xC0C0C0,
                    colorRange: { start: 0xC0C0C0, end: 0xFFFFFF },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.0
                }
            },
            charge: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B4513,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 3.0
                }
            },
            impact: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0xFF4500,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 1.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // Don't charge if already charging
        const charging = this.game.getComponent(casterEntity, this.componentTypes.CHARGING);
        if (charging && charging.isCharging) return false;
        
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // DESYNC SAFE: Select closest enemy deterministically
        const target = this.findClosestEnemy(casterEntity, enemies);
        if (!target) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Knight charges into battle!", true);
        
        // DESYNC SAFE: Use scheduling system for charge execution
        this.game.schedulingSystem.scheduleAction(() => {
            this.initiateCharge(casterEntity, target);
        }, this.castTime, casterEntity);
    }
    
    // DESYNC SAFE: Find closest enemy deterministically
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closest = null;
        let closestDistance = Infinity;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });
        
        return closest;
    }
    
    initiateCharge(casterEntity, targetId) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);
        
        if (!pos || !targetPos || !velocity) return;
        
        // DESYNC SAFE: Calculate charge direction deterministically
        const dx = targetPos.x - pos.x;
        const dz = targetPos.z - pos.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance === 0) return; // Avoid division by zero
        
        // DESYNC SAFE: Add charging component for state tracking
        const Components = this.game.componentManager.getComponents();
        this.game.addComponent(casterEntity, this.componentTypes.CHARGING, 
            Components.Charging(targetId, this.chargeSpeed, this.chargeDamage, 
                this.game.state.now, 0, distance));
        
        // Set velocity for charge
        velocity.vx = (dx / distance) * this.chargeSpeed;
        velocity.vz = (dz / distance) * this.chargeSpeed;
        
        // Visual charge effect
        this.createVisualEffect(pos, 'charge');
        
        // Screen effect for dramatic charge
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.2, 1);
        }
        
        // DESYNC SAFE: Schedule charge completion
        this.game.schedulingSystem.scheduleAction(() => {
            this.completeCharge(casterEntity, targetId);
        }, this.chargeDuration, casterEntity);
    }
    
    completeCharge(casterEntity, targetId) {
        // Stop the charge by removing charging component and resetting velocity
        if (this.game.hasComponent(casterEntity, this.componentTypes.CHARGING)) {
            this.game.removeComponent(casterEntity, this.componentTypes.CHARGING);
        }
        
        // Stop movement
        const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);
        if (velocity) {
            velocity.vx = 0;
            velocity.vz = 0;
        }
        
        // Check if target still exists and is in range for impact
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        
        if (!casterPos || !targetPos || !targetHealth || targetHealth.current <= 0) return;
        
        // Check if we're close enough to hit the target
        const distance = Math.sqrt(
            Math.pow(targetPos.x - casterPos.x, 2) + 
            Math.pow(targetPos.z - casterPos.z, 2)
        );
        
        if (distance <= 50) { // Hit range
            // Visual impact effect
            this.createVisualEffect(targetPos, 'impact');
            
            // Deal damage
            this.dealDamageWithEffects(casterEntity, targetId, this.chargeDamage, 'physical', {
                isCharge: true,
                knockback: true
            });
            
            // DESYNC SAFE: Apply stun using buff system
            const Components = this.game.componentManager.getComponents();
            this.game.addComponent(targetId, this.componentTypes.BUFF, 
                Components.Buff('stunned', { 
                    movementDisabled: true, 
                    attackDisabled: true 
                }, this.game.state.now + this.stunDuration, false, 1, this.game.state.now));
            
            // DESYNC SAFE: Schedule stun removal
            this.game.schedulingSystem.scheduleAction(() => {
                this.removeStun(targetId);
            }, this.stunDuration, targetId);
            
            // Screen effect for impact
            if (this.game.effectsSystem) {
                this.game.effectsSystem.playScreenShake(0.4, 2);
            }
            
        
        }
    }
    
    // DESYNC SAFE: Remove stun effect
    removeStun(targetId) {
        // Check if target still exists and has the stun buff
        if (this.game.hasComponent(targetId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(targetId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'stunned') {
                this.game.removeComponent(targetId, this.componentTypes.BUFF);
                
                // Visual effect when stun expires
                const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
                if (targetPos) {
                    this.createVisualEffect(targetPos, 'cast', { 
                        count: 3, 
                        scaleMultiplier: 0.8,
                        color: 0x87CEEB 
                    });
                }
          
            }
        }
    }
    
    // Helper method to handle charge interruption (e.g., if caster dies mid-charge)
    cancelCharge(casterEntity) {
        if (this.game.hasComponent(casterEntity, this.componentTypes.CHARGING)) {
            this.game.removeComponent(casterEntity, this.componentTypes.CHARGING);
            
            // Stop movement
            const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);
            if (velocity) {
                velocity.vx = 0;
                velocity.vz = 0;
            }
        }
    }
};

// ability: BuildAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BuildAbility'] = class BuildAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, abilityData) {
        super(game, abilityData);
        this.id = 'build';
        this.name = 'Build';
        this.description = 'Construct buildings';
        this.isPassive = true;
        this.autocast = false;
        this.castTime = 0;
        this.cooldown = 0;
        this.priority = 0;
        this.enabled = true;
        this.meta = { preventEnemiesInRangeCheck: true };
        this.buildRange = 50;
    }

    canExecute(entityId) {
        if(!this.enabled){
            return false;
        }
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        let buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
        
        if (!buildingState) {
            return false;
        }

        return this.game.aiSystem.getCurrentAIControllerId(entityId) == ComponentTypes.BUILDING_STATE;
    }
    execute(entityId, targetData) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const buildState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
        const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
        const vel = this.game.getComponent(entityId, ComponentTypes.VELOCITY);
        
        if (!buildState || !pos || !vel) {
            return null;
        }

        this.updateBuilderState(entityId, buildState, pos, vel);
        return null;
    }

    updateBuilderState(entityId, buildState, pos, vel) {
        buildState.entityId = entityId;
        
        switch (buildState.state) {
            case 'idle':
                break;
            case 'walking_to_construction':
                this.walkToConstruction(buildState, pos, vel);
                break;
            case 'constructing':
                this.constructBuilding(buildState);
                break;
        }
    }

    assignToBuild(peasantEntityId, buildingEntityId, peasantInfo) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        const aiState = this.game.getComponent(peasantEntityId, ComponentTypes.AI_STATE);
        const buildingPos = this.game.getComponent(buildingEntityId, ComponentTypes.POSITION);

        if (!buildingPos) return;

        const buildingPlacement = this.game.getComponent(buildingEntityId, ComponentTypes.PLACEMENT);
        const renderComponent = this.game.getComponent(buildingEntityId, ComponentTypes.RENDERABLE);
        renderComponent.spawnType = 'underConstruction';

        this.game.removeComponent(buildingEntityId, ComponentTypes.HEALTH);

        const peasantId = peasantInfo.peasantId;
        const buildTime = peasantInfo.buildTime;

        if (buildingPlacement) {
            buildingPlacement.isUnderConstruction = true;
            buildingPlacement.buildTime = buildTime;
            buildingPlacement.assignedBuilder = peasantId || null;
        }

        this.peasantId = peasantEntityId;
        this.game.addComponent(peasantEntityId, ComponentTypes.BUILDING_STATE, Components.BuildingState('walking_to_construction', buildingEntityId, buildingPos, this.game.state.round));
        this.game.addComponent(buildingEntityId, ComponentTypes.BUILDING_STATE, Components.BuildingState('planned_for_construction', buildingEntityId, buildingPos, null));

        // Use command queue system to issue build command
        // This will properly interrupt current movement and clear the path
        if (this.game.commandQueueSystem) {
            this.game.gameManager.call('queueCommand', peasantEntityId, {
                type: 'build',
                controllerId: ComponentTypes.BUILDING_STATE,
                targetPosition: buildingPos,
                target: buildingEntityId,
                meta: this.meta,
                priority: this.game.commandQueueSystem.PRIORITY.BUILD,
                interruptible: true
            }, true); // true = interrupt current command
        } else {
            // Fallback to old method if command queue system not available
            let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(peasantEntityId, ComponentTypes.BUILDING_STATE);
            currentBuildingStateAI.targetPosition = buildingPos;
            currentBuildingStateAI.meta = this.meta;
            this.game.aiSystem.setCurrentAIController(peasantEntityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);
        }

        if (buildingPlacement) {
            buildingPlacement.assignedBuilder = peasantEntityId;
            buildingPlacement.isUnderConstruction = true;
        }
    }

    walkToConstruction(buildState, pos, vel) {
        
        if (!buildState.targetBuildingPosition || !buildState.targetBuildingEntityId) {
            buildState.state = 'idle';
            return;
        }

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const buildingPosition = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.POSITION);
        const buildingBuildState = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.BUILDING_STATE);
        
        if (!buildingPosition) {
            buildState.targetBuildingEntityId = null;
            buildState.targetBuildingPosition = null;
            buildState.state = 'idle';
            return;
        }

        const dx = buildState.targetBuildingPosition.x - pos.x;
        const dz = buildState.targetBuildingPosition.z - pos.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < this.buildRange) {
            let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(buildState.entityId, ComponentTypes.BUILDING_STATE);
            currentBuildingStateAI.targetPosition = null;
            currentBuildingStateAI.state = 'idle';
            currentBuildingStateAI.meta = this.meta;
            this.game.aiSystem.setCurrentAIController(buildState.entityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);

            pos.x = buildState.targetBuildingPosition.x + this.buildRange;
            pos.z = buildState.targetBuildingPosition.z;
            vel.vx = 0;
            vel.vz = 0;

            // Make the peasant face the building
            const facing = this.game.getComponent(buildState.entityId, ComponentTypes.FACING);
            if (facing) {
                const dx = buildState.targetBuildingPosition.x - pos.x;
                const dz = buildState.targetBuildingPosition.z - pos.z;
                const angleToBuilding = Math.atan2(dz, dx);
                facing.angle = angleToBuilding;
            }

            buildState.state = 'constructing';
            buildState.constructionStartTime = this.game.state.round;
            buildingBuildState.state = 'under_construction';
            buildingBuildState.constructionStartTime = this.game.state.round;
        } else {     
            let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(buildState.entityId, ComponentTypes.BUILDING_STATE);
            if(currentBuildingStateAI.targetPosition != buildState.targetBuildingPosition){
                currentBuildingStateAI.targetPosition = buildState.targetBuildingPosition;  
                currentBuildingStateAI.state = 'chasing';                          
                currentBuildingStateAI.meta = this.meta;
                this.game.aiSystem.setCurrentAIController(buildState.entityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);   
            }
        }
    }

    constructBuilding(buildState) {

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        const buildingPlacement = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.PLACEMENT);
        const unitType = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.UNIT_TYPE);
        this.game.addComponent(buildState.targetBuildingEntityId, ComponentTypes.HEALTH, Components.Health(unitType.hp));
        

        const elapsed = this.game.state.round - buildState.constructionStartTime;
        const buildTime = buildingPlacement.buildTime || 1;
        if (this.game.animationSystem) {
            const animState = this.game.animationSystem.entityAnimationStates.get(buildState.entityId);
            if(animState){
                const finished = this.game.animationSystem.isAnimationFinished(buildState.entityId, animState.currentClip);
                if(finished || animState.currentClip != 'attack'){
                    this.game.abilitySystem.startAbilityAnimation(buildState.entityId, { castTime: 1 });
                }
            }
        }

        if (elapsed >= buildTime) {            
            this.completeConstruction(buildState);
        }
    }

    completeConstruction(buildState) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const buildingPlacement = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.PLACEMENT);
        const aiState = this.game.getComponent(this.peasantId, ComponentTypes.AI_STATE);
        const renderComponent = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.RENDERABLE);
        renderComponent.spawnType = buildingPlacement.unitType.id;
        this.game.renderSystem?.removeInstance(buildState.targetBuildingEntityId);
        if (!buildingPlacement) {
            buildState.state = 'idle';
            return;
        }
        if(this.game.shopSystem){
            this.game.shopSystem.addBuilding(buildingPlacement.unitType.id, buildingPlacement.squadUnits[0]);
        }

        buildingPlacement.isUnderConstruction = false;
        buildingPlacement.assignedBuilder = null;

        if (this.game.animationSystem) {
            this.game.animationSystem.changeAnimation(buildState.targetBuildingEntityId, 'idle', 1.0, 0);
        }

        buildState.targetBuildingEntityId = null;
        buildState.targetBuildingPosition = null;
        buildState.state = 'idle';

        // Mark command as complete in command queue system
        if (this.game.commandQueueSystem) {
            this.game.gameManager.call('completeCurrentCommand', this.peasantId);
        } else {
            // Fallback to old method
            this.game.aiSystem.removeCurrentAIController(this.peasantId);
        }

        this.game.removeComponent(this.peasantId, ComponentTypes.BUILDING_STATE);
    }
    
    onPlacementPhaseStart(entityId) {
        if(this.canExecute(entityId)){
            this.execute(entityId);
        }
    }
    
    logAbilityUsage(entityId) {
    }
};

// ability: ConsecrationAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ConsecrationAbility'] = class ConsecrationAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'consecration',
            name: 'Consecration',
            description: 'Sanctify the ground, creating a zone that damages undead and heals the living',
            cooldown: 18.0,
            range: 0, // Centered on caster
            manaCost: 50,
            targetType: 'area',
            animation: 'cast',
            priority: 7,
            castTime: 2.0,
            ...params
        });
        
        this.consecrationRadius = 120;
        this.duration = 15.0; // 15 seconds
        this.tickInterval = 2.0; // Every 2 seconds
        this.tickDamage = 12; // Damage to undead per tick
        this.tickHeal = 8; // Healing to living per tick
    }
    
    defineEffects() {
        return {
            cast: { 
                type: 'magic', 
                options: { 
                    count: 3, 
                    color: 0xffffaa, 
                    colorRange: { start: 0xffffaa, end: 0xffffff },
                    scaleMultiplier: 1.6,
                    speedMultiplier: 1.2
                } 
            },
            consecration: { 
                type: 'heal', 
                options: { 
                    count: 3, 
                    color: 0xffffdd, 
                    scaleMultiplier: 0.6,
                    speedMultiplier: 1.0
                } 
            },
            purge: { 
                type: 'damage', 
                options: { 
                    count: 3, 
                    color: 0xffffff, 
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                } 
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if there are units nearby that would benefit from consecration
        const nearbyUnits = this.getUnitsInRange(casterEntity, this.consecrationRadius);
        return nearbyUnits.length >= 2; // At least 2 units to affect
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Templar consecrates the battlefield with holy power!", true);
        
        // DESYNC SAFE: Use scheduling system for consecration creation
        this.game.schedulingSystem.scheduleAction(() => {
            this.createConsecration(casterEntity, pos);
        }, this.castTime, casterEntity);
    }
    
    createConsecration(casterEntity, consecrationPos) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // Create consecrated ground entity
        const consecrationId = this.game.createEntity();
        const Components = this.game.componentManager.getComponents();
        
        this.game.addComponent(consecrationId, this.componentTypes.POSITION, 
            Components.Position(consecrationPos.x, consecrationPos.y, consecrationPos.z));
        
        this.game.addComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT, 
            Components.TemporaryEffect('consecrated_ground', {
                caster: casterEntity,
                radius: this.consecrationRadius,
                tickInterval: this.tickInterval,
                tickDamage: this.tickDamage,
                tickHeal: this.tickHeal
            }, this.game.state.now));
        
        this.game.addComponent(consecrationId, this.componentTypes.RENDERABLE, 
            Components.Renderable("effects", "consecration"));
        
        // DESYNC SAFE: Schedule all consecration ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeConsecrationTick(consecrationId, casterEntity, consecrationPos, tickIndex);
            }, tickDelay, consecrationId);
        }
        
        // DESYNC SAFE: Schedule consecration cleanup
        this.game.schedulingSystem.scheduleAction(() => {
            this.cleanupConsecration(consecrationId);
        }, this.duration, consecrationId);
        
        // Screen effect for consecration creation
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#ffffaa', 0.5);
        }
    }
    
    // DESYNC SAFE: Execute a single consecration tick deterministically
    executeConsecrationTick(consecrationId, casterEntity, consecrationPos, tickIndex) {
        // Check if consecration entity still exists
        if (!this.game.hasComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT)) {
            return;
        }
        
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterTeam) {
            // Caster died, end consecration early
            this.cleanupConsecration(consecrationId);
            return;
        }
        
        // DESYNC SAFE: Get all units in area deterministically
        const allUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        
        // Sort units for consistent processing order
        const sortedUnits = allUnits.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let undeadDamaged = 0;
        let livingHealed = 0;
        
        sortedUnits.forEach(unitId => {
            const unitPos = this.game.getComponent(unitId, this.componentTypes.POSITION);
            const health = this.game.getComponent(unitId, this.componentTypes.HEALTH);
            const team = this.game.getComponent(unitId, this.componentTypes.TEAM);
            const unitType = this.game.getComponent(unitId, this.componentTypes.UNIT_TYPE);
            
            if (!unitPos || !health || !team || health.current <= 0) return;
            
            // Check if unit is in consecration radius
            const distance = Math.sqrt(
                Math.pow(unitPos.x - consecrationPos.x, 2) + 
                Math.pow(unitPos.z - consecrationPos.z, 2)
            );
            
            if (distance <= this.consecrationRadius) {
                // DESYNC SAFE: Determine if unit is undead/evil deterministically
                const isUndead = this.isUndeadUnit(unitType);
                
                if (isUndead) {
                    // Damage undead/evil units
                    this.dealDamageWithEffects(casterEntity, unitId, this.tickDamage, 'divine', {
                        isConsecration: true,
                        tickIndex: tickIndex
                    });
                    this.createVisualEffect(unitPos, 'purge', { heightOffset: 10 });
                    undeadDamaged++;
                } else if (team.team === casterTeam.team) {
                    // Heal living allies
                    if (health.current < health.max) {
                        const healAmount = Math.min(this.tickHeal, health.max - health.current);
                        health.current += healAmount;
                        
                        this.createVisualEffect(unitPos, 'consecration', { heightOffset: 10 });
                        
                        if (this.game.effectsSystem) {
                            this.game.effectsSystem.showDamageNumber(
                                unitPos.x, unitPos.y + 15, unitPos.z, 
                                healAmount, 'heal'
                            );
                        }
                        livingHealed++;
                    }
                }
            }
        });
        
        // Additional visual effects every few ticks
        if (tickIndex % 3 === 0) {
            this.createVisualEffect(consecrationPos, 'consecration', { 
                count: 8, 
                scaleMultiplier: 2.0,
                heightOffset: 5 
            });
        }
        
   
    }
    
    // DESYNC SAFE: Determine if unit is undead deterministically
    isUndeadUnit(unitType) {
        if (!unitType) return false;
        
        // Check various undead/evil identifiers
        return (
            unitType.id === 'skeleton' ||
            unitType.id === 'zombie' ||
            unitType.id === 'lich' ||
            unitType.id === 'wraith' ||
            unitType.id === 'demon'
        );
    }
    
    // DESYNC SAFE: Get all units in range
    getUnitsInRange(casterEntity, radius) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return [];
        
        const allUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH
        );
        
        return allUnits.filter(unitId => {
            const unitPos = this.game.getComponent(unitId, this.componentTypes.POSITION);
            const health = this.game.getComponent(unitId, this.componentTypes.HEALTH);
            
            if (!unitPos || !health || health.current <= 0) return false;
            
            const distance = Math.sqrt(
                Math.pow(unitPos.x - casterPos.x, 2) + 
                Math.pow(unitPos.z - casterPos.z, 2)
            );
            
            return distance <= radius;
        }).sort((a, b) => String(a).localeCompare(String(b))); // Sort for determinism
    }
    
    // DESYNC SAFE: Clean up consecration
    cleanupConsecration(consecrationId) {
        if (this.game.hasComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT)) {
            // Visual effect for consecration ending
            const consecrationPos = this.game.getComponent(consecrationId, this.componentTypes.POSITION);
            if (consecrationPos) {
                this.createVisualEffect(consecrationPos, 'consecration', { 
                    count: 12, 
                    scaleMultiplier: 1.5,
                    color: 0xffd700 
                });
            }
            
            this.game.destroyEntity(consecrationId);
            
       
        }
    }
};

// ability: CorruptingAuraAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CorruptingAuraAbility'] = class CorruptingAuraAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'corrupting_aura',
            name: 'Corrupting Aura',
            description: 'Emanate dark energy that drains enemies and empowers undead (does not stack)',
            cooldown: 0,
            range: 100,
            manaCost: 0,
            targetType: 'area',
            animation: 'cast',
            priority: 6,
            castTime: 0,
            ...params
        });
        this.drainPerSecond = 8;
        this.duration = 12.0; // 12 seconds instead of 1200 seconds
        this.tickInterval = 1.0; // 1 second between ticks
        this.hasActiveAura = false;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4B0082,
                    colorRange: { start: 0x4B0082, end: 0x000000 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            corruption: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            empowerment: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Only allow one active aura per caster
        return !this.hasActiveAura;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Oathbreaker spreads corrupting darkness!");
        
        // Mark aura as active
        this.hasActiveAura = true;
        
        // DESYNC SAFE: Schedule all aura ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeAuraTick(casterEntity, tickIndex, totalTicks);
            }, tickDelay, casterEntity);
        }
        
        // DESYNC SAFE: Schedule aura cleanup
        this.game.schedulingSystem.scheduleAction(() => {
            this.hasActiveAura = false;
        }, this.duration, casterEntity);
    }
    
    // DESYNC SAFE: Execute a single aura tick deterministically
    executeAuraTick(casterEntity, tickIndex, totalTicks) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {
            // Caster is dead, end the aura early
            this.hasActiveAura = false;
            return;
        }
        
        // DESYNC SAFE: Get enemies and allies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        const allies = this.getAlliesInRange(casterEntity);
        
        // Sort for consistent processing order
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Process enemies - drain their health
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.range) {
                // Apply drain damage
                this.dealDamageWithEffects(casterEntity, enemyId, this.drainPerSecond, 'divine', {
                    isCorruption: true,
                    tickIndex: tickIndex
                });
                
                // Visual corruption effect
                this.createVisualEffect(enemyPos, 'corruption', { heightOffset: 10 });
            }
        });
        
        // Process allies - empower undead
        sortedAllies.forEach(allyId => {
            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            
            if (!unitType || !allyPos) return;
            
            // Check if this is an undead unit
            if (unitType.id === 'skeleton' || unitType.title.includes('undead') || unitType.title.includes('Skeleton')) {
                const distance = Math.sqrt(
                    Math.pow(allyPos.x - casterPos.x, 2) + 
                    Math.pow(allyPos.z - casterPos.z, 2)
                );
                
                if (distance <= this.range) {
                    // Check if already has empowerment buff
                    const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);
                    
                    if (!existingBuff || existingBuff.buffType !== 'dark_empowerment') {
                        const Components = this.game.componentManager.getComponents();
                        this.game.addComponent(allyId, this.componentTypes.BUFF, 
                            Components.Buff('dark_empowerment', { 
                                damageMultiplier: 1.3,
                                attackSpeedMultiplier: 1.2
                            }, this.game.state.now + 3.0, false, 1, this.game.state.now));
                        
                        // Visual empowerment effect
                        this.createVisualEffect(allyPos, 'empowerment', { heightOffset: 5 });
                    }
                }
            }
        });
        
        // Additional visual effects every few ticks
        if (tickIndex % 3 === 0) {
            this.createVisualEffect(casterPos, 'corruption', { 
                count: 6, 
                scaleMultiplier: 2.5,
                heightOffset: 15 
            });
        }
    }
};

// ability: CurseAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CurseAbility'] = class CurseAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'curse',
            name: 'Curse',
            description: 'Curses enemies, reducing their damage and making them vulnerable',
            cooldown: 7.0,
            range: 180,
            manaCost: 50,
            targetType: 'auto',
            animation: 'cast',
            priority: 5,
            castTime: 1.5,
            autoTrigger: 'strong_enemies',
            ...params
        });
        
        this.curseRadius = 100;
        this.damageReduction = 0.5; // Reduce enemy damage by 50%
        this.vulnerabilityIncrease = 1.3; // 30% more damage taken
        this.duration = 20.0;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    colorRange: { start: 0x2F4F4F, end: 0x000000 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.8
                }
            },
            curse: {
                type: 'magic',
                options: {
                    count: 2,
                    color: 0x696969,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Dark magic weakens the enemy forces!`);
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyCurses(casterEntity, enemies);
        }, this.castTime, casterEntity);
    }
    
    applyCurses(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Sort enemies for consistent processing order
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        const cursedEnemies = [];
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            if (!enemyPos || !enemyCombat || !enemyHealth || enemyHealth.current <= 0) return;
            
            // Check if enemy is in curse radius
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.curseRadius) {
                // Apply curse effect visually
                this.createVisualEffect(enemyPos, 'curse');
                
                // DESYNC SAFE: Use buff system instead of directly modifying stats
                const Components = this.game.componentManager.getComponents();
                this.game.addComponent(enemyId, this.componentTypes.BUFF, 
                    Components.Buff('curse', { 
                        damageMultiplier: this.damageReduction,
                        damageTakenMultiplier: this.vulnerabilityIncrease,
                        isCursed: true
                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));
                
                // Create dark aura effect
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.createAuraEffect(
                        enemyPos.x, enemyPos.y, enemyPos.z,
                        'magic',
                        this.duration * 1000
                    );
                }
                
                cursedEnemies.push({
                    id: enemyId,
                    originalDamage: enemyCombat.damage,
                    position: enemyPos
                });
                
                // DESYNC SAFE: Schedule curse removal using scheduling system
                this.game.schedulingSystem.scheduleAction(() => {
                    this.removeCurse(enemyId);
                }, this.duration, enemyId);
            }
        });
        
      
    }
    
    // DESYNC SAFE: Remove curse effect
    removeCurse(enemyId) {
        // Check if enemy still exists and has the curse buff
        if (this.game.hasComponent(enemyId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'curse') {
                this.game.removeComponent(enemyId, this.componentTypes.BUFF);
                
                // Visual effect when curse expires
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (enemyPos) {
                    this.createVisualEffect(enemyPos, 'curse', { 
                        count: 1, 
                        scaleMultiplier: 0.8,
                        color: 0x808080 
                    });
                }
                
            
            }
        }
    }
};

// ability: DisruptionBombAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DisruptionBombAbility'] = class DisruptionBombAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'disruption_bomb',
            name: 'Disruption Bomb',
            description: 'Throw a bomb that disables enemy abilities and equipment (effects do not stack)',
            cooldown: 16.0,
            range: 130,
            manaCost: 40,
            targetType: 'area',
            animation: 'cast',
            priority: 6,
            castTime: 1.3,
            ...params
        });
        
        this.explosionRadius = 90;
        this.disruptionDuration = 12.0;
        this.accuracyReduction = 0.4; // 40% accuracy reduction
        this.movementSlowed = 0.6; // Movement slowed to 60%
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF4500,
                    colorRange: { start: 0xFF4500, end: 0xFF8C00 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.8
                }
            },
            explosion: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0x8A2BE2,
                    colorRange: { start: 0x8A2BE2, end: 0x4B0082 },
                    scaleMultiplier: 2.5,
                    speedMultiplier: 2.0
                }
            },
            disruption: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x9932CC,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        // Only use if there are at least 2 enemies to disrupt
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, `Saboteur prepares a disruption bomb!`);
        
        // DESYNC SAFE: Use scheduling system for bomb throw and explosion
        this.game.schedulingSystem.scheduleAction(() => {
            this.throwDisruptionBomb(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    throwDisruptionBomb(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // DESYNC SAFE: Find best cluster position deterministically
        const clusterPos = this.findBestClusterPosition(enemies, 2);
        const targetPos = clusterPos || pos;
        
        // Visual explosion effect
        this.createVisualEffect(targetPos, 'explosion');
        
        // Screen effects for dramatic explosion
        if (this.game.effectsSystem) {
            this.game.effectsSystem.showExplosionEffect(targetPos.x, targetPos.y, targetPos.z);
            this.game.effectsSystem.playScreenShake(0.4, 2);
            this.game.effectsSystem.playScreenFlash('#8A2BE2', 0.3);
        }
        
        // DESYNC SAFE: Apply disruption effects deterministically
        this.applyDisruptionEffects(casterEntity, enemies, targetPos);
    }
    
    // DESYNC SAFE: Apply disruption effects to enemies in range
    applyDisruptionEffects(casterEntity, enemies, bombPos) {
        // Sort enemies for consistent processing order
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let disruptedCount = 0;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            // Only affect living enemies
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            
            // Check if enemy is in explosion radius
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - bombPos.x, 2) + 
                Math.pow(enemyPos.z - bombPos.z, 2)
            );
            
            if (distance <= this.explosionRadius) {
                // DESYNC SAFE: Check if already disrupted - don't stack disruptions
                const existingBuff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
                
                if (existingBuff && existingBuff.buffType === 'disrupted') {
                    // DESYNC SAFE: Just refresh duration instead of stacking
                    existingBuff.endTime = this.game.state.now + this.disruptionDuration;
                    existingBuff.appliedTime = this.game.state.now;
                } else {
                    // Apply new disruption buff
                    const Components = this.game.componentManager.getComponents();
                    this.game.addComponent(enemyId, this.componentTypes.BUFF, 
                        Components.Buff('disrupted', { 
                            abilitiesDisabled: true,
                            accuracyReduction: this.accuracyReduction,
                            movementSlowed: this.movementSlowed
                        }, this.game.state.now + this.disruptionDuration, false, 1, this.game.state.now));
                    
                    // DESYNC SAFE: Schedule disruption removal
                    this.game.schedulingSystem.scheduleAction(() => {
                        this.removeDisruption(enemyId);
                    }, this.disruptionDuration, enemyId);
                }
                
                // Visual disruption effect on each affected enemy
                this.createVisualEffect(enemyPos, 'disruption');
                
                disruptedCount++;
            }
        });
        
       
    }
    
    // DESYNC SAFE: Find best cluster position deterministically
    findBestClusterPosition(enemies, minCluster = 2) {
        if (enemies.length < minCluster) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let bestPos = null;
        let bestScore = 0;
        
        sortedEnemies.forEach(enemyId => {
            const pos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!pos) return;
            
            // Count nearby enemies within explosion radius
            let nearbyCount = 0;
            sortedEnemies.forEach(otherId => {
                if (otherId === enemyId) return;
                const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);
                if (!otherPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(pos.x - otherPos.x, 2) + 
                    Math.pow(pos.z - otherPos.z, 2)
                );
                
                if (distance <= this.explosionRadius) nearbyCount++;
            });
            
            // Use >= for consistent tie-breaking (first in sorted order wins)
            if (nearbyCount >= minCluster - 1 && nearbyCount >= bestScore) {
                bestScore = nearbyCount;
                bestPos = { x: pos.x, y: pos.y, z: pos.z };
            }
        });
        
        return bestPos;
    }
    
    // DESYNC SAFE: Remove disruption effect
    removeDisruption(enemyId) {
        // Check if enemy still exists and has the disruption buff
        if (this.game.hasComponent(enemyId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'disrupted') {
                this.game.removeComponent(enemyId, this.componentTypes.BUFF);
                
                // Visual effect when disruption expires
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (enemyPos) {
                    this.createVisualEffect(enemyPos, 'disruption', { 
                        count: 3, 
                        scaleMultiplier: 0.8,
                        color: 0x87CEEB 
                    });
                }
                
           
            }
        }
    }
};

// ability: DrainLifeAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DrainLifeAbility'] = class DrainLifeAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'drain_life',
            name: 'Drain Life',
            description: 'Drains health from an enemy and heals the caster',
            cooldown: 4.5,
            range: 200,
            manaCost: 45,
            targetType: 'auto',
            animation: 'cast',
            priority: 7,
            castTime: 1.2,
            autoTrigger: 'low_health',
            ...params
        });
        
        this.drainAmount = 60;
        this.healRatio = 0.8; // Heal 80% of drained health
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x800080,
                    colorRange: { start: 0x800080, end: 0x4B0082 },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            drain: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B008B,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.5
                }
            },
            heal: {
                type: 'heal',
                options: {
                    count: 3,
                    color: 0x9400D3,
                    scaleMultiplier: 1.0,
                    speedMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // Use when injured and enemies are available
        return enemies.length >= 1 && 
               casterHealth && casterHealth.current < casterHealth.max * 0.6;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // DESYNC SAFE: Target selection
        const target = this.findHighestHealthEnemy(enemies);
        if (!target) return;
        
        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
        if (!targetPos) return;
        
        // Immediate effects (visual, audio, logging)
        this.createVisualEffect(casterPos, 'cast');
        
        // Create drain beam effect immediately
        if (this.game.effectsSystem) {
            this.game.effectsSystem.createEnergyBeam(
                new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),
                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),
                {
                    style: { color: 0x8B008B, linewidth: 4 },
                    animation: { duration: 1000, pulseEffect: true }
                }
            );
        }
        
        this.logAbilityUsage(casterEntity, `Dark energy siphons life force!`);
        
        // DESYNC SAFE: Use scheduling system for delayed effect
        this.game.schedulingSystem.scheduleAction(() => {
            const currentTargetPos = this.game.getComponent(target, this.componentTypes.POSITION);
            if (currentTargetPos) {
                this.performDrain(casterEntity, target, currentTargetPos);
            }
        }, this.castTime, casterEntity);
    }
    
    performDrain(casterEntity, targetId, targetPos) {
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || !casterPos || !targetPos) return;
        
        // Apply damage to target
        const result = this.dealDamageWithEffects(casterEntity, targetId, this.drainAmount, this.element, {
            isDrain: true
        });
        
        if (result && result.damage > 0) {
            // Heal caster based on damage dealt
            const healAmount = Math.floor(result.damage * this.healRatio);
            const actualHeal = Math.min(healAmount, casterHealth.max - casterHealth.current);
            casterHealth.current += actualHeal;
            
            // Drain effect on target
            this.createVisualEffect(targetPos, 'drain');
            
            // Heal effect on caster
            if (actualHeal > 0) {
                this.createVisualEffect(casterPos, 'heal');
                
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.showDamageNumber(
                        casterPos.x, casterPos.y + 15, casterPos.z,
                        actualHeal, 'heal'
                    );
                }
            }
        }
    }
    
    // DESYNC SAFE: Deterministic target selection
    findHighestHealthEnemy(enemies) {
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let strongest = null;
        let highestHealth = 0;
        
        sortedEnemies.forEach(enemyId => {
            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            if (health && health.current >= highestHealth) { // Use >= for consistent tie-breaking
                highestHealth = health.current;
                strongest = enemyId;
            }
        });
        
        return strongest;
    }
};

// ability: ExplosiveTrapAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ExplosiveTrapAbility'] = class ExplosiveTrapAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'explosive_trap',
            name: 'Explosive Trap',
            description: 'Place a hidden trap that explodes when enemies approach (max 2 per Trapper)',
            cooldown: 15.0,
            range: 100,
            manaCost: 35,
            targetType: 'ground',
            animation: 'cast',
            priority: 6,
            castTime: 1.5,
            ...params
        });
        
        this.maxTrapsPerTrapper = 2;
        this.trapDamage = 80;
        this.explosionRadius = 100;
        this.triggerRadius = 40;
        this.trapPlacementDistance = 60;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B4513,
                    colorRange: { start: 0x8B4513, end: 0xA0522D },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            trap_place: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x696969,
                    scaleMultiplier: 0.8,
                    speedMultiplier: 1.0
                }
            },
            trap_explosion: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xFF4500,
                    colorRange: { start: 0xFF4500, end: 0xFF8C00 },
                    scaleMultiplier: 2.5,
                    speedMultiplier: 2.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // DESYNC SAFE: Check how many traps this trapper already has active
        const existingTraps = this.game.getEntitiesWith(
            this.componentTypes.TRAP,
            this.componentTypes.POSITION
        );
        
        // Sort traps for consistent processing
        const sortedTraps = existingTraps.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        const myTraps = sortedTraps.filter(trapId => {
            const trap = this.game.getComponent(trapId, this.componentTypes.TRAP);
            return trap && trap.caster === casterEntity && !trap.triggered;
        });
        
        return myTraps.length < this.maxTrapsPerTrapper;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Trapper prepares an explosive surprise!");
        
        // DESYNC SAFE: Use scheduling system for trap placement
        this.game.schedulingSystem.scheduleAction(() => {
            this.placeTrap(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    placeTrap(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // DESYNC SAFE: Calculate trap position deterministically
        const trapPos = this.calculateTrapPosition(casterEntity, pos);
        
        // Create trap entity
        const trapId = this.game.createEntity();
        const Components = this.game.componentManager.getComponents();
        
        // Position component
        this.game.addComponent(trapId, this.componentTypes.POSITION, 
            Components.Position(trapPos.x, trapPos.y, trapPos.z));
        
        // DESYNC SAFE: Trap component with proper game time
        this.game.addComponent(trapId, this.componentTypes.TRAP, 
            Components.Trap(
                this.trapDamage, 
                this.explosionRadius, 
                this.triggerRadius, 
                'physical', 
                casterEntity, 
                false, 
                1
            ));
        
        // Visual indicator (hidden from enemies in actual gameplay)
        this.game.addComponent(trapId, this.componentTypes.RENDERABLE, 
            Components.Renderable("effects", "hidden_trap"));
        
        // DESYNC SAFE: Add lifetime to prevent permanent traps
        this.game.addComponent(trapId, this.componentTypes.LIFETIME, 
            Components.Lifetime(60.0, this.game.state.now)); // 60 second lifetime
        
        // Visual trap placement effect
        this.createVisualEffect(trapPos, 'trap_place');
        
      
        // DESYNC SAFE: Schedule trap cleanup after lifetime
        this.game.schedulingSystem.scheduleAction(() => {
            this.cleanupTrap(trapId);
        }, 60.0, trapId);
    }
    
    // DESYNC SAFE: Calculate trap position deterministically
    calculateTrapPosition(casterEntity, casterPos) {
        // Get facing direction for consistent placement
        const facing = this.game.getComponent(casterEntity, this.componentTypes.FACING) || { angle: 0 };
        
        // Calculate position ahead of caster
        const trapPos = {
            x: casterPos.x + Math.cos(facing.angle) * this.trapPlacementDistance,
            y: casterPos.y,
            z: casterPos.z + Math.sin(facing.angle) * this.trapPlacementDistance
        };
        
        // DESYNC SAFE: Validate position and adjust if needed
        return this.validateTrapPosition(trapPos, casterPos);
    }
    
    // DESYNC SAFE: Validate and adjust trap position if needed
    validateTrapPosition(proposedPos, fallbackPos) {
        // Basic bounds checking
        if (proposedPos.x < -1000 || proposedPos.x > 1000 || 
            proposedPos.z < -1000 || proposedPos.z > 1000) {
            return fallbackPos; // Use caster position as fallback
        }
        
        // Check for existing traps nearby (prevent stacking)
        const existingTraps = this.game.getEntitiesWith(
            this.componentTypes.TRAP,
            this.componentTypes.POSITION
        );
        
        for (const trapId of existingTraps) {
            const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);
            if (trapPos) {
                const distance = Math.sqrt(
                    Math.pow(trapPos.x - proposedPos.x, 2) + 
                    Math.pow(trapPos.z - proposedPos.z, 2)
                );
                
                if (distance < 30) { // Too close to existing trap
                    // Offset the position slightly
                    return {
                        x: proposedPos.x + 20,
                        y: proposedPos.y,
                        z: proposedPos.z + 20
                    };
                }
            }
        }
        
        return proposedPos; // Position is valid
    }
    
    // DESYNC SAFE: Handle trap trigger (called by game systems when enemy approaches)
    triggerTrap(trapId, triggeringEnemyId) {
        const trapComponent = this.game.getComponent(trapId, this.componentTypes.TRAP);
        const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);
        
        if (!trapComponent || !trapPos || trapComponent.triggered) return;
        
        // Mark trap as triggered
        trapComponent.triggered = true;
        trapComponent.triggerCount++;
        
        // Visual explosion effect
        this.createVisualEffect(trapPos, 'trap_explosion');
        
        // Screen effects for dramatic explosion
        if (this.game.effectsSystem) {
            this.game.effectsSystem.showExplosionEffect(trapPos.x, trapPos.y, trapPos.z);
            this.game.effectsSystem.playScreenShake(0.3, 2);
        }
        
        // DESYNC SAFE: Apply explosion damage to all enemies in radius
        this.applyExplosionDamage(trapComponent.caster, trapPos, trapComponent);
        
        // DESYNC SAFE: Schedule trap cleanup after explosion
        this.game.schedulingSystem.scheduleAction(() => {
            this.cleanupTrap(trapId);
        }, 0.5, trapId); // Small delay for explosion effects
    }
    
    // DESYNC SAFE: Apply explosion damage deterministically
    applyExplosionDamage(casterId, explosionPos, trapComponent) {
        // Get all entities that could be damaged
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        
        const casterTeam = this.game.getComponent(casterId, this.componentTypes.TEAM);
        if (!casterTeam) return;
        
        // Sort entities for consistent processing
        const sortedEntities = allEntities.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let damageTargets = [];
        
        sortedEntities.forEach(entityId => {
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            
            if (!entityPos || !entityHealth || !entityTeam || entityHealth.current <= 0) return;
            
            // Don't damage allies
            if (entityTeam.team === casterTeam.team) return;
            
            // Check if in explosion radius
            const distance = Math.sqrt(
                Math.pow(entityPos.x - explosionPos.x, 2) + 
                Math.pow(entityPos.z - explosionPos.z, 2)
            );
            
            if (distance <= trapComponent.radius) {
                damageTargets.push({
                    id: entityId,
                    distance: distance,
                    position: entityPos
                });
            }
        });
        
        // Apply damage to all targets
        damageTargets.forEach(target => {
            // Calculate damage falloff based on distance
            const damageMultiplier = Math.max(0.3, 1.0 - (target.distance / trapComponent.radius));
            const finalDamage = Math.floor(trapComponent.damage * damageMultiplier);
            
            this.dealDamageWithEffects(casterId, target.id, finalDamage, trapComponent.element, {
                isTrap: true,
                isExplosion: true
            });
        });
        
     
    }
    
    // DESYNC SAFE: Clean up trap entity
    cleanupTrap(trapId) {
        if (this.game.hasComponent(trapId, this.componentTypes.TRAP)) {
            // Small visual effect for trap disappearing
            const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);
            if (trapPos) {
                this.createVisualEffect(trapPos, 'trap_place', { 
                    count: 2, 
                    scaleMultiplier: 0.5 
                });
            }
            
            this.game.destroyEntity(trapId);
        }
    }
    
    // Helper method for other systems to check trap count
    getActiveTrapCount(trapperId) {
        const existingTraps = this.game.getEntitiesWith(
            this.componentTypes.TRAP,
            this.componentTypes.POSITION
        );
        
        return existingTraps.filter(trapId => {
            const trap = this.game.getComponent(trapId, this.componentTypes.TRAP);
            return trap && trap.caster === trapperId && !trap.triggered;
        }).length;
    }
};

// ability: IceShardAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['IceShardAbility'] = class IceShardAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'ice_shard',
            name: 'Ice Shard',
            description: 'Fires piercing ice shards that slow enemies',
            cooldown: 2.5,
            range: 280,
            manaCost: 25,
            targetType: 'auto',
            animation: 'cast',
            priority: 5,
            castTime: 0.8,
            autoTrigger: 'enemy_in_range',
            ...params
        });
        
        this.damage = 40;
        this.shardCount = 3;
        this.element = 'cold';
        this.slowDuration = 3.0;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4488ff,
                    colorRange: { start: 0x4488ff, end: 0xaaffff },
                    scaleMultiplier: 1.0,
                    speedMultiplier: 2.0
                }
            },
            shard: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x88bbff,
                    scaleMultiplier: 0.6,
                    speedMultiplier: 3.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Crystalline ice shards pierce the air!`);
        
        // Schedule all shards with staggered timing
        for (let i = 0; i < this.shardCount; i++) {
            const shardDelay = this.castTime + (i * 0.2); // 0.2 second stagger between shards
            
            this.game.schedulingSystem.scheduleAction(() => {
                // Re-get enemies at firing time (some may have died)
                const currentEnemies = this.getEnemiesInRange(casterEntity);
                if (currentEnemies.length > 0) {
                    // DESYNC SAFE: Select target deterministically instead of randomly
                    const target = this.selectDeterministicTarget(currentEnemies, i);
                    if (target) {
                        this.fireIceShard(casterEntity, target);
                    }
                }
            }, shardDelay, casterEntity);
        }
    }
    
    // DESYNC SAFE: Deterministic target selection instead of random
    selectDeterministicTarget(enemies, shardIndex) {
        if (enemies.length === 0) return null;
        
        // Sort enemies deterministically
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Use shard index to cycle through targets deterministically
        const targetIndex = shardIndex % sortedEnemies.length;
        return sortedEnemies[targetIndex];
    }
    
    fireIceShard(casterEntity, targetId) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterPos || !targetPos) return;
        
        // Visual effect at launch
        this.createVisualEffect(casterPos, 'shard');
        
        // Deal damage with slowing effect
        this.dealDamageWithEffects(casterEntity, targetId, this.damage, this.element, {
            isIceShard: true,
            slowDuration: this.slowDuration
        });
        
        // DESYNC SAFE: Use scheduling system for visual effect delay
        this.game.schedulingSystem.scheduleAction(() => {
            const currentTargetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
            if (currentTargetPos) {
                this.createVisualEffect(currentTargetPos, 'shard', { count: 3 });
            }
        }, 0.3, casterEntity);
    }
};

// ability: InfernoAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['InfernoAbility'] = class InfernoAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'inferno',
            name: 'Inferno',
            description: 'Creates a blazing inferno that damages all enemies in a large area',
            cooldown: 8.0,
            range: 200,
            manaCost: 80,
            targetType: 'auto',
            animation: 'cast',
            priority: 9,
            castTime: 2.0,
            autoTrigger: 'multiple_enemies',
            ...params
        });
        
        this.damage = 35;
        this.infernoRadius = 120;
        this.duration = 4.0;
        this.tickInterval = 0.5;
        this.element = 'fire';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff2200,
                    colorRange: { start: 0xff2200, end: 0xffaa00 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            inferno: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff4400,
                    scaleMultiplier: 3.0,
                    speedMultiplier: 0.8
                }
            },
            tick: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff3300,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.6
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Find best cluster position deterministically
        const clusterPos = this.findBestClusterPosition(enemies, 2);
        const infernoCenter = clusterPos || this.getDefaultTargetPosition(casterPos, enemies);
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `The battlefield prepares for an unstoppable inferno!`);
        
        // Schedule the inferno to start after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.createInferno(casterEntity, infernoCenter);
        }, this.castTime, casterEntity);
    }
    
    createInferno(casterEntity, centerPos) {
        // Create initial inferno effect
        this.createVisualEffect(centerPos, 'inferno');
        
        // Screen effect
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#ff3300', 0.4);
        }
        
        this.logAbilityUsage(casterEntity, `The battlefield erupts in an unstoppable inferno!`);
        
        // Schedule damage ticks deterministically
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickNumber = 0; tickNumber < totalTicks; tickNumber++) {
            const tickDelay = tickNumber * this.tickInterval;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.performInfernoTick(casterEntity, centerPos, tickNumber, totalTicks);
            }, tickDelay, casterEntity);
        }
    }
    
    performInfernoTick(casterEntity, centerPos, tickNumber, totalTicks) {
        // Apply damage to all enemies in radius
        if (this.game.damageSystem) {
            const results = this.game.damageSystem.applySplashDamage(
                casterEntity,
                centerPos,
                this.damage,
                this.element,
                this.infernoRadius,
                { allowFriendlyFire: false, isSpell: true }
            );
            
            // Log damage on first and last ticks
            if (tickNumber === 0 && results.length > 0) {
                this.logAbilityUsage(casterEntity, `Inferno burns ${results.length} enemies!`);
            }
        }
        
        // Visual tick effect (except on last tick to avoid overlap)
        if (tickNumber < totalTicks - 1) {
            this.createVisualEffect(centerPos, 'tick');
        }
    }
    
    // FIXED: Deterministic cluster position finding
    findBestClusterPosition(enemies, minTargets) {
        if (enemies.length < minTargets) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let bestPosition = null;
        let maxTargetsHit = 0;
        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance
        
        // Check each enemy position as potential cluster center
        sortedEnemies.forEach(potentialCenter => {
            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);
            if (!centerPos) return;
            
            let targetsInRange = 0;
            let totalDistance = 0;
            
            // Count enemies within inferno radius of this position
            sortedEnemies.forEach(enemyId => {
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (!enemyPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(enemyPos.x - centerPos.x, 2) + 
                    Math.pow(enemyPos.z - centerPos.z, 2)
                );
                
                if (distance <= this.infernoRadius) {
                    targetsInRange++;
                    totalDistance += distance;
                }
            });
            
            // Only consider positions that hit minimum targets
            if (targetsInRange >= minTargets) {
                // Calculate score: prioritize more targets, then lower total distance for tie-breaking
                const score = (targetsInRange * 1000) - totalDistance;
                
                // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)
                if (targetsInRange > maxTargetsHit || 
                    (targetsInRange === maxTargetsHit && score >= bestScore)) {
                    maxTargetsHit = targetsInRange;
                    bestScore = score;
                    bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };
                }
            }
        });
        
        return bestPosition;
    }
    
    // FIXED: Deterministic fallback position when no cluster is found
    getDefaultTargetPosition(casterPos, enemies) {
        if (enemies.length === 0) return casterPos;
        
        // Sort enemies deterministically and pick the first one
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        const firstEnemy = sortedEnemies[0];
        
        const enemyPos = this.game.getComponent(firstEnemy, this.componentTypes.POSITION);
        return enemyPos ? { x: enemyPos.x, y: enemyPos.y, z: enemyPos.z } : casterPos;
    }
};

// ability: FreezingAuraAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['FreezingAuraAbility'] = class FreezingAuraAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'freezing_aura',
            name: 'Freezing Aura',
            description: 'Emanate freezing cold',
            cooldown: 0,
            range: 100,
            manaCost: 0,
            targetType: 'area',
            animation: 'cast',
            priority: 6,
            castTime: 0,
            ...params
        });
        this.drainPerSecond = 8;
        this.duration = 12.0; // 12 seconds instead of 1200 seconds
        this.tickInterval = 1.0; // 1 second between ticks
        this.hasActiveAura = false;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4B0082,
                    colorRange: { start: 0x4B0082, end: 0x000000 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            freezing: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            empowerment: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Only allow one active aura per caster
        return !this.hasActiveAura;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        this.createVisualEffect(pos, 'cast');
        // Mark aura as active
        this.hasActiveAura = true;
        
        // DESYNC SAFE: Schedule all aura ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeAuraTick(casterEntity, tickIndex, totalTicks);
            }, tickDelay, casterEntity);
        }
        
        // DESYNC SAFE: Schedule aura cleanup
        this.game.schedulingSystem.scheduleAction(() => {
            this.hasActiveAura = false;
        }, this.duration, casterEntity);
    }
    
    // DESYNC SAFE: Execute a single aura tick deterministically
    executeAuraTick(casterEntity, tickIndex, totalTicks) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {
            // Caster is dead, end the aura early
            this.hasActiveAura = false;
            return;
        }
        
        // DESYNC SAFE: Get enemies and allies deterministically
        const allies = this.getAlliesInRange(casterEntity);
        
        // Sort for consistent processing order
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));

        
        // Process allies - empower undead
        sortedAllies.forEach(allyId => {
            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            
            if (!unitType || !allyPos) return;
            
            // Check if this is an undead unit
            const distance = Math.sqrt(
                Math.pow(allyPos.x - casterPos.x, 2) + 
                Math.pow(allyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.range) {
                // Check if already has empowerment buff
                const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);
                
                if (!existingBuff || existingBuff.buffType !== 'ice_armor') {
                    const Components = this.game.componentManager.getComponents();
                    this.game.addComponent(allyId, this.componentTypes.BUFF, 
                        Components.Buff('ice_armor', { 
                            armorMultiplier: 1.5
                        }, this.game.state.now + 3.0, false, 1, this.game.state.now));
                    
                    // Visual empowerment effect
                    this.createVisualEffect(allyPos, 'empowerment', { heightOffset: 5 });
                }
            }
            
        });
        
        // Additional visual effects every few ticks
        if (tickIndex % 3 === 0) {
            this.createVisualEffect(casterPos, 'freezing', { 
                count: 6, 
                scaleMultiplier: 2.5,
                heightOffset: 50 
            });
        }
    }
};

// ability: LightningBoltAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['LightningBoltAbility'] = class LightningBoltAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'lightning_bolt',
            name: 'Lightning Bolt',
            description: 'Instantly strikes an enemy with pure lightning',
            cooldown: 2.0,
            range: 350,
            manaCost: 30,
            targetType: 'auto',
            animation: 'cast',
            priority: 7,
            castTime: 0.5,
            autoTrigger: 'enemy_in_range',
            ...params
        });
        
        this.damage = 55;
        this.criticalChance = 0.3; // 30% crit chance
        this.element = 'lightning';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 1,
                    color: 0xffff44,
                    colorRange: { start: 0xffff44, end: 0xffffff },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 4.0
                }
            },
            lightning: {
                type: 'magic',
                options: {
                    count: 2,
                    color: 0xffffaa,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 5.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // DESYNC SAFE: Find target with highest health deterministically
        const target = this.findHighestHealthEnemy(enemies);
        if (!target) return;
        
        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
        if (!targetPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Lightning crackles with divine fury!`, true);
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.strikeLightning(casterEntity, target, targetPos);
        }, this.castTime, casterEntity);
    }
    
    strikeLightning(casterEntity, targetId, targetPos) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Create lightning bolt visual effect
        if (this.game.effectsSystem) {
            this.game.effectsSystem.createLightningBolt(
                new THREE.Vector3(casterPos.x, casterPos.y + 50, casterPos.z),
                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),
                {
                    style: { color: 0xffffaa, linewidth: 6 },
                    animation: { duration: 400, flickerCount: 3 }
                }
            );
        }
        
        // Lightning effect at target
        this.createVisualEffect(targetPos, 'lightning');
        
        // Screen flash
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#ffffaa', 0.15);
        }
        
        // DESYNC SAFE: Determine critical hit deterministically instead of random
        const isCritical = this.isDeterministicCritical(casterEntity, targetId);
        const damage = isCritical ? this.damage * 2 : this.damage;
        
        // Apply lightning damage
        this.dealDamageWithEffects(casterEntity, targetId, damage, this.element, {
            isCritical: isCritical,
            isInstant: true
        });
    }
    
    // DESYNC SAFE: Deterministic critical hit calculation
    isDeterministicCritical(casterId, targetId) {
        // Create a deterministic "random" value based on entity IDs and game time
        const seed = parseInt(casterId) + parseInt(targetId) + Math.floor(this.game.state.now * 100);
        const pseudoRandom = (seed * 9301 + 49297) % 233280 / 233280; // Simple PRNG
        
        return pseudoRandom < this.criticalChance;
    }
    
    // DESYNC SAFE: Deterministic highest health enemy finding
    findHighestHealthEnemy(enemies) {
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let strongest = null;
        let highestHealth = 0;
        
        sortedEnemies.forEach(enemyId => {
            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            if (health && health.current >= highestHealth) { // Use >= for consistent tie-breaking
                highestHealth = health.current;
                strongest = enemyId;
            }
        });
        
        return strongest;
    }
};

// ability: ShadowStrikeAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ShadowStrikeAbility'] = class ShadowStrikeAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'shadow_strike',
            name: 'Shadow Strike',
            description: 'Teleport behind an enemy and deal critical damage',
            cooldown: 9.0,
            range: 120,
            manaCost: 30,
            targetType: 'enemy',
            animation: 'attack',
            priority: 8,
            castTime: 0.5,
            ...params
        });
        this.backstabDamage = 65;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F2F2F,
                    colorRange: { start: 0x2F2F2F, end: 0x000000 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.0
                }
            },
            teleport: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 3.0
                }
            },
            backstab: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0xFF0000,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // DESYNC SAFE: Select target deterministically (closest enemy)
        const target = this.findClosestEnemy(casterEntity, enemies);
        if (!target) return;
        
        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
        if (!targetPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Rogue strikes from the shadows!");
        
        // DESYNC SAFE: Use scheduling system for teleport and attack
        this.game.schedulingSystem.scheduleAction(() => {
            this.performShadowStrike(casterEntity, target);
        }, this.castTime, casterEntity);
    }
    
    // DESYNC SAFE: Find closest enemy deterministically
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closest = null;
        let closestDistance = Infinity;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });
        
        return closest;
    }
    
    performShadowStrike(casterEntity, targetId) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterPos || !targetPos) return;
        
        // DESYNC SAFE: Calculate teleport position deterministically
        const teleportPos = this.calculateTeleportPosition(targetPos);
        
        // Visual effect at original position before teleport
        this.createVisualEffect(casterPos, 'teleport');
        
        // Teleport behind target
        casterPos.x = teleportPos.x;
        casterPos.z = teleportPos.z;
        
        // Visual effect at new position after teleport
        this.createVisualEffect(teleportPos, 'teleport');
        
        // Deal critical backstab damage
        this.dealDamageWithEffects(casterEntity, targetId, this.backstabDamage, 'physical', {
            isCritical: true,
            criticalMultiplier: 2.0,
            isBackstab: true
        });
        
        // Backstab effect
        this.createVisualEffect(targetPos, 'backstab');
        
        // Screen effect for dramatic teleport
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.2, 1.5);
        }
    }
    
    // DESYNC SAFE: Calculate teleport position deterministically
    calculateTeleportPosition(targetPos) {
        // Try positions behind the target in a deterministic order
        const offsets = [
            { x: -25, z: -25 }, // Behind and to the left
            { x: -25, z: 0 },   // Directly behind
            { x: -25, z: 25 },  // Behind and to the right
            { x: 0, z: -25 },   // To the left
            { x: 0, z: 25 },    // To the right
        ];
        
        // Use the first valid position
        for (const offset of offsets) {
            const testPos = {
                x: targetPos.x + offset.x,
                y: targetPos.y,
                z: targetPos.z + offset.z
            };
            
            if (this.isValidTeleportPosition(testPos)) {
                return testPos;
            }
        }
        
        // Fallback position if no valid position found
        return {
            x: targetPos.x - 25,
            y: targetPos.y,
            z: targetPos.z - 25
        };
    }
    
    isValidTeleportPosition(pos) {
        // Basic validation - ensure position is within reasonable bounds
        // This could be enhanced with collision detection if needed
        return pos.x >= -1000 && pos.x <= 1000 && pos.z >= -1000 && pos.z <= 1000;
    }
};

// ability: MindControlAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MindControlAbility'] = class MindControlAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'mind_control',
            name: 'Mind Control',
            description: 'Charms enemy to fight for you',
            cooldown: 5.0,
            range: 190,
            manaCost: 0,
            targetType: 'enemy',
            animation: 'cast',
            priority: 8,
            castTime: 3.0,
            ...params
        });

        // How long control lasts once applied
        this.controlDuration = 5.0;

        // DESYNC SAFE: Track pending controls deterministically
        // Map<targetId, { team, contributors: Set<casterId>, progress: number, startTime: number, scheduledActionId: string }>
        this.pendingControls = new Map();

        // DESYNC SAFE: Track active beams for cleanup
        // Map<targetId, { team, beams: Map<casterId, effectData> }>
        this.beamRegistry = new Map();
    }

    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8A2BE2,
                    colorRange: { start: 0x8A2BE2, end: 0xDDA0DD },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.8
                }
            },
            control: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x9932CC,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 2.0
                }
            },
            charm: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xDA70D6,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.5
                }
            }
        };
    }

    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // Filter out enemies that are already being controlled or targeted
        const validTargets = enemies.filter(enemyId => {
            const enemyTeam = this.game.getComponent(enemyId, this.componentTypes.TEAM);
            const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
            
            if (!enemyTeam || !casterTeam) return false;
            
            // Don't target enemies that are already controlled by our team
            if (enemyTeam.team === casterTeam.team) return false;
            
            // Don't target enemies that are already being mind controlled
            return !this.pendingControls.has(enemyId);
        });
        
        return validTargets.length > 0;
    }

    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!casterPos || !casterTeam) return;

        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        const validTargets = enemies.filter(enemyId => {
            const enemyTeam = this.game.getComponent(enemyId, this.componentTypes.TEAM);
            return enemyTeam && enemyTeam.team !== casterTeam.team && !this.pendingControls.has(enemyId);
        });

        if (validTargets.length === 0) return;

        // DESYNC SAFE: Select target deterministically (closest enemy)
        const target = this.findClosestEnemy(casterEntity, validTargets);
        if (!target) return;

        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `${this.name} begins to dominate an enemy mind!`);

        // DESYNC SAFE: Use scheduling system for mind control process
        this.game.schedulingSystem.scheduleAction(() => {
            this.startMindControl(casterEntity, target);
        }, this.castTime, casterEntity);
    }

    // DESYNC SAFE: Find closest enemy deterministically
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;

        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));

        let closest = null;
        let closestDistance = Infinity;

        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;

            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );

            if (distance < closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });

        return closest;
    }

    // DESYNC SAFE: Start mind control process
    startMindControl(casterId, targetId) {
        const casterTeam = this.game.getComponent(casterId, this.componentTypes.TEAM);
        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterTeam || !targetTeam || !targetPos) return;

        // Check if target is already being controlled
        if (this.pendingControls.has(targetId)) {
            // Add this caster as a contributor to existing control attempt
            const existing = this.pendingControls.get(targetId);
            existing.contributors.add(casterId);
            this.createBeam(casterId, targetId);
            return;
        }

        // Start new mind control attempt
        const controlData = {
            team: casterTeam.team,
            contributors: new Set([casterId]),
            progress: 0,
            startTime: this.game.state.now,
            originalTeam: targetTeam.team
        };

        this.pendingControls.set(targetId, controlData);

        // Create visual beam effect
        this.createBeam(casterId, targetId);

        // Visual effect on target
        this.createVisualEffect(targetPos, 'control');

        // DESYNC SAFE: Schedule the mind control completion check
        const completionTime = 2.0; // 2 seconds to complete mind control
        const actionId = this.game.schedulingSystem.scheduleAction(() => {
            this.completeMindControl(targetId);
        }, completionTime, casterId);

        controlData.scheduledActionId = actionId;
    }

    // DESYNC SAFE: Complete mind control process
    completeMindControl(targetId) {
        const controlData = this.pendingControls.get(targetId);
        if (!controlData) return;

        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!targetTeam || !targetPos) {
            this.cancelMindControl(targetId);
            return;
        }

        // Check if any contributors are still alive and in range
        const validContributors = Array.from(controlData.contributors).filter(casterId => {
            const casterHealth = this.game.getComponent(casterId, this.componentTypes.HEALTH);
            const casterPos = this.game.getComponent(casterId, this.componentTypes.POSITION);
            
            if (!casterHealth || casterHealth.current <= 0 || !casterPos) return false;
            
            const distance = Math.sqrt(
                Math.pow(casterPos.x - targetPos.x, 2) + 
                Math.pow(casterPos.z - targetPos.z, 2)
            );
            
            return distance <= this.range;
        });

        if (validContributors.length === 0) {
            this.cancelMindControl(targetId);
            return;
        }

        // Apply mind control
        this.applyMindControl(targetId, controlData);
    }

    // DESYNC SAFE: Apply mind control effect
    applyMindControl(targetId, controlData) {
        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!targetTeam || !targetPos) return;

        // Change team
        targetTeam.team = controlData.team;

        // Visual charm effect
        this.createVisualEffect(targetPos, 'charm');

       

        // Clean up beams
        this.clearAllBeamsForTarget(targetId);

        // Remove from pending controls
        this.pendingControls.delete(targetId);

        // DESYNC SAFE: Schedule the mind control to expire
        this.game.schedulingSystem.scheduleAction(() => {
            this.expireMindControl(targetId, controlData.originalTeam);
        }, this.controlDuration, null);
    }

    // DESYNC SAFE: Cancel mind control attempt
    cancelMindControl(targetId) {
        const controlData = this.pendingControls.get(targetId);
        if (!controlData) return;

        // Cancel scheduled completion if it exists
        if (controlData.scheduledActionId) {
            this.game.schedulingSystem.cancelAction(controlData.scheduledActionId);
        }

        // Clean up beams
        this.clearAllBeamsForTarget(targetId);

        // Remove from pending controls
        this.pendingControls.delete(targetId);
    }

    // DESYNC SAFE: Expire mind control effect
    expireMindControl(targetId, originalTeam) {
        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!targetTeam) return; // Target might be dead

        // Restore original team
        targetTeam.team = originalTeam;

        // Visual effect for mind control ending
        if (targetPos) {
            this.createVisualEffect(targetPos, 'control', { count: 2 });
        }

    
    }

    // DESYNC SAFE: Create visual beam effect
    createBeam(casterId, targetId) {
        const casterPos = this.game.getComponent(casterId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterPos || !targetPos || !this.game.effectsSystem) return;

        // Create beam using the effects system
        const beamEffect = this.game.effectsSystem.createEnergyBeam(
            new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),
            new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),
            {
                style: { color: 0x8A2BE2, linewidth: 3 },
                animation: { duration: 2000, pulseEffect: true }
            }
        );

        // Track beam for cleanup
        if (!this.beamRegistry.has(targetId)) {
            this.beamRegistry.set(targetId, { beams: new Map() });
        }
        
        this.beamRegistry.get(targetId).beams.set(casterId, beamEffect);
    }

    // DESYNC SAFE: Clear all beams for a target
    clearAllBeamsForTarget(targetId) {
        const entry = this.beamRegistry.get(targetId);
        if (!entry) return;

        // Clean up all beams for this target
        for (const [casterId, beamEffect] of entry.beams.entries()) {
            if (beamEffect && this.game.scene) {
                try {
                    this.game.scene.remove(beamEffect);
                    if (beamEffect.geometry) beamEffect.geometry.dispose();
                    if (beamEffect.material) beamEffect.material.dispose();
                } catch (error) {
                    console.warn('Error cleaning up beam:', error);
                }
            }
        }

        this.beamRegistry.delete(targetId);
    }

    // DESYNC SAFE: Clear specific beam
    clearBeam(casterId, targetId) {
        const entry = this.beamRegistry.get(targetId);
        if (!entry) return;

        const beamEffect = entry.beams.get(casterId);
        if (beamEffect && this.game.scene) {
            try {
                this.game.scene.remove(beamEffect);
                if (beamEffect.geometry) beamEffect.geometry.dispose();
                if (beamEffect.material) beamEffect.material.dispose();
            } catch (error) {
                console.warn('Error cleaning up specific beam:', error);
            }
        }

        entry.beams.delete(casterId);
        
        // If no more beams for this target, remove the entry
        if (entry.beams.size === 0) {
            this.beamRegistry.delete(targetId);
        }
    }

    // DESYNC SAFE: Handle when a caster dies or becomes invalid
    onCasterDeath(casterId) {
        // Remove from all pending controls
        for (const [targetId, controlData] of this.pendingControls.entries()) {
            if (controlData.contributors.has(casterId)) {
                controlData.contributors.delete(casterId);
                
                // Clear the beam for this caster
                this.clearBeam(casterId, targetId);
                
                // If no contributors left, cancel the mind control
                if (controlData.contributors.size === 0) {
                    this.cancelMindControl(targetId);
                }
            }
        }
    }

    // DESYNC SAFE: Handle when a target dies
    onTargetDeath(targetId) {
        // Clean up any pending mind control
        this.cancelMindControl(targetId);
    }

    // DESYNC SAFE: System cleanup
    destroy() {
        // Cancel all pending controls
        for (const [targetId, controlData] of this.pendingControls.entries()) {
            if (controlData.scheduledActionId) {
                this.game.schedulingSystem.cancelAction(controlData.scheduledActionId);
            }
        }
        this.pendingControls.clear();

        // Clean up all beams
        for (const [targetId] of this.beamRegistry.entries()) {
            this.clearAllBeamsForTarget(targetId);
        }
        this.beamRegistry.clear();
    }
};

// ability: SmiteAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SmiteAbility'] = class SmiteAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'smite',
            name: 'Divine Smite',
            description: 'Calls down divine wrath upon the strongest enemy',
            cooldown: 6.0,
            range: 400,
            manaCost: 65,
            targetType: 'auto',
            animation: 'cast',
            priority: 9,
            castTime: 1.8,
            autoTrigger: 'strong_enemy',
            ...params
        });
        
        this.damage = 80;
        this.bonusDamageVsUndead = 2.0; // Double damage vs undead
        this.pillarDelay = 0.5; // Time between pillar and damage
        this.element = 'divine';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFD700,
                    colorRange: { start: 0xFFD700, end: 0xFFFACD },
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.2
                }
            },
            smite: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFF8DC,
                    scaleMultiplier: 3.0,
                    speedMultiplier: 0.8
                }
            },
            pillar: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xF0E68C,
                    scaleMultiplier: 4.0,
                    speedMultiplier: 2.0
                }
            },
            divine_judgment: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFFFE0,
                    scaleMultiplier: 2.5,
                    speedMultiplier: 1.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Target the strongest enemy (highest health) deterministically
        const target = this.findHighestHealthEnemyDeterministic(enemies);
        if (!target) return null;
        
        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
        if (!targetPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Divine judgment descends from the heavens!`);
        
        // Schedule the divine smite after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.performDivineSmite(casterEntity, target, targetPos);
        }, this.castTime, casterEntity);
    }
    
    performDivineSmite(casterEntity, targetId, originalTargetPos) {
        // Get current target position (target may have moved)
        const currentTargetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const targetPos = currentTargetPos || originalTargetPos; // Fallback to original position
        
        // Create pillar of light effect
        this.createVisualEffect(targetPos, 'pillar');
        
        // Create divine judgment aura effect
        this.createVisualEffect(targetPos, 'divine_judgment');
        
        // Screen flash and shake
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#FFD700', 0.5);
            this.game.effectsSystem.playScreenShake(0.3, 3);
        }
        
        this.logAbilityUsage(casterEntity, `A pillar of divine light appears!`);
        
        // Schedule the actual damage after pillar effect
        this.game.schedulingSystem.scheduleAction(() => {
            this.applySmiteDamage(casterEntity, targetId, targetPos);
        }, this.pillarDelay, targetId);
    }
    
    applySmiteDamage(casterEntity, targetId, targetPos) {
        // Validate target still exists
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        if (!targetHealth || targetHealth.current <= 0) {
            this.logAbilityUsage(casterEntity, `Divine judgment finds no target!`);
            return;
        }
        
        // Calculate damage (bonus vs undead)
        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);
        let damage = this.damage;
        let isUndeadTarget = false;
        
        if (targetUnitType && (
            targetUnitType.title.includes('undead') || 
            targetUnitType.title.includes('skeleton') ||
            targetUnitType.title.includes('zombie') ||
            targetUnitType.id.includes('undead')
        )) {
            damage = Math.floor(damage * this.bonusDamageVsUndead);
            isUndeadTarget = true;
        }
        
        // Apply divine damage
        this.dealDamageWithEffects(casterEntity, targetId, damage, this.element, {
            isSmite: true,
            isCritical: true,
            isAntiUndead: isUndeadTarget,
            criticalMultiplier: 1.5
        });
        
        // Create smite impact effect
        this.createVisualEffect(targetPos, 'smite');
      
    
    }
    
    // FIXED: Deterministic highest health enemy selection
    findHighestHealthEnemyDeterministic(enemies) {
        if (enemies.length === 0) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let strongest = null;
        let highestHealth = 0;
        
        // Process enemies in deterministic order
        sortedEnemies.forEach(enemyId => {
            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            if (!health) return;
            
            // Use >= for consistent tie-breaking (first in sorted order wins when health is equal)
            if (health.current >= highestHealth) {
                highestHealth = health.current;
                strongest = enemyId;
            }
        });
        
        return strongest;
    }
    
    // Helper method to check if target is undead (for potential future use)
    isUndeadTarget(targetId) {
        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);
        if (!targetUnitType) return false;
        
        return targetUnitType.title.includes('undead') || 
               targetUnitType.title.includes('skeleton') ||
               targetUnitType.title.includes('zombie') ||
               targetUnitType.id.includes('undead');
    }
    
    // Helper method to get effective damage against target
    getEffectiveDamage(targetId) {
        let damage = this.damage;
        
        if (this.isUndeadTarget(targetId)) {
            damage = Math.floor(damage * this.bonusDamageVsUndead);
        }
        
        return damage;
    }
};

// ability: MultiShotAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MultiShotAbility'] = class MultishotAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'multi_shot',
            name: 'Multi Shot',
            description: 'Fire multiple arrows at different targets',
            cooldown: 7.0,
            range: 180,
            manaCost: 25,
            targetType: 'enemies',
            animation: 'attack',
            priority: 6,
            castTime: 1.0,
            ...params
        });
        
        this.maxTargets = 3;
        this.arrowDamage = 35;
        this.shotInterval = 0.2; // Time between each arrow
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B4513,
                    colorRange: { start: 0x8B4513, end: 0xDEB887 },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            arrow_launch: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xCD853F,
                    scaleMultiplier: 1.0,
                    speedMultiplier: 2.0
                }
            },
            volley: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xF4A460,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Need at least one enemy to shoot at
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Select targets deterministically
        const targets = this.selectMultishotTargets(enemies);
        if (targets.length === 0) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, 
            `Archer prepares to fire ${targets.length} arrows...`);
        
        // Schedule the multishot volley after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.fireMultishotVolley(casterEntity, targets);
        }, this.castTime, casterEntity);
    }
    
    fireMultishotVolley(casterEntity, targets) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Create volley effect
        this.createVisualEffect(casterPos, 'volley');
        
        // Fire arrows at each target with staggered timing
        targets.forEach((targetId, shotIndex) => {
            const shotDelay = shotIndex * this.shotInterval;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.fireSingleArrow(casterEntity, targetId, shotIndex);
            }, shotDelay, casterEntity);
        });
        
        this.logAbilityUsage(casterEntity, 
            `Archer fires volley of ${targets.length} arrows!`);
    }
    
    fireSingleArrow(casterEntity, targetId, shotIndex) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        // Validate target still exists
        if (!casterPos || !targetPos) return;
        
        // Create arrow launch effect
        this.createVisualEffect(casterPos, 'arrow_launch');
        
        // Fire projectile if system is available
        if (this.game.projectileSystem) {
            const projectileData = {
                id: 'arrow',
                title: `Arrow ${shotIndex + 1}`,
                damage: this.arrowDamage,
                speed: 120,
                element: this.element,
                ballistic: true,
                onHit: (hitPos) => {
                    // Impact effect
                    this.createVisualEffect(hitPos, 'arrow_launch', { 
                        count: 3, 
                        scaleMultiplier: 0.8 
                    });
                },
                onTravel: (currentPos) => {
                    // Optional: trail effect during flight
                    if (shotIndex === 0) { // Only show trail on first arrow to avoid spam
                        this.createVisualEffect(currentPos, 'cast', { 
                            count: 1, 
                            scaleMultiplier: 0.5,
                            heightOffset: 0 
                        });
                    }
                }
            };
            
            this.game.projectileSystem.fireProjectile(casterEntity, targetId, projectileData);
        } else {
            // Fallback: direct damage if no projectile system
            this.dealDamageWithEffects(casterEntity, targetId, this.arrowDamage, this.element, {
                isArrow: true,
                isMultishot: true,
                shotIndex: shotIndex
            });
        }
        
    }
    
    // FIXED: Deterministic target selection
    selectMultishotTargets(enemies) {
        if (enemies.length === 0) return [];
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Take up to maxTargets, but prioritize by distance for tactical targeting
        const casterPos = this.game.getComponent(this.getCasterFromContext(), this.componentTypes.POSITION);
        if (!casterPos) {
            // Fallback: just take first N enemies if no caster position
            return sortedEnemies.slice(0, this.maxTargets);
        }
        
        // Calculate distances and sort by distance (closest first), then by ID for tie-breaking
        const enemiesWithDistance = sortedEnemies.map(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            let distance = Infinity;
            
            if (enemyPos) {
                distance = Math.sqrt(
                    Math.pow(enemyPos.x - casterPos.x, 2) + 
                    Math.pow(enemyPos.z - casterPos.z, 2)
                );
            }
            
            return { enemyId, distance };
        });
        
        // Sort by distance first, then by entity ID for deterministic tie-breaking
        enemiesWithDistance.sort((a, b) => {
            if (Math.abs(a.distance - b.distance) < 0.001) { // Nearly equal distances
                return String(a.enemyId).localeCompare(String(b.enemyId));
            }
            return a.distance - b.distance;
        });
        
        // Return up to maxTargets closest enemies
        return enemiesWithDistance
            .slice(0, this.maxTargets)
            .map(item => item.enemyId);
    }
    
    // Helper method to get caster in current context (if needed)
    getCasterFromContext() {
        // This is a fallback - in practice, the caster should be passed to selectMultishotTargets
        // For now, we'll use a simple approach
        return null; // Will trigger the simpler fallback logic
    }
};

// ability: MineGoldAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MineGoldAbility'] = class MineGoldAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, abilityData) {
        super(game, abilityData);
        this.id = 'mineGold';
        this.name = 'Mine Gold';
        this.description = 'Automatically mines gold from gold mines';
        this.isPassive = true;
        this.autocast = true;
        this.enabled = true;
        this.castTime = 0;
        this.cooldown = 0;
        this.priority = 0;
        
        this.goldPerTrip = 10;
        this.miningRange = 25;
        this.depositRange = 25;
        this.miningDuration = 2;
        this.depositDuration = 1;
        this.waitingDistance = 30; // Distance to wait from mine when queued
    }

    canExecute(entityId) {
        if(!this.enabled){
            return false;
        }
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        let miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);
        if (!miningState) {
            const team = this.game.getComponent(entityId, ComponentTypes.TEAM);

            this.game.addComponent(entityId, ComponentTypes.MINING_STATE, {
                state: 'idle',
                targetMineEntityId: null,
                targetMinePosition: null,
                targetTownHall: null,
                waitingPosition: null,
                hasGold: false,
                miningStartTime: 0,
                depositStartTime: 0,
                team: team?.team,
                entityId: entityId
            });
            miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);
        }

        // Autocast behavior: only activate mining if there's NO current command
        const currentCommand = this.game.gameManager.call('getCurrentCommand', entityId);

        // If there's a current command, don't execute mining
        if (currentCommand) {
            return false;
        }

        // No current command - activate mining (autocast)
        // If we were interrupted (controller was changed), reset mining state to idle
        const currentAIController = this.game.aiSystem.getCurrentAIControllerId(entityId);
        if(currentAIController !== ComponentTypes.MINING_STATE){
            // Mining was interrupted, reset state to idle so it can start fresh
            miningState.state = 'idle';
            miningState.targetMineEntityId = null;
            miningState.targetMinePosition = null;
            miningState.targetTownHall = null;
            miningState.waitingPosition = null;
            miningState.miningStartTime = 0;
            miningState.depositStartTime = 0;
            // Note: Keep hasGold if they were carrying gold when interrupted

            let currentMiningStateAI = this.game.aiSystem.getAIControllerData(entityId, ComponentTypes.MINING_STATE);
            this.game.aiSystem.setCurrentAIController(entityId, ComponentTypes.MINING_STATE, currentMiningStateAI);
        }

        return true;
    }

    execute(entityId, targetData) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);
        const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
        const vel = this.game.getComponent(entityId, ComponentTypes.VELOCITY);
        const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
        
        if (!miningState || !pos || !vel || !health || health.current <= 0) {
            this.enabled = false;
            return null;
        }
        this.updateMinerState(entityId, miningState, pos, vel);
        return null;
    }

    updateMinerState(entityId, miningState, pos, vel) {
        miningState.entityId = entityId;
        switch (miningState.state) {
            case 'idle':
                this.findMineTarget(miningState);
                break;
            case 'walking_to_mine':
                this.walkToMine(miningState, pos, vel);
                break;
            case 'waiting_at_mine':
                this.waitAtMine(miningState, pos, vel);
                break;
            case 'mining':
                this.mineGold(miningState);
                break;
            case 'walking_to_hall':
                this.walkToTownHall(miningState, pos, vel);
                break;
            case 'depositing':
                this.depositGold(miningState);
                break;
        }
    }

    findMineTarget(miningState) {
        let closestMine = null;
        let closestDistance = Infinity;
        let closestMineEntityId = null;

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const pos = this.game.getComponent(miningState.entityId, ComponentTypes.POSITION);
        const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);

        if (!pos) return;

        // Get sorted mine entityIds for deterministic iteration
        const sortedMineIds = Array.from(this.game.goldMineSystem.claimedGoldMines.keys()).sort((a, b) =>
            String(a).localeCompare(String(b))
        );

        // Search through all claimed gold mines in deterministic order
        for (const mineEntityId of sortedMineIds) {
            const goldMine = this.game.goldMineSystem.claimedGoldMines.get(mineEntityId);

            // Check if this mine belongs to our team
            if (goldMine.team === miningState.team) {
                // Calculate distance to this mine
                const dx = goldMine.worldPosition.x - pos.x;
                const dz = goldMine.worldPosition.z - pos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestMine = goldMine;
                    closestMineEntityId = mineEntityId;
                }
            }
        }

        if (!closestMine) {
            return;
        }

        miningState.targetMineEntityId = closestMineEntityId;
        miningState.targetMinePosition = {
            x: closestMine.worldPosition.x,
            y: closestMine.worldPosition.y || 0,
            z: closestMine.worldPosition.z
        };
        miningState.state = 'walking_to_mine';

        if (aiState && aiState.targetPosition != miningState.targetMinePosition) {
            aiState.targetPosition = miningState.targetMinePosition;
            aiState.path = [];
            aiState.meta = {};
        }
    }

    findTownHall(miningState) {
        const CT = this.game.componentManager.getComponentTypes();
        const combatUnits = this.game.getEntitiesWith(CT.POSITION, CT.TEAM, CT.UNIT_TYPE);        
        const aiState = this.game.getComponent(miningState.entityId, CT.AI_STATE);
        const pos = this.game.getComponent(miningState.entityId, CT.POSITION);
        
        if (!pos) return;
        
        let closestTownHall = null;
        let closestDistance = Infinity;
    
        for (let i = 0; i < combatUnits.length; i++) {
            const entityId = combatUnits[i];
            const townHallPos = this.game.getComponent(entityId, CT.POSITION);
            const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);
            const team = this.game.getComponent(entityId, CT.TEAM);
        
            if (team.team == miningState.team && unitType.id == "townHall") {
                // Calculate distance to this town hall
                const dx = townHallPos.x - pos.x;
                const dz = townHallPos.z - pos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
            
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestTownHall = { x: townHallPos.x, y: townHallPos.y, z: townHallPos.z };
                }
            }
        }
        
        if (closestTownHall) {
            miningState.targetTownHall = closestTownHall;
            if (aiState) {
                aiState.targetPosition = miningState.targetTownHall;
                aiState.path = [];
                aiState.meta = {};
            }
        }
    }

    walkToMine(miningState, pos, vel) {
        if (!miningState.targetMinePosition || !miningState.targetMineEntityId) {
            this.findMineTarget(miningState);
            if (!miningState.targetMinePosition) {
                miningState.state = 'idle';
                return;
            }
        }

        const mine = this.game.goldMineSystem.claimedGoldMines.get(miningState.targetMineEntityId);
        if (!mine || mine.team !== miningState.team) {
            // Mine no longer exists or changed teams - reset to idle
            miningState.targetMineEntityId = null;
            miningState.targetMinePosition = null;
            miningState.waitingPosition = null;
            miningState.state = 'idle';
            return;
        }

        const dx = miningState.targetMinePosition.x - pos.x;
        const dz = miningState.targetMinePosition.z - pos.z;
        const dist = Math.sqrt(dx * dx + dz * dz);


        if (dist < this.miningRange) {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);
            
            const mineEntityId = miningState.targetMineEntityId;
            const isOccupied = this.game.goldMineSystem.isMineOccupied(mineEntityId);
            const currentOccupant = this.game.goldMineSystem.getCurrentMiner(mineEntityId);

            if (isOccupied && currentOccupant !== miningState.entityId) {
                // Mine is occupied, need to wait
                const queuePosition = this.game.goldMineSystem.getQueuePosition(mineEntityId, miningState.entityId);
                const waitPos = this.getWaitingPosition(miningState.targetMinePosition, queuePosition);
                
                miningState.waitingPosition = waitPos;
                miningState.state = 'waiting_at_mine';

                if (aiState) {
                    aiState.state = 'chasing';
                    aiState.targetPosition = waitPos;
                }
            } else if (!isOccupied) {
                // Mine is free, start mining
                if (aiState) {
                    aiState.state = 'idle';
                    aiState.targetPosition = null;
                }
                pos.x = miningState.targetMinePosition.x;
                pos.z = miningState.targetMinePosition.z;
                vel.vx = 0;
                vel.vz = 0;
                miningState.state = 'mining';
                miningState.miningStartTime = this.game.state.now;
            }
        } else {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);
            
            if (aiState && aiState.targetPosition != miningState.targetMinePosition) {
                aiState.state = 'chasing';
                aiState.targetPosition = miningState.targetMinePosition;        
                aiState.path = [];                        
                aiState.meta = {};
            }
        }
    }

    walkToTownHall(miningState, pos, vel) {
        if (!miningState.targetTownHall) {
            this.findTownHall(miningState);
            if (!miningState.targetTownHall) {
                miningState.state = 'idle';
                return;
            }
        }

        const dx = miningState.targetTownHall.x - pos.x;
        const dz = miningState.targetTownHall.z - pos.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < this.depositRange) {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);
            
            if (aiState) {
                aiState.state = 'idle';
                aiState.targetPosition = null;
            }
            pos.x = miningState.targetTownHall.x - 5;
            pos.z = miningState.targetTownHall.z - 5;
            vel.vx = 0;
            vel.vz = 0;
            miningState.state = 'depositing';
            miningState.depositStartTime = this.game.state.now;
        } else {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);
            
            if (aiState && aiState.targetPosition != miningState.targetTownHall) {
                aiState.state = 'chasing';
                aiState.targetPosition = miningState.targetTownHall;
                aiState.path = [];
                aiState.meta = {};
            }
        }
    }

    waitAtMine(miningState, pos, vel) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);

        // Check if we're next in queue
        const isNextInQueue = this.game.goldMineSystem.isNextInQueue(
            miningState.targetMineEntityId, 
            miningState.entityId
        );
        
        const isMineOccupied = this.game.goldMineSystem.isMineOccupied(miningState.targetMineEntityId);
        
        // If we're next and the mine is free, start mining
        if (isNextInQueue && !isMineOccupied) {
            // The goldMineSystem.processNextInQueue will be called from mineGold when mining completes
            // But we can also transition directly here if we detect we're next
            if (aiState) {
                aiState.state = 'idle';
                aiState.targetPosition = null;
            }
            pos.x = miningState.targetMinePosition.x;
            pos.z = miningState.targetMinePosition.z;
            vel.vx = 0;
            vel.vz = 0;
            
            miningState.state = 'mining';
            miningState.miningStartTime = this.game.state.now;
            miningState.waitingPosition = null;
        } else {
            // Otherwise stay at waiting position
            if (miningState.waitingPosition && aiState && aiState.state !== 'idle') {
                aiState.state = 'idle';
                aiState.targetPosition = null;
                pos.x = miningState.waitingPosition.x;
                pos.z = miningState.waitingPosition.z;
                vel.vx = 0;
                vel.vz = 0;
            }
        }
    }

    getWaitingPosition(minePosition, queuePosition) {
        // Line up miners in a row next to each other
        // Each miner stands 10 units apart
        const spacing = 10;
        const offsetX = queuePosition * spacing;
        
        return {
            x: minePosition.x + this.waitingDistance + offsetX,
            y: minePosition.y,
            z: minePosition.z
        };
    }

    mineGold(miningState) {
        const elapsed = this.game.state.now - miningState.miningStartTime;
        
        if (elapsed >= this.miningDuration) {
            miningState.hasGold = true;
            miningState.goldAmt = 10;

            if(this.game.state.teams){
                let teamState = this.game.state.teams[miningState.team];
                if(teamState && teamState.effects){
                    let teamStateEffects = teamState.effects;
                    if(teamStateEffects['goldPerTrip']){
                        let goldPerTrip = teamStateEffects['goldPerTrip'];
                        if(goldPerTrip && goldPerTrip.value){
                            miningState.goldAmt += goldPerTrip.value;
                        }
                    }
                }
            }
            
            // Change state first, then process queue
            miningState.state = 'walking_to_hall';
            
            // Process next miner in queue now that this mine is free
            if (miningState.targetMineEntityId) {
                this.game.goldMineSystem.processNextInQueue(miningState.targetMineEntityId);
            }
            
            this.findTownHall(miningState);
        }
    }

    depositGold(miningState) {
        const elapsed = this.game.state.now - miningState.depositStartTime;
        
        if (elapsed >= this.depositDuration) {
            this.awardGold(miningState.team, miningState.goldAmt);
            miningState.hasGold = false;
            this.findMineTarget(miningState);
        }
    }

    awardGold(team, goldAmt) {
        if (this.game.isServer) {
            const room = this.game.room;
            for (const [playerId, player] of room.players) {
                if(player.stats.side == team){
                    player.stats.gold += goldAmt;
                    break;
                }
            }
        } else {
            if (team === this.game.state.mySide) {
                this.game.state.playerGold += goldAmt;
            }
        }
    }
    
    logAbilityUsage(entityId) {
        // Passive ability, no logging needed
    }
};

// ability: EnchantWeaponAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['EnchantWeaponAbility'] = class EnchantWeaponAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'enchant_weapon',
            name: 'Enchant Weapon',
            description: 'Enchant ally weapons with elemental damage (does not stack, refreshes duration)',
            cooldown: 12.0,
            range: 100,
            manaCost: 35,
            targetType: 'allies',
            animation: 'cast',
            priority: 5,
            castTime: 1.5,
            ...params
        });
        
        this.elementalDamage = 15;
        this.duration = 30.0; // 30 seconds
        this.availableElements = ['fire', 'cold', 'lightning'];
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFD700,
                    colorRange: { start: 0xFFD700, end: 0xFFA500 },
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.5
                }
            },
            enchant_fire: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF4500,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            },
            enchant_cold: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x00BFFF,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            },
            enchant_lightning: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFFF00,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        // Only use if there are allies to enchant (excluding self)
        return allies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Enchanter begins weaving magical enhancements!`);
        
        // DESYNC SAFE: Use scheduling system for enchantment application
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyWeaponEnchantments(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    applyWeaponEnchantments(casterEntity) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;
        
        // DESYNC SAFE: Get and sort allies deterministically
        const allies = this.getAlliesInRange(casterEntity);
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let enchantedCount = 0;
        
        sortedAllies.forEach((allyId, index) => {
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            const allyHealth = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            
            // Only enchant living allies
            if (!allyPos || !allyHealth || allyHealth.current <= 0) return;
            
            // DESYNC SAFE: Check if already enchanted - don't stack enchantments
            const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);
            
            // DESYNC SAFE: Select element deterministically based on ally index and game time
            const selectedElement = this.selectDeterministicElement(allyId, index);
            
            if (existingBuff && existingBuff.buffType === 'enchant_weapon') {
                // DESYNC SAFE: Refresh duration and update element
                existingBuff.endTime = this.game.state.now + this.duration;
                existingBuff.appliedTime = this.game.state.now;
                existingBuff.modifiers.weaponElement = selectedElement;
            } else {
                // Apply new weapon enchantment
                const Components = this.game.componentManager.getComponents();
                this.game.addComponent(allyId, this.componentTypes.BUFF, 
                    Components.Buff('enchant_weapon', { 
                        weaponElement: selectedElement,
                        elementalDamage: this.elementalDamage,
                        glowing: true
                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));
                
                // DESYNC SAFE: Schedule enchantment removal
                this.game.schedulingSystem.scheduleAction(() => {
                    this.removeEnchantment(allyId);
                }, this.duration, allyId);
            }
            
            // Visual enchantment effect based on element
            this.createVisualEffect(allyPos, `enchant_${selectedElement}`);
            
            enchantedCount++;
        });
        
        // Screen effect for successful enchantment
        if (this.game.effectsSystem && enchantedCount > 0) {
            this.game.effectsSystem.playScreenFlash('#FFD700', 0.4);
        }
        
     
    }
    
    // DESYNC SAFE: Select element deterministically instead of randomly
    selectDeterministicElement(allyId, allyIndex) {
        // Create a deterministic "random" value based on ally ID, game time, and index
        const seed = parseInt(allyId) + Math.floor(this.game.state.now * 100) + allyIndex;
        const pseudoRandom = (seed * 9301 + 49297) % 233280; // Simple PRNG
        const elementIndex = Math.floor((pseudoRandom / 233280) * this.availableElements.length);
        
        return this.availableElements[elementIndex];
    }
    
    // Alternative deterministic selection method (cycle through elements)
    selectCyclicElement(allyIndex) {
        return this.availableElements[allyIndex % this.availableElements.length];
    }
    
    // DESYNC SAFE: Remove enchantment effect
    removeEnchantment(allyId) {
        // Check if ally still exists and has the enchantment buff
        if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'enchant_weapon') {
                const element = buff.modifiers.weaponElement || 'fire';
                
                this.game.removeComponent(allyId, this.componentTypes.BUFF);
                
                // Visual effect when enchantment expires
                const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
                if (allyPos) {
                    this.createVisualEffect(allyPos, `enchant_${element}`, { 
                        count: 3, 
                        scaleMultiplier: 0.6,
                        speedMultiplier: 0.8
                    });
                }
                
              
            }
        }
    }
    
    // Helper method to get enchantment color for UI/effects
    getElementColor(element) {
        switch (element) {
            case 'fire': return 0xFF4500;
            case 'cold': return 0x00BFFF;
            case 'lightning': return 0xFFFF00;
            default: return 0xFFD700;
        }
    }
    
    // Helper method to get element damage type for combat system integration
    getElementDamageType(element) {
        switch (element) {
            case 'fire': return 'fire';
            case 'cold': return 'cold';
            case 'lightning': return 'lightning';
            default: return 'magic';
        }
    }
};

// ability: MirrorImagesAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MirrorImagesAbility'] = class MirrorImagesAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'mirror_images',
            name: 'Mirror Images',
            description: 'Creates 2 weaker illusions of self',
            cooldown: 10.0,
            range: 0, // Self-target
            manaCost: 0,
            targetType: 'self',
            animation: 'cast',
            priority: 6,
            castTime: 1.5,
            autoTrigger: 'low_health',
            ...params
        });
        
        this.imageCount = 2;
        this.imageDuration = 5.0;
        this.imageHealthRatio = 0.4; // 40% of original health
        this.imageDamageRatio = 0.6; // 60% of original damage
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4169E1,
                    colorRange: { start: 0x4169E1, end: 0x87CEEB },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.0
                }
            },
            mirror: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x6495ED,
                    scaleMultiplier: 2.5,
                    speedMultiplier: 1.5
                }
            },
            illusion: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xB0C4DE,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 3.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Use when low on health or facing multiple enemies
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (casterHealth && casterHealth.current < casterHealth.max * 0.5) {
            return true;
        }
        
        const enemies = this.getEnemiesInRange(casterEntity, 150);
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Reality fractures as mirror images appear!`);
        
        // Schedule mirror image creation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.createMirrorImages(casterEntity, casterPos);
        }, this.castTime, casterEntity);
    }
    
    createMirrorImages(casterEntity, casterPos) {
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        const casterUnitType = this.game.getComponent(casterEntity, this.componentTypes.UNIT_TYPE);
        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterCollision = this.game.getComponent(casterEntity, this.componentTypes.COLLISION);
        const casterVelocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);
        
        if (!casterTeam || !casterUnitType || !casterCombat || !casterHealth) return;
        
        // Mirror effect at caster
        this.createVisualEffect(casterPos, 'mirror');
        
        const createdImages = [];
        
        // Create images at deterministic positions
        for (let i = 0; i < this.imageCount; i++) {
            const imagePos = this.getDeterministicImagePosition(casterPos, i);
            
            const imageId = this.createMirrorImage(
                casterEntity, imagePos, casterTeam, casterUnitType, 
                casterCombat, casterHealth, casterCollision, casterVelocity
            );
            
            if (imageId !== null) {
                createdImages.push(imageId);
                // Illusion creation effect
                this.createVisualEffect(imagePos, 'illusion');
                
                // Schedule image removal deterministically
                this.game.schedulingSystem.scheduleAction(() => {
                    this.removeMirrorImage(imageId);
                }, this.imageDuration, imageId);
            }
        }
        
    }
    
    // FIXED: Deterministic positioning algorithm
    getDeterministicImagePosition(casterPos, imageIndex) {
        // Use predefined positions instead of trigonometry for determinism
        const positions = [
            { offsetX: -35, offsetZ: 25 },   // Left-back
            { offsetX: 35, offsetZ: 25 }     // Right-back
        ];
        
        const offset = positions[imageIndex % positions.length];
        
        return {
            x: casterPos.x + offset.offsetX,
            y: casterPos.y,
            z: casterPos.z + offset.offsetZ
        };
    }
    
    createMirrorImage(originalId, imagePos, team, unitType, combat, health, collision, velocity) {
        // Use deterministic entity creation if available, otherwise use standard method
        const imageId = this.game.createEntity ? this.game.createEntity() : this.generateDeterministicId(originalId);
        
        if (imageId === null || imageId === undefined) return null;
        
        const components = this.game.componentManager.getComponents();
        
        try {
            // Add components in deterministic order (alphabetical by component type)
            this.game.addComponent(imageId, this.componentTypes.AI_STATE, 
                components.AIState('idle'));
                
            this.game.addComponent(imageId, this.componentTypes.ANIMATION, 
                components.Animation());
                
            this.game.addComponent(imageId, this.componentTypes.COLLISION, 
                components.Collision(collision?.radius, collision.height));
                
            this.game.addComponent(imageId, this.componentTypes.COMBAT, 
                components.Combat(
                    Math.floor(combat.damage * this.imageDamageRatio),
                    combat.range,
                    combat.attackSpeed,
                    combat.projectile,
                    0,
                    combat.element || 'physical',
                    Math.floor((combat.armor || 0) * 0.5), // Half armor
                    combat.fireResistance || 0,
                    combat.coldResistance || 0,
                    combat.lightningResistance || 0
                ));
                
            this.game.addComponent(imageId, this.componentTypes.EQUIPMENT, 
                components.Equipment());
                
            this.game.addComponent(imageId, this.componentTypes.FACING, 
                components.Facing(0));
                
            this.game.addComponent(imageId, this.componentTypes.HEALTH, 
                components.Health(Math.floor(health.max * this.imageHealthRatio)));
                
            this.game.addComponent(imageId, this.componentTypes.MIRROR_IMAGE, 
                components.MirrorImage(originalId, true, this.game.state.now || 0));
                
            this.game.addComponent(imageId, this.componentTypes.POSITION, 
                components.Position(imagePos.x, imagePos.y, imagePos.z));
                
            this.game.addComponent(imageId, this.componentTypes.RENDERABLE, 
                components.Renderable("units", unitType.id || unitType.title));
                
            this.game.addComponent(imageId, this.componentTypes.TEAM, 
                components.Team(team.team));
                
            this.game.addComponent(imageId, this.componentTypes.UNIT_TYPE, 
                components.UnitType(
                    unitType.id || unitType.title,
                    `Mirror Image`,
                    0 // No value - they're illusions
                ));
                
            this.game.addComponent(imageId, this.componentTypes.VELOCITY, 
                components.Velocity(0, 0, 0, velocity?.maxSpeed || 40));
            
            return imageId;
            
        } catch (error) {
            console.error(`Failed to create mirror image:`, error);
            return null;
        }
    }
    
    // FIXED: Deterministic removal instead of lifetime system
    removeMirrorImage(imageId) {
        if (!this.game.hasEntity || !this.game.hasEntity(imageId)) return;
        
        const imagePos = this.game.getComponent(imageId, this.componentTypes.POSITION);
        
        // Create disappearance effect
        if (imagePos) {
            this.createVisualEffect(imagePos, 'illusion');
        }
        
        // Remove the entity
        if (this.game.removeEntity) {
            this.game.removeEntity(imageId);
        } else if (this.game.destroyEntity) {
            this.game.destroyEntity(imageId);
        }
       
    }
    
    // Fallback method for deterministic ID generation (if needed)
    generateDeterministicId(originalId) {
        // This is a fallback - ideally the game should provide deterministic entity creation
        const timestamp = this.game.state.now || this.game.state.now || 0;
        return `mirror_${originalId}_${Math.floor(timestamp * 1000)}`;
    }
};

// ability: TrackingMark
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['TrackingMark'] = class TrackingMarkAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'tracking_mark',
            name: 'Tracking Mark',
            description: 'Mark an enemy for increased damage - multiple Rangers can mark the same target for stacking effect',
            cooldown: 8.0,
            range: 200,
            manaCost: 20,
            targetType: 'enemy',
            animation: 'cast',
            priority: 7,
            castTime: 1.0,
            ...params
        });
        
        this.markDamageIncrease = 0.25; // 25% per mark
        this.maxMarks = 4; // Cap at 4 marks (100% bonus)
        this.markDuration = 15.0;
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF6347,
                    colorRange: { start: 0xFF6347, end: 0xFF4500 },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            mark_target: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xDC143C,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 2.0
                }
            },
            tracking_beam: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF0000,
                    scaleMultiplier: 1.0,
                    speedMultiplier: 3.0
                }
            },
            mark_stack: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Need at least one enemy to mark
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Select target deterministically
        const target = this.selectMarkTarget(enemies, casterEntity);
        if (!target) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Ranger takes aim at their prey...`);
        
        // Schedule the mark application after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyTrackingMark(casterEntity, target);
        }, this.castTime, casterEntity);
    }
    
    applyTrackingMark(casterEntity, targetId) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        // Validate target still exists
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        if (!targetHealth || targetHealth.current <= 0 || !targetPos) {
            this.logAbilityUsage(casterEntity, `Target has vanished from sight!`);
            return;
        }
        
        // Create marking beam effect if caster still exists
        if (casterPos) {
            this.createTrackingBeamEffect(casterPos, targetPos);
        }
        
        // Apply or stack the tracking mark
        const markResult = this.applyOrStackMark(casterEntity, targetId);
        
        // Create appropriate visual effect based on result
        if (markResult.isNewMark) {
            this.createVisualEffect(targetPos, 'mark_target');
        } else if (markResult.wasStacked) {
            this.createVisualEffect(targetPos, 'mark_stack');
        } else {
            // Mark refreshed
            this.createVisualEffect(targetPos, 'tracking_beam');
        }
        
        // Enhanced logging
        this.logMarkResult(casterEntity, targetId, markResult);
    }
    
    applyOrStackMark(casterEntity, targetId) {
        const Components = this.game.componentManager.getComponents();
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const endTime = currentTime + this.markDuration;
        
        // Check for existing tracking mark
        let existingMark = this.game.getComponent(targetId, this.componentTypes.BUFF);
        
        if (existingMark && existingMark.buffType === 'marked') {
            // Stack the mark up to the maximum
            if (existingMark.stacks < this.maxMarks) {
                existingMark.stacks++;
                existingMark.damageTakenMultiplier = 1 + (this.markDamageIncrease * existingMark.stacks);
                existingMark.endTime = endTime; // Refresh duration
                existingMark.appliedTime = currentTime; // Update applied time
                
                // Track who applied this stack (for potential future features)
                if (!existingMark.appliedBy) {
                    existingMark.appliedBy = [];
                }
                if (!existingMark.appliedBy.includes(casterEntity)) {
                    existingMark.appliedBy.push(casterEntity);
                }
                
                return {
                    isNewMark: false,
                    wasStacked: true,
                    wasRefreshed: false,
                    currentStacks: existingMark.stacks,
                    damageMultiplier: existingMark.damageTakenMultiplier
                };
            } else {
                // Just refresh duration if at max stacks
                existingMark.endTime = endTime;
                existingMark.appliedTime = currentTime;
                
                return {
                    isNewMark: false,
                    wasStacked: false,
                    wasRefreshed: true,
                    currentStacks: existingMark.stacks,
                    damageMultiplier: existingMark.damageTakenMultiplier
                };
            }
        } else {
            // Apply new tracking mark
            this.game.addComponent(targetId, this.componentTypes.BUFF, 
                Components.Buff(
                    'marked', 
                    { 
                        damageTakenMultiplier: 1 + this.markDamageIncrease,
                        revealed: true,
                        markedBy: casterEntity,
                        appliedBy: [casterEntity]
                    }, 
                    endTime,      // End time
                    true,         // Stackable
                    1,            // Initial stack count
                    currentTime   // Applied time
                )
            );
            
            return {
                isNewMark: true,
                wasStacked: false,
                wasRefreshed: false,
                currentStacks: 1,
                damageMultiplier: 1 + this.markDamageIncrease
            };
        }
    }
    
    createTrackingBeamEffect(casterPos, targetPos) {
        // Create a visual connection between ranger and target
        this.createVisualEffect(casterPos, 'tracking_beam');
        this.createVisualEffect(targetPos, 'tracking_beam');
        
        // Create energy beam if effects system supports it
        if (this.game.effectsSystem && this.game.effectsSystem.createEnergyBeam) {
            this.game.effectsSystem.createEnergyBeam(
                new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),
                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),
                {
                    style: { color: 0xFF6347, linewidth: 3 },
                    animation: { duration: 600, flickerCount: 2 }
                }
            );
        }
    }
    
    logMarkResult(casterEntity, targetId, markResult) {
       
        
    }
    
    // FIXED: Deterministic target selection
    selectMarkTarget(enemies, casterEntity) {
        if (enemies.length === 0) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Priority 1: Unmarked enemies (new marks are more valuable)
        const unmarkedEnemies = sortedEnemies.filter(enemyId => {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            return !buff || buff.buffType !== 'marked';
        });
        
        if (unmarkedEnemies.length > 0) {
            // Among unmarked enemies, prioritize by distance (closest first)
            return this.selectClosestEnemy(unmarkedEnemies, casterEntity);
        }
        
        // Priority 2: Marked enemies that can be stacked further
        const stackableEnemies = sortedEnemies.filter(enemyId => {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            return buff && buff.buffType === 'marked' && buff.stacks < this.maxMarks;
        });
        
        if (stackableEnemies.length > 0) {
            // Among stackable enemies, prioritize by current stacks (higher first for focused fire)
            return this.selectHighestStackedEnemy(stackableEnemies);
        }
        
        // Priority 3: Any marked enemy (for duration refresh)
        return this.selectClosestEnemy(sortedEnemies, casterEntity);
    }
    
    selectClosestEnemy(enemies, casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos || enemies.length === 0) return null;
        
        let closest = null;
        let closestDistance = Infinity;
        
        enemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            // Use <= for consistent tie-breaking (first in sorted order wins)
            if (distance <= closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });
        
        return closest;
    }
    
    selectHighestStackedEnemy(enemies) {
        let highestStacked = null;
        let highestStacks = 0;
        
        enemies.forEach(enemyId => {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            if (!buff || buff.buffType !== 'marked') return;
            
            // Use >= for consistent tie-breaking (first in sorted order wins)
            if (buff.stacks >= highestStacks) {
                highestStacks = buff.stacks;
                highestStacked = enemyId;
            }
        });
        
        return highestStacked;
    }
};

// ability: PhalanxFormationAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['PhalanxFormationAbility'] = class PhalanxFormationAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'phalanx_formation',
            name: 'Phalanx Formation',
            description: 'Link with nearby Hoplites - more Hoplites = stronger formation bonus',
            cooldown: 2.0,
            range: 80,
            manaCost: 0,
            targetType: 'allies',
            animation: 'cast',
            priority: 7,
            castTime: 1.2,
            ...params
        });
        
        this.formationDuration = 25.0;
        this.baseArmorMultiplier = 1.15; // 15% base armor bonus
        this.perHopliteBonus = 0.15;     // Additional 15% per hoplite
        this.maxArmorMultiplier = 2.0;   // Cap at 200%
        this.baseCounterChance = 0.2;    // 20% base counter attack chance
        this.perHopliteCounterBonus = 0.05; // +5% per hoplite
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4169E1,
                    colorRange: { start: 0x4169E1, end: 0xB0C4DE },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            formation: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x6495ED,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            phalanx: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x87CEEB,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if caster already has a phalanx buff to prevent re-casting
        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        if (existingBuff && existingBuff.buffType === 'phalanx') return false;
        
        // Must have at least one nearby hoplite ally (not counting self)
        const nearbyHoplites = this.getNearbyHoplites(casterEntity);
        return nearbyHoplites.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterUnitType = this.game.getComponent(casterEntity, this.componentTypes.UNIT_TYPE);
        
        if (!casterPos || !casterUnitType) return null;
        
        const nearbyHoplites = this.getNearbyHoplites(casterEntity);
        if (nearbyHoplites.length === 0) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, 
            `Hoplite begins forming phalanx with ${nearbyHoplites.length} allies...`);
        
        // Schedule the formation creation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.createPhalanxFormation(casterEntity, nearbyHoplites);
        }, this.castTime, casterEntity);
    }
    
    createPhalanxFormation(casterEntity, nearbyHoplites) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Sort hoplites deterministically for consistent processing
        const sortedHoplites = nearbyHoplites.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        const phalanxSize = sortedHoplites.length + 1; // Include caster
        const armorMultiplier = Math.min(
            this.baseArmorMultiplier + (phalanxSize * this.perHopliteBonus), 
            this.maxArmorMultiplier
        );
        const counterAttackChance = this.baseCounterChance + (phalanxSize * this.perHopliteCounterBonus);
        
        // Create formation effect at caster position
        this.createVisualEffect(casterPos, 'formation');
        
        // Apply formation buff to all Hoplites in range (including caster)
        const allHoplites = [casterEntity, ...sortedHoplites];
        let formationSuccess = 0;
        
        // Process hoplites in deterministic order
        allHoplites.forEach((hopliteId, index) => {
            // Validate hoplite still exists and is a hoplite
            const unitType = this.game.getComponent(hopliteId, this.componentTypes.UNIT_TYPE);
            const position = this.game.getComponent(hopliteId, this.componentTypes.POSITION);
            
            if (!unitType || !position || unitType.id !== 'hoplite') return;
            
            // Apply phalanx buff
            const Components = this.game.componentManager.getComponents();
            const currentTime = this.game.state.now || this.game.state.now || 0;
            const endTime = currentTime + this.formationDuration;
            
            this.game.addComponent(hopliteId, this.componentTypes.BUFF, 
                Components.Buff(
                    'phalanx', 
                    { 
                        armorMultiplier: armorMultiplier,
                        counterAttackChance: counterAttackChance,
                        formationSize: phalanxSize,
                        formationLeader: casterEntity,
                        formationRole: (hopliteId === casterEntity) ? 'leader' : 'member'
                    }, 
                    endTime,     // Proper end time
                    false,       // Not stackable
                    1,           // Single stack  
                    currentTime  // Applied time
                )
            );
            
            // Create phalanx effect on each member
            this.createVisualEffect(position, 'phalanx');
            
            // Schedule a delayed formation link effect for visual appeal
            this.game.schedulingSystem.scheduleAction(() => {
                const pos = this.game.getComponent(hopliteId, this.componentTypes.POSITION);
                if (pos) {
                    this.createVisualEffect(pos, 'formation', { 
                        count: 3, 
                        scaleMultiplier: 1.0 
                    });
                }
            }, index * 0.2, hopliteId); // Staggered visual effects
            
            formationSuccess++;
        });
        
        // Screen effects for dramatic formation
        if (this.game.effectsSystem && formationSuccess > 0) {
            this.game.effectsSystem.playScreenFlash('#4169E1', 0.4);
        }
    
      
        
        // Schedule formation expiration warning
        this.game.schedulingSystem.scheduleAction(() => {
            this.warnFormationEnding(allHoplites);
        }, this.formationDuration - 2.0, casterEntity);
    }
    
    // FIXED: Deterministic nearby hoplite detection
    getNearbyHoplites(casterEntity) {
        const allAllies = this.getAlliesInRange(casterEntity);
        
        // Filter and sort hoplites deterministically
        const hoplites = allAllies.filter(allyId => {
            if (allyId === casterEntity) return false; // Exclude self
            
            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);
            return unitType && unitType.id === 'hoplite';
        });
        
        // Sort deterministically for consistent processing
        return hoplites.sort((a, b) => String(a).localeCompare(String(b)));
    }
    
    // FIXED: Formation ending warning
    warnFormationEnding(hopliteIds) {
        let activeFormationMembers = 0;
        
        hopliteIds.forEach(hopliteId => {
            // Check if hoplite still exists and has the phalanx buff
            const buff = this.game.getComponent(hopliteId, this.componentTypes.BUFF);
            const position = this.game.getComponent(hopliteId, this.componentTypes.POSITION);
            
            if (!buff || buff.buffType !== 'phalanx' || !position) return;
            
            // Create warning effect
            this.createVisualEffect(position, 'cast', { 
                count: 3, 
                color: 0x4169E1,
                scaleMultiplier: 0.8 
            });
            
            activeFormationMembers++;
        });
       
    }
};

// ability: SummonWolfAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SummonWolfAbility'] = class SummonWolfAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'summon_wolf',
            name: 'Summon Wolf',
            description: 'Call forth a loyal wolf companion (max 1 per Beast Master)',
            cooldown: 0.0,
            range: 0,
            manaCost: 50,
            targetType: 'self',
            animation: 'cast',
            priority: 5,
            castTime: 1.0,
            ...params
        });
        this.hasSummon = false;
        this.summonId = '0_skeleton';
        this.summonedWolfId = null; // Track the specific summoned wolf
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x228b22,
                    colorRange: { start: 0x228b22, end: 0x90ee90 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.2
                }
            },
            summon: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x32cd32,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if this Beast Master already has a summoned wolf that's still alive
        if (this.summonedWolfId) {
            const wolfHealth = this.game.getComponent(this.summonedWolfId, this.componentTypes.HEALTH);
            const wolfDeathState = this.game.getComponent(this.summonedWolfId, this.componentTypes.DEATH_STATE);
            
            // If wolf is dead or dying, reset our tracking
            if (!wolfHealth || wolfHealth.current <= 0 || (wolfDeathState && wolfDeathState.isDying)) {
                this.hasSummon = false;
                this.summonedWolfId = null;
            }
        }
        
        return !this.hasSummon;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const team = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        if (!pos || !team) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Beast Master summons a faithful wolf!");
        
        // DESYNC SAFE: Use scheduling system for summoning
        this.game.schedulingSystem.scheduleAction(() => {
            this.performSummon(casterEntity, pos, team);
        }, this.castTime, casterEntity);
    }
    
    performSummon(casterEntity, summonPos, team) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // DESYNC SAFE: Find deterministic summon position
        const wolfPosition = this.findSummonPosition(summonPos);
        
        // Create wolf companion
        const wolfId = this.createSummonedCreature(wolfPosition, this.summonId, team.team, casterEntity);
        
        if (wolfId) {
            this.hasSummon = true;
            this.summonedWolfId = wolfId;
            
            // Summon effect at wolf position
            this.createVisualEffect(wolfPosition, 'summon');
            
            // Screen effect for dramatic summoning
            if (this.game.effectsSystem) {
                this.game.effectsSystem.playScreenShake(0.15, 1);
            }
        }
    }
    
    // DESYNC SAFE: Find a valid summon position deterministically
    findSummonPosition(basePos) {
        // Try positions in a deterministic pattern around the caster
        const offsets = [
            { x: 30, z: 0 },    // Right
            { x: -30, z: 0 },   // Left
            { x: 0, z: 30 },    // Forward
            { x: 0, z: -30 },   // Back
            { x: 21, z: 21 },   // Diagonal positions
            { x: -21, z: 21 },
            { x: 21, z: -21 },
            { x: -21, z: -21 }
        ];
        
        // Try each position in order until we find a valid one
        for (const offset of offsets) {
            const testPos = {
                x: basePos.x + offset.x,
                y: basePos.y,
                z: basePos.z + offset.z
            };
            
            // Simple position validation (could be enhanced with collision checking)
            if (this.isValidSummonPosition(testPos)) {
                return testPos;
            }
        }
        
        // Fallback to right side of caster if no valid position found
        return {
            x: basePos.x + 30,
            y: basePos.y,
            z: basePos.z
        };
    }
    
    isValidSummonPosition(pos) {
        // Basic validation - ensure position is within reasonable bounds
        // This could be enhanced with collision detection if needed
        return pos.x >= -1000 && pos.x <= 1000 && pos.z >= -1000 && pos.z <= 1000;
    }
    
    createSummonedCreature(pos, unitDefId, team, summoner) {
        try {
            const creatureId = this.game.createEntity();
            const components = this.game.componentManager.getComponents();
            const componentTypes = this.game.componentManager.getComponentTypes();
            
            // Get unit definition for stats (with fallbacks)
            const collections = this.game.getCollections();
            const unitDef = collections?.units?.[unitDefId] || {
                hp: 60,
                damage: 25,
                range: 30,
                attackSpeed: 1.2,
                speed: 40,
                size: 20
            };
            
            // Add all standard unit components
            this.game.addComponent(creatureId, componentTypes.POSITION, 
                components.Position(pos.x, pos.y, pos.z));
            
            this.game.addComponent(creatureId, componentTypes.VELOCITY, 
                components.Velocity(0, 0, 0, (unitDef.speed) * 20));
            
            this.game.addComponent(creatureId, componentTypes.RENDERABLE, 
                components.Renderable("units", unitDefId));
            
            this.game.addComponent(creatureId, componentTypes.HEALTH, 
                components.Health(unitDef.hp));
            
            this.game.addComponent(creatureId, componentTypes.COMBAT, 
                components.Combat(unitDef.damage, unitDef.range, unitDef.attackSpeed));
            
            this.game.addComponent(creatureId, componentTypes.COLLISION, 
                components.Collision(unitDef.size, unitDef.height));
            
            this.game.addComponent(creatureId, componentTypes.TEAM, 
                components.Team(team));
            
            this.game.addComponent(creatureId, componentTypes.UNIT_TYPE, 
                components.UnitType(unitDefId, 'Summoned Wolf', 0));
            
            this.game.addComponent(creatureId, componentTypes.AI_STATE, 
                components.AIState('idle'));
            
            this.game.addComponent(creatureId, componentTypes.ANIMATION, 
                components.Animation());
            
            this.game.addComponent(creatureId, componentTypes.FACING, 
                components.Facing(0));
            
            // DESYNC SAFE: Use game time for summoned component
            this.game.addComponent(creatureId, componentTypes.SUMMONED, 
                components.Summoned(summoner, unitDefId, null, this.game.state.now || 0));
            
            return creatureId;
        } catch (error) {
            console.error('Failed to create summoned creature:', error);
            return null;
        }
    }
    
    // Helper method to clean up when the summoner dies
    onSummonerDeath(summonerId) {
        if (this.summonedWolfId && this.game.hasComponent(this.summonedWolfId, this.componentTypes.HEALTH)) {
            // Kill the summoned wolf when summoner dies
            const wolfHealth = this.game.getComponent(this.summonedWolfId, this.componentTypes.HEALTH);
            if (wolfHealth && wolfHealth.current > 0) {
                wolfHealth.current = 0;
                
                // Trigger death system for the wolf
                if (this.game.deathSystem) {
                    this.game.deathSystem.handleEntityDeath(this.summonedWolfId);
                }
            }
        }
        
        this.hasSummon = false;
        this.summonedWolfId = null;
    }
};

// ability: Tornado
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['Tornado'] = class CurseAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'curse',
            name: 'Curse',
            description: 'Curses enemies, reducing their damage and making them vulnerable',
            cooldown: 7.0,
            range: 180,
            manaCost: 50,
            targetType: 'auto',
            animation: 'cast',
            priority: 5,
            castTime: 1.5,
            autoTrigger: 'strong_enemies',
            ...params
        });
        
        this.curseRadius = 100;
        this.damageReduction = 0.5; // Reduce enemy damage by 50%
        this.vulnerabilityIncrease = 1.3; // 30% more damage taken
        this.duration = 20.0;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    colorRange: { start: 0x2F4F4F, end: 0x000000 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.8
                }
            },
            curse: {
                type: 'magic',
                options: {
                    count: 2,
                    color: 0x696969,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Cast effect
        this.createVisualEffect(casterPos, 'cast');
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyCurses(casterEntity, enemies);
        }, this.castTime, casterEntity);
    }
    
    applyCurses(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        enemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);
            
            if (!enemyPos || !enemyCombat) return;
            
            // Check if enemy is in curse radius
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.curseRadius) {
                // Apply curse effect
                this.createVisualEffect(enemyPos, 'curse');
                
                // Reduce enemy damage
                const originalDamage = enemyCombat.damage;
                enemyCombat.damage = Math.floor(enemyCombat.damage * this.damageReduction);
                
                // Create dark aura effect
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.createAuraEffect(
                        enemyPos.x, enemyPos.y, enemyPos.z,
                        'magic',
                        this.duration * 1000
                    );
                }
                        
                this.game.schedulingSystem.scheduleAction(() => {
                    if (this.game.getComponent(enemyId, this.componentTypes.COMBAT)) {
                        enemyCombat.damage = originalDamage;
                    }
                }, this.duration, enemyId);

            }
        });
    }
}
;

// ability: WindShieldAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['WindShieldAbility'] = class WindShieldAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'wind_shield',
            name: 'Wind Shield',
            description: 'Creates protective wind barriers that deflect projectiles',
            cooldown: 8.0,
            range: 200,
            manaCost: 60,
            targetType: 'defensive',
            animation: 'cast',
            priority: 4,
            castTime: 1.2,
            autoTrigger: 'projectiles_incoming',
            ...params
        });
        
        this.shieldDuration = 15.0;
        this.deflectionChance = 0.7; // 70% chance to deflect projectiles
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 1,
                    color: 0xE0FFFF,
                    colorRange: { start: 0xE0FFFF, end: 0x87CEEB },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.5
                }
            },
            shield: {
                type: 'magic',
                options: {
                    count: 1,
                    color: 0xAFEEEE,
                    scaleMultiplier: 2.5,
                    speedMultiplier: 1.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        // Use when there are allies to protect and enemies with projectiles nearby
        const enemies = this.getEnemiesInRange(casterEntity, 300);
        return allies.length >= 1 && enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Protective winds swirl around allies!`);
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.createWindShields(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    createWindShields(casterEntity) {
        // DESYNC SAFE: Get and sort allies deterministically
        const allies = this.getAlliesInRange(casterEntity);
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        sortedAllies.forEach(allyId => {
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            if (!allyPos) return;
            // Shield effect
            this.createVisualEffect(allyPos, 'shield');            
            
            // DESYNC SAFE: Add shield component using scheduling system for duration
            const Components = this.game.componentManager.getComponents();
            this.game.addComponent(allyId, this.componentTypes.BUFF, 
                Components.Buff('wind_shield', { 
                    deflectionChance: this.deflectionChance,
                    projectileReflection: true
                }, this.game.state.now + this.shieldDuration, false, 1, this.game.state.now));
            
            // DESYNC SAFE: Schedule shield removal
            this.game.schedulingSystem.scheduleAction(() => {
                if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {
                    const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);
                    if (buff && buff.buffType === 'wind_shield') {
                        this.game.removeComponent(allyId, this.componentTypes.BUFF);
                        
                        // Visual effect when shield expires
                        const currentPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
                        if (currentPos) {
                            this.createVisualEffect(currentPos, 'shield', { 
                                count: 3, 
                                scaleMultiplier: 0.5,
                                color: 0x87CEEB 
                            });
                        }
                    }
                }
            }, this.shieldDuration, allyId);
        });
    }
};

// ability: RageAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['RageAbility'] = class RageAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'raging_strike',
            name: 'Raging Strike',
            description: 'Unleash primal fury with increased damage and attack speed',
            cooldown: 5.0,
            range: 0, // Self-buff
            manaCost: 20,
            targetType: 'self',
            animation: 'attack',
            priority: 6,
            castTime: 0.8,
            ...params
        });
        
        this.rageDuration = 8.0;
        this.damageMultiplier = 1.5;
        this.attackSpeedMultiplier = 1.3;
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: { 
                    count: 3, 
                    color: 0xff4444, 
                    colorRange: { start: 0xff4444, end: 0xff8800 },
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.5
                }
            },
            rage: {
                type: 'magic',
                options: { 
                    count: 3, 
                    color: 0xff0000, 
                    scaleMultiplier: 1.8,
                    speedMultiplier: 2.0
                }
            },
            fury: {
                type: 'magic',
                options: { 
                    count: 3, 
                    color: 0xcc0000, 
                    scaleMultiplier: 2.2,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if there are enemies nearby to rage against
        const enemies = this.getEnemiesInRange(casterEntity, 100);
        if (enemies.length === 0) return false;
        
        // Don't stack rage buffs - check if already raged
        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        if (existingBuff && existingBuff.buffType === 'rage') return false;
        
        return true;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Primal fury begins to build...`);
        
        // Schedule the rage activation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.activateRage(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    activateRage(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Create dramatic rage effects
        this.createVisualEffect(casterPos, 'rage');
        
        // Schedule a secondary fury effect for visual impact
        this.game.schedulingSystem.scheduleAction(() => {
            if (this.game.hasComponent && this.game.hasComponent(casterEntity, this.componentTypes.POSITION)) {
                const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
                if (pos) {
                    this.createVisualEffect(pos, 'fury');
                }
            }
        }, 0.5, casterEntity);
        
        // Apply rage buff with proper timing
        const Components = this.game.componentManager.getComponents();
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const endTime = currentTime + this.rageDuration;
        
        this.game.addComponent(casterEntity, this.componentTypes.BUFF, 
            Components.Buff(
                'rage', 
                { 
                    damageMultiplier: this.damageMultiplier, 
                    attackSpeedMultiplier: this.attackSpeedMultiplier,
                    moveSpeedMultiplier: 1.1 // Slight movement speed bonus
                }, 
                endTime,     // Proper end time
                false,       // Not stackable
                1,           // Single stack
                currentTime  // Applied time
            )
        );
        
        // Screen effects for dramatic impact
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.3, 2);
            this.game.effectsSystem.playScreenFlash('#ff4444', 0.4);
        }
    
        
        // Schedule buff expiration warning
        this.game.schedulingSystem.scheduleAction(() => {
            this.warnRageEnding(casterEntity);
        }, this.rageDuration - 1.0, casterEntity);
    }
    
    // FIXED: Add rage ending warning for better gameplay feedback
    warnRageEnding(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        // Check if entity still exists and has the buff
        const buff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        if (!buff || buff.buffType !== 'rage') return;
        
        if (casterPos) {
            // Create fading effect
            this.createVisualEffect(casterPos, 'cast', { 
                count: 5, 
                color: 0x884444,
                scaleMultiplier: 0.8 
            });
        }
       
    }
};

// ability: PiercingShotAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['PiercingShotAbility'] = class PiercingShotAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'piercing_shot',
            name: 'Piercing Shot',
            description: 'Fire a bolt that pierces through multiple enemies',
            cooldown: 6.0,
            range: 200,
            manaCost: 25,
            targetType: 'line',
            animation: 'attack',
            priority: 6,
            castTime: 1.5,
            ...params
        });
        
        this.piercingDamage = 45;
        this.lineWidth = 20; // Width of the piercing line
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4682B4,
                    colorRange: { start: 0x4682B4, end: 0x87CEEB },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            beam_charge: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x6495ED,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.8
                }
            },
            piercing_beam: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xB0C4DE,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 2.5
                }
            },
            impact: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0x4169E1,
                    scaleMultiplier: 1.0,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Need at least one enemy in range to pierce
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterFacing = this.game.getComponent(casterEntity, this.componentTypes.FACING);
        
        if (!casterPos || !casterFacing) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Crossbow charges a piercing bolt...`);
        
        // Schedule the piercing shot after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.firePiercingShot(casterEntity, casterPos, casterFacing);
        }, this.castTime, casterEntity);
    }
    
    firePiercingShot(casterEntity, casterPos, casterFacing) {
        // Calculate piercing line end position
        const endPos = this.calculateLineEndPosition(casterPos, casterFacing);
        
        // Create beam charging effect
        this.createVisualEffect(casterPos, 'beam_charge');
        
        // Schedule visual beam effect slightly before damage
        this.game.schedulingSystem.scheduleAction(() => {
            this.createPiercingBeamEffect(casterPos, endPos);
        }, 0.2, casterEntity);
        
        // Schedule damage application
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyPiercingDamage(casterEntity, casterPos, endPos);
        }, 0.3, casterEntity);
    }
    
    createPiercingBeamEffect(startPos, endPos) {
        // Create piercing beam visual effect
        this.createVisualEffect(startPos, 'piercing_beam');
        this.createVisualEffect(endPos, 'piercing_beam', { 
            count: 6, 
            scaleMultiplier: 1.5 
        });
        
        // Create energy beam if effects system supports it
        if (this.game.effectsSystem && this.game.effectsSystem.createEnergyBeam) {
            this.game.effectsSystem.createEnergyBeam(
                new THREE.Vector3(startPos.x, startPos.y + 15, startPos.z),
                new THREE.Vector3(endPos.x, endPos.y + 15, endPos.z),
                {
                    style: { color: 0x4682B4, linewidth: 4 },
                    animation: { duration: 800, flickerCount: 2 }
                }
            );
        }
    }
    
    applyPiercingDamage(casterEntity, startPos, endPos) {
        // Get all enemies in range and filter those hit by the line
        const enemies = this.getEnemiesInRange(casterEntity, this.range);
        const hitEnemies = this.getEnemiesInLine(enemies, startPos, endPos);
        
        if (hitEnemies.length === 0) {
            this.logAbilityUsage(casterEntity, `Piercing bolt finds no targets!`);
            return;
        }
        
        // Sort hit enemies by distance along the line for consistent damage application
        const sortedHitEnemies = this.sortEnemiesByDistanceAlongLine(hitEnemies, startPos, endPos);
        
        // Apply damage to each enemy in order
        sortedHitEnemies.forEach((enemyData, index) => {
            const { enemyId, position } = enemyData;
            
            // Apply piercing damage
            this.dealDamageWithEffects(casterEntity, enemyId, this.piercingDamage, this.element, {
                isPiercing: true,
                piercingIndex: index,
                totalPierced: sortedHitEnemies.length
            });
            
            // Create impact effect at each enemy position
            this.createVisualEffect(position, 'impact');
            
         
        });
        
        // Screen effects for dramatic impact
        if (this.game.effectsSystem && sortedHitEnemies.length > 1) {
            this.game.effectsSystem.playScreenShake(0.4, 2);
        }
        
        this.logAbilityUsage(casterEntity, 
            `Crossbow bolt pierces through ${sortedHitEnemies.length} enemies!`);
    }
    
    // FIXED: Deterministic line end position calculation
    calculateLineEndPosition(startPos, facing) {
        return {
            x: startPos.x + Math.cos(facing.angle) * this.range,
            y: startPos.y,
            z: startPos.z + Math.sin(facing.angle) * this.range
        };
    }
    
    // FIXED: Deterministic enemy filtering in line
    getEnemiesInLine(enemies, startPos, endPos) {
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        const hitEnemies = [];
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            if (this.isInLine(startPos, endPos, enemyPos, this.lineWidth)) {
                hitEnemies.push({
                    enemyId: enemyId,
                    position: { x: enemyPos.x, y: enemyPos.y, z: enemyPos.z }
                });
            }
        });
        
        return hitEnemies;
    }
    
    // FIXED: More precise and deterministic line-point distance calculation
    isInLine(start, end, point, width) {
        if (!point) return false;
        
        // Calculate line parameters more precisely
        const lineLength = Math.sqrt(
            Math.pow(end.x - start.x, 2) + Math.pow(end.z - start.z, 2)
        );
        
        if (lineLength < 0.001) return false; // Avoid division by zero
        
        // Calculate perpendicular distance from point to line
        const A = end.z - start.z;
        const B = start.x - end.x;
        const C = end.x * start.z - start.x * end.z;
        
        const distance = Math.abs(A * point.x + B * point.z + C) / Math.sqrt(A * A + B * B);
        
        // Also check if point is within the line segment bounds
        const dotProduct = (point.x - start.x) * (end.x - start.x) + (point.z - start.z) * (end.z - start.z);
        const projectionRatio = dotProduct / (lineLength * lineLength);
        
        // Point must be within line width and within line segment bounds
        return distance <= width && projectionRatio >= 0 && projectionRatio <= 1;
    }
    
    // FIXED: Sort enemies by distance along line for consistent ordering
    sortEnemiesByDistanceAlongLine(hitEnemies, startPos, endPos) {
        return hitEnemies.slice().sort((a, b) => {
            // Calculate distance from start of line for each enemy
            const distanceA = Math.sqrt(
                Math.pow(a.position.x - startPos.x, 2) + 
                Math.pow(a.position.z - startPos.z, 2)
            );
            const distanceB = Math.sqrt(
                Math.pow(b.position.x - startPos.x, 2) + 
                Math.pow(b.position.z - startPos.z, 2)
            );
            
            // Sort by distance from caster, then by entity ID for tie-breaking
            if (Math.abs(distanceA - distanceB) < 0.001) {
                return String(a.enemyId).localeCompare(String(b.enemyId));
            }
            return distanceA - distanceB;
        });
    }
};

// ability: BattleCryAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BattleCryAbility'] = class BattleCryAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'battle_cry',
            name: 'Battle Cry',
            description: 'Rally nearby allies, boosting their damage and morale (does not stack)',
            cooldown: 15.0,
            range: 150,
            manaCost: 40,
            targetType: 'allies',
            animation: 'cast',
            priority: 8,
            castTime: 1.0,
            ...params
        });
        
        this.damageMultiplier = 1.3; // 30% damage boost
        this.duration = 20.0; // 20 seconds
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFD700,
                    colorRange: { start: 0xFFD700, end: 0xFF4500 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 1.5
                }
            },
            rally: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF6347,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        // Only use if there are at least 2 allies to rally (including potentially the caster)
        return allies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        
        // DESYNC SAFE: Use scheduling system for the rally effect
        this.game.schedulingSystem.scheduleAction(() => {
            this.performBattleCry(casterEntity);
        }, this.castTime, casterEntity);
        
        // Log immediately when cast starts
        const allies = this.getAlliesInRange(casterEntity);
        this.logAbilityUsage(casterEntity, `Warlord rallies ${allies.length} allies to battle!`, true);
    }
    
    performBattleCry(casterEntity) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;
        
        // DESYNC SAFE: Get and sort allies deterministically
        const allies = this.getAlliesInRange(casterEntity);
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let ralliedCount = 0;
        
        sortedAllies.forEach(allyId => {
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            const allyHealth = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            
            // Only rally living allies
            if (!allyPos || !allyHealth || allyHealth.current <= 0) return;
            
            // DESYNC SAFE: Check if already rallied - don't stack multiple battle cries
            const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);
            
            if (existingBuff && existingBuff.buffType === 'rallied') {
                // DESYNC SAFE: Refresh duration instead of stacking
                existingBuff.endTime = this.game.state.now + this.duration;
                existingBuff.appliedTime = this.game.state.now; // Update applied time
            } else {
                // Apply new rally buff
                const Components = this.game.componentManager.getComponents();
                this.game.addComponent(allyId, this.componentTypes.BUFF, 
                    Components.Buff('rallied', { 
                        damageMultiplier: this.damageMultiplier, 
                        moralBoost: true, 
                        fearImmunity: true 
                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));
            }
            
            // Visual rally effect on each ally
            this.createVisualEffect(allyPos, 'rally');
            
            // DESYNC SAFE: Schedule buff removal
            this.game.schedulingSystem.scheduleAction(() => {
                this.removeRallyBuff(allyId);
            }, this.duration, allyId);
            
            ralliedCount++;
        });
        
        // Screen effect for dramatic rally
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.3, 2);
            this.game.effectsSystem.playScreenFlash('#FFD700', 0.4);
        }
        
        // Additional visual effect at caster position
        this.createVisualEffect(casterPos, 'rally', { 
            count: 12, 
            scaleMultiplier: 3.0,
            heightOffset: 20 
        });
 
    }
    
    // DESYNC SAFE: Remove rally buff
    removeRallyBuff(allyId) {
        // Check if ally still exists and has the rally buff
        if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'rallied') {
                this.game.removeComponent(allyId, this.componentTypes.BUFF);
                
                // Visual effect when rally expires
                const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
                if (allyPos) {
                    this.createVisualEffect(allyPos, 'rally', { 
                        count: 2, 
                        scaleMultiplier: 0.8,
                        color: 0xCD853F 
                    });
                }
       
            }
        }
    }
};

// ability: ChainLightningAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ChainLightningAbility'] = class ChainLightningAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'chain_lightning',
            name: 'Chain Lightning',
            description: 'Lightning that jumps between multiple enemies',
            cooldown: 4.0,
            range: 250,
            manaCost: 40,
            targetType: 'enemy',
            animation: 'cast',
            priority: 7,
            castTime: 1,
            ...params
        });
        
        this.initialDamage = 60;
        this.maxJumps = 5;
        this.jumpRange = 70;
        this.damageReduction = 0.8;
        this.element = 'lightning';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x00aaff,
                    colorRange: { start: 0x00aaff, end: 0x88aaff },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 2.0
                }
            },
            lightning: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x00ccff,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 3.0
                }
            },
            arc: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x88aaff,
                    scaleMultiplier: 0.8,
                    speedMultiplier: 2.5
                }
            },
            impact: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0x00aaff,
                    scaleMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Initial cast effect
        this.createVisualEffect(casterPos, 'cast');
   
        // DESYNC SAFE: Find closest enemy deterministically
        const firstTarget = this.findClosestEnemy(casterEntity, enemies);
        if (!firstTarget) return;
               
        this.startChainLightning(casterEntity, firstTarget, enemies);
    }
    
    // DESYNC SAFE: Start the chain lightning sequence deterministically
    startChainLightning(sourceId, firstTarget, availableTargets) {
        const hitTargets = []; // Track which targets have been hit
        
        // Process the entire chain synchronously to avoid timing issues
        this.processLightningChain(sourceId, firstTarget, availableTargets, hitTargets, this.maxJumps, this.initialDamage, 0);
    }
    
    // DESYNC SAFE: Process the entire lightning chain deterministically
    processLightningChain(sourceId, currentTarget, availableTargets, hitTargets, remainingJumps, damage, jumpIndex) {
        if (remainingJumps <= 0 || !currentTarget || hitTargets.includes(currentTarget)) {
            return;
        }
        
        const targetPos = this.game.getComponent(currentTarget, this.componentTypes.POSITION);
        if (!targetPos) return;
        
        // Add target to hit list
        hitTargets.push(currentTarget);
        
        // Schedule this jump's effects with a small delay for visual appeal
        const jumpDelay = jumpIndex * 0.15; // 150ms between jumps
        
        this.game.schedulingSystem.scheduleAction(() => {
            // Lightning strike effect
            this.createVisualEffect(targetPos, 'lightning');
            
            // Apply damage
            this.dealDamageWithEffects(sourceId, currentTarget, Math.floor(damage), this.element);
            
            // Screen flash for dramatic effect (only on first hit)
            if (this.game.effectsSystem && jumpIndex === 0) {
                this.game.effectsSystem.playScreenFlash('#00aaff', 0.2);
            }
            
            // Create visual arc effect if there was a previous target
            if (jumpIndex > 0) {
                const previousTarget = hitTargets[jumpIndex - 1];
                const previousPos = this.game.getComponent(previousTarget, this.componentTypes.POSITION);
                if (previousPos) {
                    this.createLightningArc(previousPos, targetPos);
                }
            }
        }, jumpDelay, sourceId);
        
        // DESYNC SAFE: Find next target deterministically
        const nextTarget = this.findNextChainTarget(currentTarget, availableTargets, hitTargets);
        
        if (nextTarget && remainingJumps > 1) {
            // Recursively process the next jump
            this.processLightningChain(
                sourceId, 
                nextTarget, 
                availableTargets, 
                hitTargets, 
                remainingJumps - 1, 
                damage * this.damageReduction, 
                jumpIndex + 1
            );
        }
    }
    
    // DESYNC SAFE: Find closest enemy deterministically
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closest = null;
        let closestDistance = Infinity;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            // Use < for consistent tie-breaking (first in sorted order wins)
            if (distance < closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });
        
        return closest;
    }
    
    // DESYNC SAFE: Find next chain target deterministically
    findNextChainTarget(fromTarget, availableTargets, hitTargets) {
        const fromPos = this.game.getComponent(fromTarget, this.componentTypes.POSITION);
        if (!fromPos) return null;
        
        // Sort targets deterministically first
        const sortedTargets = availableTargets.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closest = null;
        let closestDistance = Infinity;
        
        sortedTargets.forEach(targetId => {
            if (targetId === fromTarget || hitTargets.includes(targetId)) return;
            
            const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
            if (!targetPos) return;
            
            const distance = Math.sqrt(
                Math.pow(targetPos.x - fromPos.x, 2) + 
                Math.pow(targetPos.z - fromPos.z, 2)
            );
            
            // Use < for consistent tie-breaking
            if (distance <= this.jumpRange && distance < closestDistance) {
                closestDistance = distance;
                closest = targetId;
            }
        });
        
        return closest;
    }
    
    createLightningArc(fromPos, toPos) {
        if (!this.game.scene) return;
        
        // Create lightning bolt geometry with deterministic path (no random)
        const points = this.generateDeterministicLightningPath(fromPos, toPos);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        
        // Create lightning material
        const material = new THREE.LineBasicMaterial({
            color: 0x00ddff,
            linewidth: 3,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending
        });
        
        // Create the lightning line
        const lightningLine = new THREE.Line(geometry, material);
        this.game.scene.add(lightningLine);
        
        // Animate the lightning arc
        this.animateLightningArc(lightningLine, material);
        
        // Add bright points at connection points
        this.createLightningPoints(fromPos, toPos);
    }
    
    // DESYNC SAFE: Generate deterministic lightning path (no random)
    generateDeterministicLightningPath(fromPos, toPos) {
        const points = [];
        const segments = 3; // Number of lightning segments
        
        points.push(new THREE.Vector3(
            fromPos.x + (this.game.effectsSystem?.effectOffset?.x || 0),
            fromPos.y + (this.game.effectsSystem?.effectOffset?.y || 0) + 10,
            fromPos.z + (this.game.effectsSystem?.effectOffset?.z || 0)
        ));
        
        // Create jagged lightning path using deterministic values
        for (let i = 1; i < segments; i++) {
            const progress = i / segments;
            
            // Linear interpolation between start and end
            const baseX = fromPos.x + (toPos.x - fromPos.x) * progress;
            const baseY = fromPos.y + (toPos.y - fromPos.y) * progress + 10;
            const baseZ = fromPos.z + (toPos.z - fromPos.z) * progress;
            
            // Add deterministic jagged deviation based on segment index
            const deviation = 15; // Maximum deviation from straight line
            const jaggedX = baseX + (((i * 37) % 100) / 100 - 0.5) * deviation; // Deterministic "random"
            const jaggedY = baseY + (((i * 73) % 100) / 100 - 0.5) * deviation * 0.5;
            const jaggedZ = baseZ + (((i * 91) % 100) / 100 - 0.5) * deviation;
            
            points.push(new THREE.Vector3(
                jaggedX + (this.game.effectsSystem?.effectOffset?.x || 0),
                jaggedY + (this.game.effectsSystem?.effectOffset?.y || 0),
                jaggedZ + (this.game.effectsSystem?.effectOffset?.z || 0)
            ));
        }
        
        points.push(new THREE.Vector3(
            toPos.x + (this.game.effectsSystem?.effectOffset?.x || 0),
            toPos.y + (this.game.effectsSystem?.effectOffset?.y || 0) + 10,
            toPos.z + (this.game.effectsSystem?.effectOffset?.z || 0)
        ));
        
        return points;
    }
    
    animateLightningArc(lightningLine, material) {
        // Use game time for deterministic animation instead of real time
        const startTime = this.game.state.now;
        const animationDuration = 0.48; // 480ms in game time
        const flickerInterval = 0.08; // 80ms in game time
        
        // DESYNC SAFE: Use scheduling system for animation frames
        const animateFrame = (frameIndex) => {
            const currentTime = this.game.state.now;
            const elapsed = currentTime - startTime;
            
            if (elapsed >= animationDuration) {
                // Fade out and remove
                this.fadeLightningArc(lightningLine, material);
                return;
            }
            
            // Deterministic flicker effect based on frame index
            material.opacity = 0.2 + 0.6 * ((frameIndex % 3) / 2); // Cycles between 0.2, 0.5, 0.8
            material.color.setHex((frameIndex % 2) === 0 ? 0x00ddff : 0x88aaff);
            
            // Schedule next frame
            this.game.schedulingSystem.scheduleAction(() => {
                animateFrame(frameIndex + 1);
            }, flickerInterval, null);
        };
        
        animateFrame(0);
    }
    
    fadeLightningArc(lightningLine, material) {
        // Quick cleanup instead of complex fade animation for multiplayer safety
        if (this.game.scene && lightningLine.parent) {
            this.game.scene.remove(lightningLine);
            lightningLine.geometry.dispose();
            lightningLine.material.dispose();
        }
    }
    
    createLightningPoints(fromPos, toPos) {
        // Create bright particle effects at connection points
        if (this.game.effectsSystem) {
            this.game.effectsSystem.createParticleEffect(
                fromPos.x, fromPos.y + 10, fromPos.z, 'magic', {
                    count: 5,
                    color: 0x00ddff,
                    scaleMultiplier: 0.8,
                    speedMultiplier: 2.0,
                    heightOffset: 0
                }
            );
            
            // DESYNC SAFE: Use scheduling system for delayed effect
            this.game.schedulingSystem.scheduleAction(() => {
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.createParticleEffect(
                        toPos.x, toPos.y + 10, toPos.z, 'magic', {
                            count: 5,
                            color: 0x00ddff,
                            scaleMultiplier: 0.8,
                            speedMultiplier: 2.0,
                            heightOffset: 0
                        }
                    );
                }
            }, 0.1, null);
        }
    }
};

// ability: FireBallAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['FireBallAbility'] = class FireballAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'fireBall',
            name: 'Fire Ball',
            description: 'Launch a fiery projectile that explodes on impact',
            cooldown: 5.0,
            range: 150,
            manaCost: 30,
            targetType: 'enemy',
            animation: 'cast',
            priority: 6,
            castTime: 1.5,
            ...params
        });
        
        this.damage = 60;
        this.splashRadius = 80;
        this.element = 'fire';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff4400,
                    colorRange: { start: 0xff4400, end: 0xff8800 },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 0.8
                }
            },
            projectile: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff2200,
                    scaleMultiplier: 0.6,
                    speedMultiplier: 1.5
                }
            },
            explosion: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff4400,
                    colorRange: { start: 0xff4400, end: 0xff0000 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.2
                }
            },
            impact: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0xff0000,
                    scaleMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity, targetData = null) {
        if (!this.game.projectileSystem) return;
        
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        
        // DESYNC SAFE: Find closest enemy deterministically
        const closestEnemy = this.findClosestEnemy(casterEntity, enemies);
        if (!closestEnemy) return;
        
        this.logAbilityUsage(casterEntity, `Fireball launched at enemy target!`, true);
        
        // DESYNC SAFE: Use scheduling system for projectile firing
        this.game.schedulingSystem.scheduleAction(() => {
            this.fireProjectile(casterEntity, closestEnemy);
        }, this.castTime, casterEntity);
    }
    
    // DESYNC SAFE: Deterministic closest enemy finding
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closestEnemy = null;
        let closestDistance = Infinity;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            // Use < for consistent tie-breaking (first in sorted order wins)
            if (distance < closestDistance) {
                closestDistance = distance;
                closestEnemy = enemyId;
            }
        });
        
        return closestEnemy;
    }
    
    fireProjectile(casterEntity, targetId) {
        if (!this.game.projectileSystem) return;
        
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterPos || !targetPos) return;
        
        // Create fireball projectile with enhanced effects
        const projectileData = {
            id: 'fireball',
            title: 'Fireball',
            damage: this.damage,
            speed: 80,
            element: this.element,
            ballistic: true,
            splashRadius: this.splashRadius,
            homing: true,
            homingStrength: 0.3,
            onHit: (impactPos) => {
                // Explosion effect
                this.createVisualEffect(impactPos, 'explosion');
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.playScreenShake(0.3, 2);
                }
                
                // DESYNC SAFE: Handle splash damage deterministically
                this.handleSplashDamage(casterEntity, impactPos);
            },
            onTravel: (currentPos) => {
                // Trail effect during flight
                this.createVisualEffect(currentPos, 'projectile', { heightOffset: 0 });
            }
        };
        
        this.game.projectileSystem.fireProjectile(casterEntity, targetId, projectileData);
    }
    
    // DESYNC SAFE: Handle splash damage deterministically
    handleSplashDamage(casterEntity, impactPos) {
        // Get all entities in splash radius
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        if (!casterTeam) return;
        
        const splashTargets = [];
        
        // Find all valid targets in splash radius
        allEntities.forEach(entityId => {
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            
            if (!entityPos || !entityTeam || entityTeam.team === casterTeam.team) return;
            
            const distance = Math.sqrt(
                Math.pow(entityPos.x - impactPos.x, 2) + 
                Math.pow(entityPos.z - impactPos.z, 2)
            );
            
            if (distance <= this.splashRadius) {
                splashTargets.push({
                    id: entityId,
                    distance: distance,
                    position: entityPos
                });
            }
        });
        
        // DESYNC SAFE: Sort splash targets deterministically
        splashTargets.sort((a, b) => {
            // Primary sort by distance
            if (Math.abs(a.distance - b.distance) > 0.001) {
                return a.distance - b.distance;
            }
            // Secondary sort by entity ID for deterministic tie-breaking
            return String(a.id).localeCompare(String(b.id));
        });
        
        // Apply splash damage to all targets
        splashTargets.forEach(target => {
            // Calculate damage falloff based on distance
            const damageMultiplier = Math.max(0.3, 1.0 - (target.distance / this.splashRadius));
            const splashDamage = Math.floor(this.damage * damageMultiplier);
            
            // Apply damage
            this.dealDamageWithEffects(casterEntity, target.id, splashDamage, this.element, {
                isSplash: true
            });
            
            // Impact effect on each target
            this.createVisualEffect(target.position, 'impact');
        });
    }
};

// ability: FireStormAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['FireStormAbility'] = class FirestormAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'fireStorm',
            name: 'Fire Storm',
            description: 'Rain fire on the largest enemy cluster',
            cooldown: 12.0,
            range: 200,
            manaCost: 50,
            targetType: 'auto',
            animation: 'cast',
            priority: 8,
            castTime: 2.5,
            autoTrigger: 'enemy_cluster',
            ...params
        });
        
        this.stormRadius = 90;
        this.damage = 70;
        this.element = 'fire';
        this.minTargets = 3;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff2200,
                    colorRange: { start: 0xff2200, end: 0xffaa00 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            firestorm: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff4400,
                    colorRange: { start: 0xff4400, end: 0xff0000 },
                    scaleMultiplier: 2.5,
                    speedMultiplier: 0.6
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        const clusterPos = this.findBestClusterPosition(enemies, this.minTargets);
        return clusterPos !== null;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        const clusterPos = this.findBestClusterPosition(enemies, this.minTargets);
        
        if (!clusterPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `The sky darkens as firestorm approaches!`);
        
        // Schedule the firestorm to hit after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.performFirestorm(casterEntity, clusterPos);
        }, this.castTime, casterEntity);
    }
    
    performFirestorm(casterEntity, targetPos) {
        // Create firestorm visual effect
        this.createVisualEffect(targetPos, 'firestorm');
        
        // Apply fire damage to all enemies in storm area
        if (this.game.damageSystem) {
            const results = this.game.damageSystem.applySplashDamage(
                casterEntity,
                targetPos,
                this.damage,
                this.element,
                this.stormRadius,
                { allowFriendlyFire: false, isSpell: true }
            );
            
            this.logAbilityUsage(casterEntity, 
                `Firestorm engulfs ${results.length} enemies in flames!`);
        }
    }
    
    // FIXED: Deterministic cluster position finding
    findBestClusterPosition(enemies, minTargets) {
        if (enemies.length < minTargets) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let bestPosition = null;
        let maxTargetsHit = 0;
        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance
        
        // Check each enemy position as potential cluster center
        sortedEnemies.forEach(potentialCenter => {
            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);
            if (!centerPos) return;
            
            let targetsInRange = 0;
            let totalDistance = 0;
            
            // Count enemies within storm radius of this position
            sortedEnemies.forEach(enemyId => {
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (!enemyPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(enemyPos.x - centerPos.x, 2) + 
                    Math.pow(enemyPos.z - centerPos.z, 2)
                );
                
                if (distance <= this.stormRadius) {
                    targetsInRange++;
                    totalDistance += distance;
                }
            });
            
            // Only consider positions that hit minimum targets
            if (targetsInRange >= minTargets) {
                // Calculate score: prioritize more targets, then lower total distance for tie-breaking
                const score = (targetsInRange * 1000) - totalDistance;
                
                // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)
                if (targetsInRange > maxTargetsHit || 
                    (targetsInRange === maxTargetsHit && score >= bestScore)) {
                    maxTargetsHit = targetsInRange;
                    bestScore = score;
                    bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };
                }
            }
        });
        
        return bestPosition;
    }
};

// ability: HealAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['HealAbility'] = class HealAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'heal',
            name: 'Heal',
            description: 'Restores health to the most injured ally',
            cooldown: 30,
            range: 200,
            manaCost: 40,
            targetType: 'ally',
            animation: 'cast',
            priority: 8,
            castTime: 1.0,
            autoTrigger: 'injured_ally',
            ...params
        });
        
        this.healAmount = 80;
        this.element = 'divine';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 2,
                    color: 0x88ff88,
                    colorRange: { start: 0x88ff88, end: 0xffffaa },
                    scaleMultiplier: 1.0,
                    speedMultiplier: 1.0
                }
            },
            heal: {
                type: 'heal',
                options: {
                    count: 3,
                    color: 0x88ffaa,
                    scaleMultiplier: 1.2,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        return allies.some(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            return health && health.current < health.max; // Ally needs healing
        });
    }
        
    execute(casterEntity, targetData = null) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const allies = this.getAlliesInRange(casterEntity);
        const target = this.findMostInjuredAlly(allies);
        
        if (!target) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Divine light mends wounds!`);
        
    
        this.game.schedulingSystem.scheduleAction(() => {
            const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
            if (targetPos) {
                this.performHeal(casterEntity, target, targetPos);
            }
        }, this.castTime, casterEntity);
    }
    
    performHeal(casterEntity, targetId, targetPos) {
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        if (!targetHealth) return;
        // Heal effect
        this.createVisualEffect(targetPos, 'heal');
        
        // Apply healing
        const actualHeal = Math.min(this.healAmount, targetHealth.max - targetHealth.current);
        targetHealth.current += actualHeal;
        
        // Show heal number
        if (this.game.effectsSystem) {
            this.game.effectsSystem.showDamageNumber(
                targetPos.x, targetPos.y + 50, targetPos.z,
                actualHeal, 'heal'
            );
        }
        
    
    }
        
    findMostInjuredAlly(allies) {
        // Sort allies deterministically first
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let mostInjured = null;
        let lowestHealthRatio = 1.0;
        
        sortedAllies.forEach(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            if (health && health.max > 0) {
                const healthRatio = health.current / health.max;
                // Use <= for consistent tie-breaking (first in sorted order wins)
                if (healthRatio <= lowestHealthRatio) {
                    lowestHealthRatio = healthRatio;
                    mostInjured = allyId;
                }
            }
        });
        
        return mostInjured;
    }
};

// ability: RaiseDeadAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['RaiseDeadAbility'] = class RaiseDeadAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'raise_dead',
            name: 'Raise Dead',
            description: 'Convert corpses into skeleton warriors',
            cooldown: 1.0,
            range: 150,
            manaCost: 0,
            targetType: 'auto',
            animation: 'cast',
            priority: 1,
            castTime: 1.0,
            autoTrigger: 'corpses_available',
            ...params
        });
        
        this.maxCorpsesToRaise = 4;
        this.raisedUnitType = '0_skeleton';
        this.element = 'dark';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4B0082,
                    colorRange: { start: 0x4B0082, end: 0x8B008B },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            raise_dead: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B008B,
                    colorRange: { start: 0x8B008B, end: 0x32CD32 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            },
            necromancy: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x228B22,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        if (!this.game.deathSystem) return false;
        
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return false;
        
        const validCorpses = this.getValidCorpsesInRange(casterPos);
        return validCorpses.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!this.game.deathSystem || !casterPos || !casterTeam) return null;
        
        const validCorpses = this.getValidCorpsesInRange(casterPos);
        if (validCorpses.length === 0) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Dark magic stirs the dead...`);
        
        // Schedule the necromancy after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.performRaiseDeadRitual(casterEntity, validCorpses, casterTeam.team);
        }, this.castTime, casterEntity);
    }
    
    performRaiseDeadRitual(casterEntity, validCorpses, team) {
        const collections = this.game.getCollections();
        if (!collections?.units?.[this.raisedUnitType]) {
            console.warn(`${this.raisedUnitType} unit type not found`);
            return;
        }
        
        const skeletonDef = collections.units[this.raisedUnitType];
        
        // Sort corpses deterministically for consistent processing order
        const sortedCorpses = this.sortCorpsesDeterministically(validCorpses);
        const corpsesToRaise = sortedCorpses.slice(0, this.maxCorpsesToRaise);
        
        let raisedCount = 0;
        const raisedSkeletons = [];
        
        // Process corpses in deterministic order
        corpsesToRaise.forEach((corpseData, index) => {
            const consumedCorpse = this.game.deathSystem.consumeCorpse(corpseData.entityId);
            if (!consumedCorpse) return;
            
            const skeletonId = this.createSkeletonFromCorpse(
                corpseData.position, 
                skeletonDef, 
                team, 
                index
            );
            
            if (skeletonId !== null) {
                raisedCount++;
                raisedSkeletons.push(skeletonId);
                
                // Create raising effect
                this.createVisualEffect(corpseData.position, 'raise_dead');
                this.logCorpseRaising(consumedCorpse, team);
                
                // Schedule a delayed necromancy effect for dramatic flair
                this.game.schedulingSystem.scheduleAction(() => {
                    this.createVisualEffect(corpseData.position, 'necromancy');
                }, 0.5, skeletonId);
            }
        });
        
        if (raisedCount > 0) {
            this.logAbilityUsage(casterEntity, 
                `Necromancy raises ${raisedCount} skeleton${raisedCount > 1 ? 's' : ''} from the dead!`);
                
            // Screen effect for dramatic impact
            if (this.game.effectsSystem) {
                this.game.effectsSystem.playScreenFlash('#4B0082', 0.4);
            }
        }
    }
    
    // FIXED: Deterministic corpse validation and retrieval
    getValidCorpsesInRange(casterPos) {
        const nearbyCorpses = this.game.deathSystem.getCorpsesInRange(casterPos, this.range);
        
        // Filter out corpses that are already the raised unit type (prevent re-raising skeletons)
        const validCorpses = nearbyCorpses.filter(corpseData => {
            return corpseData.corpse.originalUnitType.id !== this.raisedUnitType;
        });
        
        return validCorpses;
    }
    
    // FIXED: Deterministic corpse sorting
    sortCorpsesDeterministically(corpses) {
        return corpses.slice().sort((a, b) => {
            // Sort by entity ID first for primary determinism
            const idComparison = String(a.entityId).localeCompare(String(b.entityId));
            if (idComparison !== 0) return idComparison;
            
            // Secondary sort by position for additional determinism
            if (a.position.x !== b.position.x) {
                return a.position.x - b.position.x;
            }
            if (a.position.z !== b.position.z) {
                return a.position.z - b.position.z;
            }
            
            return 0;
        });
    }
    
    // FIXED: Deterministic skeleton creation with ordered components
    createSkeletonFromCorpse(corpsePos, skeletonDef, team, creationIndex) {
        const skeletonId = this.game.createEntity ? this.game.createEntity() : null;
        if (skeletonId === null || skeletonId === undefined) return null;
        
        const components = this.game.componentManager.getComponents();
        const componentTypes = this.game.componentManager.getComponentTypes();
        
        // FIXED: Deterministic facing based on creation order, not team
        const initialFacing = (creationIndex % 2 === 0) ? 0 : Math.PI;
        
        try {
            // Add components in deterministic alphabetical order
            this.game.addComponent(skeletonId, componentTypes.AI_STATE, 
                components.AIState('idle'));
                
            this.game.addComponent(skeletonId, componentTypes.ANIMATION, 
                components.Animation());
                
            this.game.addComponent(skeletonId, componentTypes.COLLISION, 
                components.Collision(skeletonDef.size, skeletonDef.height));
                
            this.game.addComponent(skeletonId, componentTypes.COMBAT, 
                components.Combat(
                    skeletonDef.damage || 15, 
                    skeletonDef.range || 25, 
                    skeletonDef.attackSpeed || 1.0,
                    skeletonDef.projectile || null, 
                    0, 
                    skeletonDef.element || 'physical',
                    skeletonDef.armor || 0, 
                    skeletonDef.fireResistance || 0,
                    skeletonDef.coldResistance || 0, 
                    skeletonDef.lightningResistance || 0
                ));
                
            this.game.addComponent(skeletonId, componentTypes.EQUIPMENT, 
                components.Equipment());
                
            this.game.addComponent(skeletonId, componentTypes.FACING, 
                components.Facing(initialFacing));
                
            this.game.addComponent(skeletonId, componentTypes.HEALTH, 
                components.Health(skeletonDef.hp || 50));
                
            this.game.addComponent(skeletonId, componentTypes.POSITION, 
                components.Position(corpsePos.x, corpsePos.y, corpsePos.z));
                
            this.game.addComponent(skeletonId, componentTypes.RENDERABLE, 
                components.Renderable("units", this.raisedUnitType));
                
            this.game.addComponent(skeletonId, componentTypes.TEAM, 
                components.Team(team));
                
            this.game.addComponent(skeletonId, componentTypes.UNIT_TYPE, 
                components.UnitType(
                    this.raisedUnitType, 
                    skeletonDef.title || "Skeleton", 
                    skeletonDef.value || 25
                ));
                
            this.game.addComponent(skeletonId, componentTypes.VELOCITY, 
                components.Velocity(0, 0, 0, (skeletonDef.speed || 1) * 20));
            
            return skeletonId;
            
        } catch (error) {
            console.error(`Failed to create skeleton from corpse:`, error);
            return null;
        }
    }
    
    logCorpseRaising(corpse, team) {
       
    }
};

// ability: MassHealAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MassHealAbility'] = class MassHealAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'mass_heal',
            name: 'Mass Heal',
            description: 'Heal all injured allies across the battlefield',
            cooldown: 15.0,
            range: 300,
            manaCost: 60,
            targetType: 'auto',
            animation: 'cast',
            priority: 9,
            castTime: 2.0,
            autoTrigger: 'low_team_health',
            ...params
        });
        
        this.healPercent = 0.4; // 40% of max health
        this.minInjuredAllies = 3;
        this.element = 'divine';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x88ff88,
                    colorRange: { start: 0x88ff88, end: 0xffffaa },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            heal: {
                type: 'heal',
                options: {
                    count: 3,
                    color: 0x88ffaa,
                    scaleMultiplier: 1.2,
                    speedMultiplier: 0.8
                }
            },
            mass_heal: {
                type: 'heal',
                options: {
                    count: 3,
                    color: 0xaaffaa,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.6
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        const injuredAllies = this.getInjuredAllies(allies);
        return injuredAllies.length >= this.minInjuredAllies;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const allies = this.getAlliesInRange(casterEntity);
        const injuredAllies = this.getInjuredAllies(allies);
        
        if (injuredAllies.length < this.minInjuredAllies) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Divine energy gathers to heal the wounded!`);
        
        // Schedule the mass heal to trigger after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.performMassHeal(casterEntity, injuredAllies);
        }, this.castTime, casterEntity);
    }
    
    performMassHeal(casterEntity, targetAllies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        let healedCount = 0;
        let totalHealing = 0;
        
        // Sort allies deterministically for consistent processing order
        const sortedAllies = targetAllies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Process each ally deterministically
        sortedAllies.forEach(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            
            if (!health || !allyPos) return;
            
            // Only heal if ally is still injured
            if (health.current < health.max) {
                const healAmount = Math.floor(health.max * this.healPercent);
                const actualHeal = Math.min(healAmount, health.max - health.current);
                
                if (actualHeal > 0) {
                    // Apply healing
                    health.current += actualHeal;
                    healedCount++;
                    totalHealing += actualHeal;
                    
                    // Create heal effect on each ally
                    this.createVisualEffect(allyPos, 'heal');
                    
                    // Show heal number
                    if (this.game.effectsSystem) {
                        this.game.effectsSystem.showDamageNumber(
                            allyPos.x, allyPos.y + 50, allyPos.z,
                            actualHeal, 'heal'
                        );
                    }
                
                }
            }
        });
        
        // Create major healing effect at caster position
        if (casterPos && healedCount > 0) {
            this.createVisualEffect(casterPos, 'mass_heal');
        }
        
        // Screen effect for dramatic impact
        if (this.game.effectsSystem && healedCount > 0) {
            this.game.effectsSystem.playScreenFlash('#88ff88', 0.3);
        }
        
        // Log final results
        this.logAbilityUsage(casterEntity, 
            `Mass heal restores ${healedCount} allies for ${totalHealing} total health!`);
    }
    
    // FIXED: Deterministic injured ally detection
    getInjuredAllies(allies) {
        // Sort allies deterministically first for consistent processing
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        return sortedAllies.filter(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            // Check if ally is injured (below 80% health threshold)
            return health && health.current < health.max * 0.8;
        });
    }
    
    // Helper method to get all valid heal targets (for future use)
    getAllHealTargets(allies) {
        // Sort allies deterministically first for consistent processing
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        return sortedAllies.filter(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            // Any ally that isn't at full health
            return health && health.current < health.max;
        });
    }
};

// ability: MeteorStrikeAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MeteorStrikeAbility'] = class MeteorStrikeAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'meteor_strike',
            name: 'Meteor Strike',
            description: 'Devastating strike on the densest enemy formation',
            cooldown: 5.0,
            range: 300,
            manaCost: 0,
            targetType: 'enemies',
            animation: 'cast',
            priority: 10,
            castTime: 1.0,
            ...params
        });
        
        this.damage = 200;
        this.splashRadius = 120;
        this.delay = 3.0;
        this.element = 'fire';
        this.minTargets = 0;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff4400,
                    colorRange: { start: 0xff4400, end: 0xffaa00 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            },
            warning: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff0000,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            meteor_explosion: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff2200,
                    colorRange: { start: 0xff2200, end: 0xffaa00 },
                    scaleMultiplier: 4.0,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);        
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        const targetPos = this.findBestClusterPosition(enemies, this.minTargets);
        
        if (!targetPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `A massive meteor approaches from the heavens!`);
        
        // Schedule warning indicator after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.createMeteorWarning(targetPos);
        }, this.castTime, casterEntity);
        
        // Schedule meteor impact after cast time + delay
        this.game.schedulingSystem.scheduleAction(() => {
            this.meteorImpact(casterEntity, targetPos);
        }, this.castTime + this.delay, casterEntity);
    }
    
    createMeteorWarning(position) {
        // Create warning effect instead of entity for better desync safety
        this.createVisualEffect(position, 'warning');
        
        // Schedule repeated warning effects during the delay period
        const warningInterval = 0.5;
        const warningCount = Math.floor(this.delay / warningInterval);
        
        for (let i = 1; i < warningCount; i++) {
            this.game.schedulingSystem.scheduleAction(() => {
                this.createVisualEffect(position, 'warning');
            }, i * warningInterval, null);
        }
        
        this.logAbilityUsage(null, `The ground trembles as a meteor approaches!`);
    }
    
    meteorImpact(casterEntity, position) {
        // Create massive explosion effect
        this.createVisualEffect(position, 'meteor_explosion');
        
        // Screen effects for dramatic impact
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.8, 4);
            this.game.effectsSystem.playScreenFlash('#ff4400', 0.5);
        }
        
        // Apply splash damage
        if (this.game.damageSystem) {
            const results = this.game.damageSystem.applySplashDamage(
                casterEntity,
                position,
                this.damage,
                this.element,
                this.splashRadius,
                { allowFriendlyFire: false, isSpell: true }
            );
         
        }
    }
    
    // FIXED: Deterministic cluster position finding
    findBestClusterPosition(enemies, minTargets) {
        if (enemies.length === 0) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let bestPosition = null;
        let maxTargetsHit = 0;
        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance
        
        // Check each enemy position as potential impact center
        sortedEnemies.forEach(potentialCenter => {
            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);
            if (!centerPos) return;
            
            let targetsInRange = 0;
            let totalDistance = 0;
            
            // Count enemies within splash radius of this position
            sortedEnemies.forEach(enemyId => {
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (!enemyPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(enemyPos.x - centerPos.x, 2) + 
                    Math.pow(enemyPos.z - centerPos.z, 2)
                );
                
                if (distance <= this.splashRadius) {
                    targetsInRange++;
                    totalDistance += distance;
                }
            });
            
            // Calculate score: prioritize more targets, then lower total distance for tie-breaking
            const score = (targetsInRange * 1000) - totalDistance;
            
            // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)
            if (targetsInRange > maxTargetsHit || 
                (targetsInRange === maxTargetsHit && score >= bestScore)) {
                maxTargetsHit = targetsInRange;
                bestScore = score;
                bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };
            }
        });
        
        // If no good cluster found but we have enemies, target the first enemy deterministically
        if (!bestPosition && sortedEnemies.length > 0) {
            const firstEnemyPos = this.game.getComponent(sortedEnemies[0], this.componentTypes.POSITION);
            if (firstEnemyPos) {
                bestPosition = { x: firstEnemyPos.x, y: firstEnemyPos.y, z: firstEnemyPos.z };
            }
        }
        
        return bestPosition;
    }
};

// ========== CLASS REGISTRY ACCESSORS ==========

/**
 * Get a compiled class by name and type
 * This replaces the ModuleManager.getCompiledScript method for compiled bundles
 */
window.COMPILED_GAME.getClass = function(className, collectionType) {
    const collection = window.engine.app[collectionType];
    if (!collection) {
        console.error(`Collection ${collectionType} not found in compiled bundle`);
        return null;
    }
    
    const ClassDef = collection[className];
    if (!ClassDef) {
        console.error(`Class ${className} not found in collection ${collectionType}`);
        return null;
    }
    
    return ClassDef;
};

/**
 * Check if a class exists in the compiled bundle
 */
window.COMPILED_GAME.hasClass = function(className, collectionType) {
    const collection = window.engine.app[collectionType];
    return collection && collection[className] !== undefined;
};

// ========== INITIALIZATION ==========

/**
 * Initialize the compiled bundle - patches ModuleManager to prevent duplicate loading
 */
window.COMPILED_GAME.init = function(engine) {
    if (window.COMPILED_GAME.initialized) {
        console.log('Compiled game bundle already initialized');
        return;
    }

    console.log('Initializing compiled game bundle...');

    // Store original methods
    const originalGetCompiledScript = ModuleManager.prototype.getCompiledScript;
    const originalCompileScript = ModuleManager.prototype.compileScript;
    const originalCompileFunction = ModuleManager.prototype.compileFunction;

    // Patch getCompiledScript
    ModuleManager.prototype.getCompiledScript = function(typeName, collectionType) {
        if (window.COMPILED_GAME.hasClass(typeName, collectionType)) {
            return window.COMPILED_GAME.getClass(typeName, collectionType);
        }
        return originalGetCompiledScript.call(this, typeName, collectionType);
    };

    // Patch compileScript
    ModuleManager.prototype.compileScript = function(scriptText, typeName) {
        for (const collectionType in window.engine.app) {
            if (window.COMPILED_GAME.hasClass(typeName, collectionType)) {
                return window.COMPILED_GAME.getClass(typeName, collectionType);
            }
        }
        return originalCompileScript.call(this, scriptText, typeName);
    };

    // Patch compileFunction
    ModuleManager.prototype.compileFunction = function(scriptText, typeName) {
        if (window.COMPILED_GAME.hasClass(typeName, 'functions')) {
            return window.COMPILED_GAME.getClass(typeName, 'functions');
        }
        return originalCompileFunction.call(this, scriptText, typeName);
    };

    // Patch core.getCollections() to return compiled collections
    if (engine.core && typeof engine.core.getCollections === 'function') {
        const originalGetCollections = engine.core.getCollections.bind(engine.core);
        engine.core.getCollections = function() {
            if (window.COMPILED_GAME?.collections) {
                return window.COMPILED_GAME.collections;
            }
            return originalGetCollections();
        };
    }

    // Make library classes available
    if (engine.moduleManager) {
        engine.moduleManager.libraryClasses = {
            ...engine.moduleManager.libraryClasses,
            ...window.COMPILED_GAME.libraryClasses
        };
        window.GUTS = engine.moduleManager.libraryClasses;
    }

    window.COMPILED_GAME.initialized = true;
    console.log('Compiled game bundle initialized successfully');
};

// Wait for external libraries to load before allowing engine init
window.COMPILED_GAME.ready = new Promise((resolve) => {
    if (window.COMPILED_GAME.externalLibraries && window.COMPILED_GAME.externalLibraries.length > 0) {
        window.addEventListener('compiled-libraries-ready', () => {
            console.log('ðŸŽ® Compiled game ready');
            resolve();
        });
    } else {
        // No external libraries, ready immediately
        resolve();
    }
});